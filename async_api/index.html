<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>playwright.async_api API documentation</title>
<meta name="description" content="Python package `playwright` is a Python library to automate Chromium,
Firefox and WebKit with a single API. Playwright is built to enable …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>playwright.async_api</code></h1>
</header>
<section id="section-intro">
<p>Python package <code><a title="playwright" href="../index.html">playwright</a></code> is a Python library to automate Chromium,
Firefox and WebKit with a single API. Playwright is built to enable cross-browser
web automation that is ever-green, capable, reliable and fast.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) Microsoft Corporation.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;
Python package `playwright` is a Python library to automate Chromium,
Firefox and WebKit with a single API. Playwright is built to enable cross-browser
web automation that is ever-green, capable, reliable and fast.
&#34;&#34;&#34;

import playwright._impl._api_structures
import playwright._impl._api_types
import playwright.async_api._generated
from playwright.async_api._context_manager import PlaywrightContextManager
from playwright.async_api._generated import (
    Accessibility,
    BindingCall,
    Browser,
    BrowserContext,
    BrowserType,
    CDPSession,
    ChromiumBrowserContext,
    ConsoleMessage,
    Dialog,
    Download,
    ElementHandle,
    FileChooser,
    Frame,
    JSHandle,
    Keyboard,
    Mouse,
    Page,
    Playwright,
    Request,
    Response,
    Route,
    Selectors,
    Touchscreen,
    Video,
    WebSocket,
    Worker,
)

Cookie = playwright._impl._api_structures.Cookie
FilePayload = playwright._impl._api_structures.FilePayload
FloatRect = playwright._impl._api_structures.FloatRect
Geolocation = playwright._impl._api_structures.Geolocation
HttpCredentials = playwright._impl._api_structures.HttpCredentials
PdfMargins = playwright._impl._api_structures.PdfMargins
Position = playwright._impl._api_structures.Position
ProxySettings = playwright._impl._api_structures.ProxySettings
ResourceTiming = playwright._impl._api_structures.ResourceTiming
SourceLocation = playwright._impl._api_structures.SourceLocation
StorageState = playwright._impl._api_structures.StorageState
ViewportSize = playwright._impl._api_structures.ViewportSize

Error = playwright._impl._api_types.Error
TimeoutError = playwright._impl._api_types.TimeoutError


def async_playwright() -&gt; PlaywrightContextManager:
    return PlaywrightContextManager()


__all__ = [
    &#34;async_playwright&#34;,
    &#34;Accessibility&#34;,
    &#34;BindingCall&#34;,
    &#34;Browser&#34;,
    &#34;BrowserContext&#34;,
    &#34;BrowserType&#34;,
    &#34;CDPSession&#34;,
    &#34;ChromiumBrowserContext&#34;,
    &#34;ConsoleMessage&#34;,
    &#34;Cookie&#34;,
    &#34;Dialog&#34;,
    &#34;Download&#34;,
    &#34;ElementHandle&#34;,
    &#34;Error&#34;,
    &#34;FileChooser&#34;,
    &#34;FilePayload&#34;,
    &#34;FloatRect&#34;,
    &#34;Frame&#34;,
    &#34;Geolocation&#34;,
    &#34;HttpCredentials&#34;,
    &#34;JSHandle&#34;,
    &#34;Keyboard&#34;,
    &#34;Mouse&#34;,
    &#34;Page&#34;,
    &#34;PdfMargins&#34;,
    &#34;Position&#34;,
    &#34;Playwright&#34;,
    &#34;ProxySettings&#34;,
    &#34;Request&#34;,
    &#34;ResourceTiming&#34;,
    &#34;Response&#34;,
    &#34;Route&#34;,
    &#34;Selectors&#34;,
    &#34;SourceLocation&#34;,
    &#34;StorageState&#34;,
    &#34;sync_playwright&#34;,
    &#34;TimeoutError&#34;,
    &#34;Touchscreen&#34;,
    &#34;Video&#34;,
    &#34;ViewportSize&#34;,
    &#34;WebSocket&#34;,
    &#34;Worker&#34;,
]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="playwright.async_api.async_playwright"><code class="name flex">
<span>def <span class="ident">async_playwright</span></span>(<span>) ‑> playwright.async_api._context_manager.PlaywrightContextManager</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def async_playwright() -&gt; PlaywrightContextManager:
    return PlaywrightContextManager()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="playwright.async_api.Accessibility"><code class="flex name class">
<span>class <span class="ident">Accessibility</span></span>
<span>(</span><span>obj: playwright._impl._accessibility.Accessibility)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Accessibility(AsyncBase):
    def __init__(self, obj: AccessibilityImpl):
        super().__init__(obj)

    async def snapshot(
        self, interesting_only: bool = None, root: &#34;ElementHandle&#34; = None
    ) -&gt; typing.Union[typing.Dict, NoneType]:
        &#34;&#34;&#34;Accessibility.snapshot

        Captures the current state of the accessibility tree. The returned object represents the root accessible node of the
        page.

        &gt; NOTE: The Chromium accessibility tree contains nodes that go unused on most platforms and by most screen readers.
        Playwright will discard them as well for an easier to process tree, unless `interestingOnly` is set to `false`.

        An example of dumping the entire accessibility tree:

        ```py
        snapshot = await page.accessibility.snapshot()
        print(snapshot)
        ```

        An example of logging the focused node&#39;s name:

        ```py
        def find_focused_node(node):
            if (node.get(\&#34;focused\&#34;))
                return node
            for child in (node.get(\&#34;children\&#34;) or []):
                found_node = find_focused_node(child)
                return found_node
            return null

        snapshot = await page.accessibility.snapshot()
        node = find_focused_node(snapshot)
        if node:
            print(node[\&#34;name\&#34;])
        ```

        Parameters
        ----------
        interesting_only : Union[bool, NoneType]
            Prune uninteresting nodes from the tree. Defaults to `true`.
        root : Union[ElementHandle, NoneType]
            The root DOM element for the snapshot. Defaults to the whole page.

        Returns
        -------
        Union[Dict, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; accessibility.snapshot started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.snapshot(
                    interestingOnly=interesting_only, root=mapping.to_impl(root)
                )
            )
            log_api(&#34;&lt;= accessibility.snapshot succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= accessibility.snapshot failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Accessibility.snapshot"><code class="name flex">
<span>async def <span class="ident">snapshot</span></span>(<span>self, interesting_only: bool = None, root: <a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a> = None) ‑> Union[Dict, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Accessibility.snapshot</p>
<p>Captures the current state of the accessibility tree. The returned object represents the root accessible node of the
page.</p>
<blockquote>
<p>NOTE: The Chromium accessibility tree contains nodes that go unused on most platforms and by most screen readers.
Playwright will discard them as well for an easier to process tree, unless <code>interestingOnly</code> is set to <code>false</code>.</p>
</blockquote>
<p>An example of dumping the entire accessibility tree:</p>
<pre><code class="language-py">snapshot = await page.accessibility.snapshot()
print(snapshot)
</code></pre>
<p>An example of logging the focused node's name:</p>
<pre><code class="language-py">def find_focused_node(node):
    if (node.get(&quot;focused&quot;))
        return node
    for child in (node.get(&quot;children&quot;) or []):
        found_node = find_focused_node(child)
        return found_node
    return null

snapshot = await page.accessibility.snapshot()
node = find_focused_node(snapshot)
if node:
    print(node[&quot;name&quot;])
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>interesting_only</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Prune uninteresting nodes from the tree. Defaults to <code>true</code>.</dd>
<dt><strong><code>root</code></strong> :&ensp;<code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</code></dt>
<dd>The root DOM element for the snapshot. Defaults to the whole page.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[Dict, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def snapshot(
    self, interesting_only: bool = None, root: &#34;ElementHandle&#34; = None
) -&gt; typing.Union[typing.Dict, NoneType]:
    &#34;&#34;&#34;Accessibility.snapshot

    Captures the current state of the accessibility tree. The returned object represents the root accessible node of the
    page.

    &gt; NOTE: The Chromium accessibility tree contains nodes that go unused on most platforms and by most screen readers.
    Playwright will discard them as well for an easier to process tree, unless `interestingOnly` is set to `false`.

    An example of dumping the entire accessibility tree:

    ```py
    snapshot = await page.accessibility.snapshot()
    print(snapshot)
    ```

    An example of logging the focused node&#39;s name:

    ```py
    def find_focused_node(node):
        if (node.get(\&#34;focused\&#34;))
            return node
        for child in (node.get(\&#34;children\&#34;) or []):
            found_node = find_focused_node(child)
            return found_node
        return null

    snapshot = await page.accessibility.snapshot()
    node = find_focused_node(snapshot)
    if node:
        print(node[\&#34;name\&#34;])
    ```

    Parameters
    ----------
    interesting_only : Union[bool, NoneType]
        Prune uninteresting nodes from the tree. Defaults to `true`.
    root : Union[ElementHandle, NoneType]
        The root DOM element for the snapshot. Defaults to the whole page.

    Returns
    -------
    Union[Dict, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; accessibility.snapshot started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.snapshot(
                interestingOnly=interesting_only, root=mapping.to_impl(root)
            )
        )
        log_api(&#34;&lt;= accessibility.snapshot succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= accessibility.snapshot failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.BindingCall"><code class="flex name class">
<span>class <span class="ident">BindingCall</span></span>
<span>(</span><span>obj: playwright._impl._page.BindingCall)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BindingCall(AsyncBase):
    def __init__(self, obj: BindingCallImpl):
        super().__init__(obj)

    async def call(self, func: typing.Callable) -&gt; NoneType:

        try:
            log_api(&#34;=&gt; binding_call.call started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.call(func=self._wrap_handler(func))
            )
            log_api(&#34;&lt;= binding_call.call succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= binding_call.call failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.BindingCall.call"><code class="name flex">
<span>async def <span class="ident">call</span></span>(<span>self, func: Callable) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def call(self, func: typing.Callable) -&gt; NoneType:

    try:
        log_api(&#34;=&gt; binding_call.call started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.call(func=self._wrap_handler(func))
        )
        log_api(&#34;&lt;= binding_call.call succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= binding_call.call failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Browser"><code class="flex name class">
<span>class <span class="ident">Browser</span></span>
<span>(</span><span>obj: playwright._impl._browser.Browser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Browser(AsyncBase):
    def __init__(self, obj: BrowserImpl):
        super().__init__(obj)

    @property
    def contexts(self) -&gt; typing.List[&#34;BrowserContext&#34;]:
        &#34;&#34;&#34;Browser.contexts

        Returns an array of all open browser contexts. In a newly created browser, this will return zero browser contexts.

        ```py
        browser = await pw.webkit.launch()
        print(len(browser.contexts())) # prints `0`
        context = await browser.new_context()
        print(len(browser.contexts())) # prints `1`
        ```

        Returns
        -------
        List[BrowserContext]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.contexts)

    @property
    def version(self) -&gt; str:
        &#34;&#34;&#34;Browser.version

        Returns the browser version.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.version)

    def is_connected(self) -&gt; bool:
        &#34;&#34;&#34;Browser.is_connected

        Indicates that the browser is connected.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser.is_connected started&#34;)
            result = mapping.from_maybe_impl(self._impl_obj.is_connected())
            log_api(&#34;&lt;= browser.is_connected succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser.is_connected failed&#34;)
            raise e

    async def new_context(
        self,
        viewport: ViewportSize = None,
        no_viewport: bool = None,
        ignore_https_errors: bool = None,
        java_script_enabled: bool = None,
        bypass_csp: bool = None,
        user_agent: str = None,
        locale: str = None,
        timezone_id: str = None,
        geolocation: Geolocation = None,
        permissions: typing.List[str] = None,
        extra_http_headers: typing.Union[typing.Dict[str, str]] = None,
        offline: bool = None,
        http_credentials: HttpCredentials = None,
        device_scale_factor: float = None,
        is_mobile: bool = None,
        has_touch: bool = None,
        color_scheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
        accept_downloads: bool = None,
        default_browser_type: str = None,
        proxy: ProxySettings = None,
        record_har_path: typing.Union[str, pathlib.Path] = None,
        record_har_omit_content: bool = None,
        record_video_dir: typing.Union[str, pathlib.Path] = None,
        record_video_size: ViewportSize = None,
        storage_state: typing.Union[StorageState, str, pathlib.Path] = None,
    ) -&gt; &#34;BrowserContext&#34;:
        &#34;&#34;&#34;Browser.new_context

        Creates a new browser context. It won&#39;t share cookies/cache with other browser contexts.

        ```py
            browser = await playwright.firefox.launch() # or \&#34;chromium\&#34; or \&#34;webkit\&#34;.
            # create a new incognito browser context.
            context = await browser.new_context()
            # create a new page in a pristine context.
            page = await context.new_page()
            await page.goto(\&#34;https://example.com\&#34;)
        ```

        Parameters
        ----------
        viewport : Union[{width: int, height: int}, NoneType]
            Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed viewport.
        no_viewport : Union[bool, NoneType]
            Does not enforce fixed viewport, allows resizing window in the headed mode.
        ignore_https_errors : Union[bool, NoneType]
            Whether to ignore HTTPS errors during navigation. Defaults to `false`.
        java_script_enabled : Union[bool, NoneType]
            Whether or not to enable JavaScript in the context. Defaults to `true`.
        bypass_csp : Union[bool, NoneType]
            Toggles bypassing page&#39;s Content-Security-Policy.
        user_agent : Union[str, NoneType]
            Specific user agent to use in this context.
        locale : Union[str, NoneType]
            Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language`
            request header value as well as number and date formatting rules.
        timezone_id : Union[str, NoneType]
            Changes the timezone of the context. See
            [ICU&#39;s metaZones.txt](https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1)
            for a list of supported timezone IDs.
        geolocation : Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]
        permissions : Union[List[str], NoneType]
            A list of permissions to grant to all pages in this context. See `browser_context.grant_permissions()` for more
            details.
        extra_http_headers : Union[Dict[str, str], NoneType]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        offline : Union[bool, NoneType]
            Whether to emulate network being offline. Defaults to `false`.
        http_credentials : Union[{username: str, password: str}, NoneType]
            Credentials for [HTTP authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication).
        device_scale_factor : Union[float, NoneType]
            Specify device scale factor (can be thought of as dpr). Defaults to `1`.
        is_mobile : Union[bool, NoneType]
            Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported
            in Firefox.
        has_touch : Union[bool, NoneType]
            Specifies if viewport supports touch events. Defaults to false.
        color_scheme : Union[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;, NoneType]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See
            `page.emulate_media()` for more details. Defaults to &#39;`light`&#39;.
        accept_downloads : Union[bool, NoneType]
            Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
        proxy : Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]
            Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this
            option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example
            `launch({ proxy: { server: &#39;per-context&#39; } })`.
        record_har_path : Union[pathlib.Path, str, NoneType]
            Path on the filesystem to write the HAR file to.
        record_har_omit_content : Union[bool, NoneType]
            Optional setting to control whether to omit request content from the HAR. Defaults to `false`.
        record_video_dir : Union[pathlib.Path, str, NoneType]
            Path to the directory to put videos into.
        record_video_size : Union[{width: int, height: int}, NoneType]
            Optional dimensions of the recorded videos. If not specified the size will be equal to `viewport`.
        storage_state : Union[pathlib.Path, str, {cookies: Union[List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}], NoneType], origins: Union[List[{origin: str, localStorage: List[{name: str, value: str}]}], NoneType]}, NoneType]
            Populates context with given storage state. This method can be used to initialize context with logged-in information
            obtained via `browser_context.storage_state()`. Either a path to the file with saved storage, or an object with
            the following fields:

        Returns
        -------
        BrowserContext
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser.new_context started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.new_context(
                    viewport=viewport,
                    noViewport=no_viewport,
                    ignoreHTTPSErrors=ignore_https_errors,
                    javaScriptEnabled=java_script_enabled,
                    bypassCSP=bypass_csp,
                    userAgent=user_agent,
                    locale=locale,
                    timezoneId=timezone_id,
                    geolocation=geolocation,
                    permissions=permissions,
                    extraHTTPHeaders=mapping.to_impl(extra_http_headers),
                    offline=offline,
                    httpCredentials=http_credentials,
                    deviceScaleFactor=device_scale_factor,
                    isMobile=is_mobile,
                    hasTouch=has_touch,
                    colorScheme=color_scheme,
                    acceptDownloads=accept_downloads,
                    defaultBrowserType=default_browser_type,
                    proxy=proxy,
                    recordHarPath=record_har_path,
                    recordHarOmitContent=record_har_omit_content,
                    recordVideoDir=record_video_dir,
                    recordVideoSize=record_video_size,
                    storageState=storage_state,
                )
            )
            log_api(&#34;&lt;= browser.new_context succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser.new_context failed&#34;)
            raise e

    async def new_page(
        self,
        viewport: ViewportSize = None,
        no_viewport: bool = None,
        ignore_https_errors: bool = None,
        java_script_enabled: bool = None,
        bypass_csp: bool = None,
        user_agent: str = None,
        locale: str = None,
        timezone_id: str = None,
        geolocation: Geolocation = None,
        permissions: typing.List[str] = None,
        extra_http_headers: typing.Union[typing.Dict[str, str]] = None,
        offline: bool = None,
        http_credentials: HttpCredentials = None,
        device_scale_factor: float = None,
        is_mobile: bool = None,
        has_touch: bool = None,
        color_scheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
        accept_downloads: bool = None,
        default_browser_type: str = None,
        proxy: ProxySettings = None,
        record_har_path: typing.Union[str, pathlib.Path] = None,
        record_har_omit_content: bool = None,
        record_video_dir: typing.Union[str, pathlib.Path] = None,
        record_video_size: ViewportSize = None,
        storage_state: typing.Union[StorageState, str, pathlib.Path] = None,
    ) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;Browser.new_page

        Creates a new page in a new browser context. Closing this page will close the context as well.

        This is a convenience API that should only be used for the single-page scenarios and short snippets. Production code and
        testing frameworks should explicitly create `browser.new_context()` followed by the
        `browser_context.new_page()` to control their exact life times.

        Parameters
        ----------
        viewport : Union[{width: int, height: int}, NoneType]
            Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed viewport.
        no_viewport : Union[bool, NoneType]
            Does not enforce fixed viewport, allows resizing window in the headed mode.
        ignore_https_errors : Union[bool, NoneType]
            Whether to ignore HTTPS errors during navigation. Defaults to `false`.
        java_script_enabled : Union[bool, NoneType]
            Whether or not to enable JavaScript in the context. Defaults to `true`.
        bypass_csp : Union[bool, NoneType]
            Toggles bypassing page&#39;s Content-Security-Policy.
        user_agent : Union[str, NoneType]
            Specific user agent to use in this context.
        locale : Union[str, NoneType]
            Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language`
            request header value as well as number and date formatting rules.
        timezone_id : Union[str, NoneType]
            Changes the timezone of the context. See
            [ICU&#39;s metaZones.txt](https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1)
            for a list of supported timezone IDs.
        geolocation : Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]
        permissions : Union[List[str], NoneType]
            A list of permissions to grant to all pages in this context. See `browser_context.grant_permissions()` for more
            details.
        extra_http_headers : Union[Dict[str, str], NoneType]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        offline : Union[bool, NoneType]
            Whether to emulate network being offline. Defaults to `false`.
        http_credentials : Union[{username: str, password: str}, NoneType]
            Credentials for [HTTP authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication).
        device_scale_factor : Union[float, NoneType]
            Specify device scale factor (can be thought of as dpr). Defaults to `1`.
        is_mobile : Union[bool, NoneType]
            Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported
            in Firefox.
        has_touch : Union[bool, NoneType]
            Specifies if viewport supports touch events. Defaults to false.
        color_scheme : Union[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;, NoneType]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See
            `page.emulate_media()` for more details. Defaults to &#39;`light`&#39;.
        accept_downloads : Union[bool, NoneType]
            Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
        proxy : Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]
            Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this
            option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example
            `launch({ proxy: { server: &#39;per-context&#39; } })`.
        record_har_path : Union[pathlib.Path, str, NoneType]
            Path on the filesystem to write the HAR file to.
        record_har_omit_content : Union[bool, NoneType]
            Optional setting to control whether to omit request content from the HAR. Defaults to `false`.
        record_video_dir : Union[pathlib.Path, str, NoneType]
            Path to the directory to put videos into.
        record_video_size : Union[{width: int, height: int}, NoneType]
            Optional dimensions of the recorded videos. If not specified the size will be equal to `viewport`.
        storage_state : Union[pathlib.Path, str, {cookies: Union[List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}], NoneType], origins: Union[List[{origin: str, localStorage: List[{name: str, value: str}]}], NoneType]}, NoneType]
            Populates context with given storage state. This method can be used to initialize context with logged-in information
            obtained via `browser_context.storage_state()`. Either a path to the file with saved storage, or an object with
            the following fields:

        Returns
        -------
        Page
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser.new_page started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.new_page(
                    viewport=viewport,
                    noViewport=no_viewport,
                    ignoreHTTPSErrors=ignore_https_errors,
                    javaScriptEnabled=java_script_enabled,
                    bypassCSP=bypass_csp,
                    userAgent=user_agent,
                    locale=locale,
                    timezoneId=timezone_id,
                    geolocation=geolocation,
                    permissions=permissions,
                    extraHTTPHeaders=mapping.to_impl(extra_http_headers),
                    offline=offline,
                    httpCredentials=http_credentials,
                    deviceScaleFactor=device_scale_factor,
                    isMobile=is_mobile,
                    hasTouch=has_touch,
                    colorScheme=color_scheme,
                    acceptDownloads=accept_downloads,
                    defaultBrowserType=default_browser_type,
                    proxy=proxy,
                    recordHarPath=record_har_path,
                    recordHarOmitContent=record_har_omit_content,
                    recordVideoDir=record_video_dir,
                    recordVideoSize=record_video_size,
                    storageState=storage_state,
                )
            )
            log_api(&#34;&lt;= browser.new_page succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser.new_page failed&#34;)
            raise e

    async def close(self) -&gt; NoneType:
        &#34;&#34;&#34;Browser.close

        In case this browser is obtained using `browser_type.launch()`, closes the browser and all of its pages (if any
        were opened).

        In case this browser is connected to, clears all created contexts belonging to this browser and disconnects from the
        browser server.

        The `Browser` object itself is considered to be disposed and cannot be used anymore.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser.close started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.close())
            log_api(&#34;&lt;= browser.close succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser.close failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Browser.contexts"><code class="name">var <span class="ident">contexts</span> : List[playwright.async_api._generated.BrowserContext]</code></dt>
<dd>
<div class="desc"><p>Browser.contexts</p>
<p>Returns an array of all open browser contexts. In a newly created browser, this will return zero browser contexts.</p>
<pre><code class="language-py">browser = await pw.webkit.launch()
print(len(browser.contexts())) # prints `0`
context = await browser.new_context()
print(len(browser.contexts())) # prints `1`
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.BrowserContext" href="#playwright.async_api.BrowserContext">BrowserContext</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def contexts(self) -&gt; typing.List[&#34;BrowserContext&#34;]:
    &#34;&#34;&#34;Browser.contexts

    Returns an array of all open browser contexts. In a newly created browser, this will return zero browser contexts.

    ```py
    browser = await pw.webkit.launch()
    print(len(browser.contexts())) # prints `0`
    context = await browser.new_context()
    print(len(browser.contexts())) # prints `1`
    ```

    Returns
    -------
    List[BrowserContext]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.contexts)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Browser.version"><code class="name">var <span class="ident">version</span> : str</code></dt>
<dd>
<div class="desc"><p>Browser.version</p>
<p>Returns the browser version.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self) -&gt; str:
    &#34;&#34;&#34;Browser.version

    Returns the browser version.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.version)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Browser.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Browser.close</p>
<p>In case this browser is obtained using <code>browser_type.launch()</code>, closes the browser and all of its pages (if any
were opened).</p>
<p>In case this browser is connected to, clears all created contexts belonging to this browser and disconnects from the
browser server.</p>
<p>The <code><a title="playwright.async_api.Browser" href="#playwright.async_api.Browser">Browser</a></code> object itself is considered to be disposed and cannot be used anymore.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; NoneType:
    &#34;&#34;&#34;Browser.close

    In case this browser is obtained using `browser_type.launch()`, closes the browser and all of its pages (if any
    were opened).

    In case this browser is connected to, clears all created contexts belonging to this browser and disconnects from the
    browser server.

    The `Browser` object itself is considered to be disposed and cannot be used anymore.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser.close started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.close())
        log_api(&#34;&lt;= browser.close succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser.close failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Browser.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Browser.is_connected</p>
<p>Indicates that the browser is connected.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self) -&gt; bool:
    &#34;&#34;&#34;Browser.is_connected

    Indicates that the browser is connected.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser.is_connected started&#34;)
        result = mapping.from_maybe_impl(self._impl_obj.is_connected())
        log_api(&#34;&lt;= browser.is_connected succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser.is_connected failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Browser.new_context"><code class="name flex">
<span>async def <span class="ident">new_context</span></span>(<span>self, viewport: playwright._impl._api_structures.ViewportSize = None, no_viewport: bool = None, ignore_https_errors: bool = None, java_script_enabled: bool = None, bypass_csp: bool = None, user_agent: str = None, locale: str = None, timezone_id: str = None, geolocation: playwright._impl._api_structures.Geolocation = None, permissions: List[str] = None, extra_http_headers: Dict[str, str] = None, offline: bool = None, http_credentials: playwright._impl._api_structures.HttpCredentials = None, device_scale_factor: float = None, is_mobile: bool = None, has_touch: bool = None, color_scheme: Literal['dark', 'light', 'no-preference'] = None, accept_downloads: bool = None, default_browser_type: str = None, proxy: playwright._impl._api_structures.ProxySettings = None, record_har_path: Union[str, pathlib.Path] = None, record_har_omit_content: bool = None, record_video_dir: Union[str, pathlib.Path] = None, record_video_size: playwright._impl._api_structures.ViewportSize = None, storage_state: Union[playwright._impl._api_structures.StorageState, str, pathlib.Path] = None) ‑> playwright.async_api._generated.BrowserContext</span>
</code></dt>
<dd>
<div class="desc"><p>Browser.new_context</p>
<p>Creates a new browser context. It won't share cookies/cache with other browser contexts.</p>
<pre><code class="language-py">    browser = await playwright.firefox.launch() # or &quot;chromium&quot; or &quot;webkit&quot;.
    # create a new incognito browser context.
    context = await browser.new_context()
    # create a new page in a pristine context.
    page = await context.new_page()
    await page.goto(&quot;https://example.com&quot;)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Union[{width: int, height: int}, NoneType]</code></dt>
<dd>Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. <code>no_viewport</code> disables the fixed viewport.</dd>
<dt><strong><code>no_viewport</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Does not enforce fixed viewport, allows resizing window in the headed mode.</dd>
<dt><strong><code>ignore_https_errors</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to ignore HTTPS errors during navigation. Defaults to <code>false</code>.</dd>
<dt><strong><code>java_script_enabled</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether or not to enable JavaScript in the context. Defaults to <code>true</code>.</dd>
<dt><strong><code>bypass_csp</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Toggles bypassing page's Content-Security-Policy.</dd>
<dt><strong><code>user_agent</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Specific user agent to use in this context.</dd>
<dt><strong><code>locale</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Specify user locale, for example <code>en-GB</code>, <code>de-DE</code>, etc. Locale will affect <code>navigator.language</code> value, <code>Accept-Language</code>
request header value as well as number and date formatting rules.</dd>
<dt><strong><code>timezone_id</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Changes the timezone of the context. See
<a href="https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1">ICU's metaZones.txt</a>
for a list of supported timezone IDs.</dd>
<dt><strong><code>geolocation</code></strong> :&ensp;<code>Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code>Union[List[str], NoneType]</code></dt>
<dd>A list of permissions to grant to all pages in this context. See <code>browser_context.grant_permissions()</code> for more
details.</dd>
<dt><strong><code>extra_http_headers</code></strong> :&ensp;<code>Union[Dict[str, str], NoneType]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
<dt><strong><code>offline</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to emulate network being offline. Defaults to <code>false</code>.</dd>
<dt><strong><code>http_credentials</code></strong> :&ensp;<code>Union[{username: str, password: str}, NoneType]</code></dt>
<dd>Credentials for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication">HTTP authentication</a>.</dd>
<dt><strong><code>device_scale_factor</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Specify device scale factor (can be thought of as dpr). Defaults to <code>1</code>.</dd>
<dt><strong><code>is_mobile</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether the <code>meta viewport</code> tag is taken into account and touch events are enabled. Defaults to <code>false</code>. Not supported
in Firefox.</dd>
<dt><strong><code>has_touch</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Specifies if viewport supports touch events. Defaults to false.</dd>
<dt><strong><code>color_scheme</code></strong> :&ensp;<code>Union["dark", "light", "no-preference", NoneType]</code></dt>
<dd>Emulates <code>'prefers-colors-scheme'</code> media feature, supported values are <code>'light'</code>, <code>'dark'</code>, <code>'no-preference'</code>. See
<code>page.emulate_media()</code> for more details. Defaults to '<code>light</code>'.</dd>
<dt><strong><code>accept_downloads</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to automatically download all the attachments. Defaults to <code>false</code> where all the downloads are canceled.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]</code></dt>
<dd>Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this
option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example
<code>launch({ proxy: { server: 'per-context' } })</code>.</dd>
<dt><strong><code>record_har_path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path on the filesystem to write the HAR file to.</dd>
<dt><strong><code>record_har_omit_content</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Optional setting to control whether to omit request content from the HAR. Defaults to <code>false</code>.</dd>
<dt><strong><code>record_video_dir</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the directory to put videos into.</dd>
<dt><strong><code>record_video_size</code></strong> :&ensp;<code>Union[{width: int, height: int}, NoneType]</code></dt>
<dd>Optional dimensions of the recorded videos. If not specified the size will be equal to <code>viewport</code>.</dd>
<dt><strong><code>storage_state</code></strong> :&ensp;<code>Union[pathlib.Path, str, {cookies: Union[List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union["Lax", "None", "Strict", NoneType]}], NoneType], origins: Union[List[{origin: str, localStorage: List[{name: str, value: str}]}], NoneType]}, NoneType]</code></dt>
<dd>Populates context with given storage state. This method can be used to initialize context with logged-in information
obtained via <code>browser_context.storage_state()</code>. Either a path to the file with saved storage, or an object with
the following fields:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.BrowserContext" href="#playwright.async_api.BrowserContext">BrowserContext</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def new_context(
    self,
    viewport: ViewportSize = None,
    no_viewport: bool = None,
    ignore_https_errors: bool = None,
    java_script_enabled: bool = None,
    bypass_csp: bool = None,
    user_agent: str = None,
    locale: str = None,
    timezone_id: str = None,
    geolocation: Geolocation = None,
    permissions: typing.List[str] = None,
    extra_http_headers: typing.Union[typing.Dict[str, str]] = None,
    offline: bool = None,
    http_credentials: HttpCredentials = None,
    device_scale_factor: float = None,
    is_mobile: bool = None,
    has_touch: bool = None,
    color_scheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
    accept_downloads: bool = None,
    default_browser_type: str = None,
    proxy: ProxySettings = None,
    record_har_path: typing.Union[str, pathlib.Path] = None,
    record_har_omit_content: bool = None,
    record_video_dir: typing.Union[str, pathlib.Path] = None,
    record_video_size: ViewportSize = None,
    storage_state: typing.Union[StorageState, str, pathlib.Path] = None,
) -&gt; &#34;BrowserContext&#34;:
    &#34;&#34;&#34;Browser.new_context

    Creates a new browser context. It won&#39;t share cookies/cache with other browser contexts.

    ```py
        browser = await playwright.firefox.launch() # or \&#34;chromium\&#34; or \&#34;webkit\&#34;.
        # create a new incognito browser context.
        context = await browser.new_context()
        # create a new page in a pristine context.
        page = await context.new_page()
        await page.goto(\&#34;https://example.com\&#34;)
    ```

    Parameters
    ----------
    viewport : Union[{width: int, height: int}, NoneType]
        Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed viewport.
    no_viewport : Union[bool, NoneType]
        Does not enforce fixed viewport, allows resizing window in the headed mode.
    ignore_https_errors : Union[bool, NoneType]
        Whether to ignore HTTPS errors during navigation. Defaults to `false`.
    java_script_enabled : Union[bool, NoneType]
        Whether or not to enable JavaScript in the context. Defaults to `true`.
    bypass_csp : Union[bool, NoneType]
        Toggles bypassing page&#39;s Content-Security-Policy.
    user_agent : Union[str, NoneType]
        Specific user agent to use in this context.
    locale : Union[str, NoneType]
        Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language`
        request header value as well as number and date formatting rules.
    timezone_id : Union[str, NoneType]
        Changes the timezone of the context. See
        [ICU&#39;s metaZones.txt](https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1)
        for a list of supported timezone IDs.
    geolocation : Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]
    permissions : Union[List[str], NoneType]
        A list of permissions to grant to all pages in this context. See `browser_context.grant_permissions()` for more
        details.
    extra_http_headers : Union[Dict[str, str], NoneType]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    offline : Union[bool, NoneType]
        Whether to emulate network being offline. Defaults to `false`.
    http_credentials : Union[{username: str, password: str}, NoneType]
        Credentials for [HTTP authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication).
    device_scale_factor : Union[float, NoneType]
        Specify device scale factor (can be thought of as dpr). Defaults to `1`.
    is_mobile : Union[bool, NoneType]
        Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported
        in Firefox.
    has_touch : Union[bool, NoneType]
        Specifies if viewport supports touch events. Defaults to false.
    color_scheme : Union[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;, NoneType]
        Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See
        `page.emulate_media()` for more details. Defaults to &#39;`light`&#39;.
    accept_downloads : Union[bool, NoneType]
        Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
    proxy : Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]
        Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this
        option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example
        `launch({ proxy: { server: &#39;per-context&#39; } })`.
    record_har_path : Union[pathlib.Path, str, NoneType]
        Path on the filesystem to write the HAR file to.
    record_har_omit_content : Union[bool, NoneType]
        Optional setting to control whether to omit request content from the HAR. Defaults to `false`.
    record_video_dir : Union[pathlib.Path, str, NoneType]
        Path to the directory to put videos into.
    record_video_size : Union[{width: int, height: int}, NoneType]
        Optional dimensions of the recorded videos. If not specified the size will be equal to `viewport`.
    storage_state : Union[pathlib.Path, str, {cookies: Union[List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}], NoneType], origins: Union[List[{origin: str, localStorage: List[{name: str, value: str}]}], NoneType]}, NoneType]
        Populates context with given storage state. This method can be used to initialize context with logged-in information
        obtained via `browser_context.storage_state()`. Either a path to the file with saved storage, or an object with
        the following fields:

    Returns
    -------
    BrowserContext
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser.new_context started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.new_context(
                viewport=viewport,
                noViewport=no_viewport,
                ignoreHTTPSErrors=ignore_https_errors,
                javaScriptEnabled=java_script_enabled,
                bypassCSP=bypass_csp,
                userAgent=user_agent,
                locale=locale,
                timezoneId=timezone_id,
                geolocation=geolocation,
                permissions=permissions,
                extraHTTPHeaders=mapping.to_impl(extra_http_headers),
                offline=offline,
                httpCredentials=http_credentials,
                deviceScaleFactor=device_scale_factor,
                isMobile=is_mobile,
                hasTouch=has_touch,
                colorScheme=color_scheme,
                acceptDownloads=accept_downloads,
                defaultBrowserType=default_browser_type,
                proxy=proxy,
                recordHarPath=record_har_path,
                recordHarOmitContent=record_har_omit_content,
                recordVideoDir=record_video_dir,
                recordVideoSize=record_video_size,
                storageState=storage_state,
            )
        )
        log_api(&#34;&lt;= browser.new_context succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser.new_context failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Browser.new_page"><code class="name flex">
<span>async def <span class="ident">new_page</span></span>(<span>self, viewport: playwright._impl._api_structures.ViewportSize = None, no_viewport: bool = None, ignore_https_errors: bool = None, java_script_enabled: bool = None, bypass_csp: bool = None, user_agent: str = None, locale: str = None, timezone_id: str = None, geolocation: playwright._impl._api_structures.Geolocation = None, permissions: List[str] = None, extra_http_headers: Dict[str, str] = None, offline: bool = None, http_credentials: playwright._impl._api_structures.HttpCredentials = None, device_scale_factor: float = None, is_mobile: bool = None, has_touch: bool = None, color_scheme: Literal['dark', 'light', 'no-preference'] = None, accept_downloads: bool = None, default_browser_type: str = None, proxy: playwright._impl._api_structures.ProxySettings = None, record_har_path: Union[str, pathlib.Path] = None, record_har_omit_content: bool = None, record_video_dir: Union[str, pathlib.Path] = None, record_video_size: playwright._impl._api_structures.ViewportSize = None, storage_state: Union[playwright._impl._api_structures.StorageState, str, pathlib.Path] = None) ‑> playwright.async_api._generated.Page</span>
</code></dt>
<dd>
<div class="desc"><p>Browser.new_page</p>
<p>Creates a new page in a new browser context. Closing this page will close the context as well.</p>
<p>This is a convenience API that should only be used for the single-page scenarios and short snippets. Production code and
testing frameworks should explicitly create <code>browser.new_context()</code> followed by the
<code>browser_context.new_page()</code> to control their exact life times.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Union[{width: int, height: int}, NoneType]</code></dt>
<dd>Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. <code>no_viewport</code> disables the fixed viewport.</dd>
<dt><strong><code>no_viewport</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Does not enforce fixed viewport, allows resizing window in the headed mode.</dd>
<dt><strong><code>ignore_https_errors</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to ignore HTTPS errors during navigation. Defaults to <code>false</code>.</dd>
<dt><strong><code>java_script_enabled</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether or not to enable JavaScript in the context. Defaults to <code>true</code>.</dd>
<dt><strong><code>bypass_csp</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Toggles bypassing page's Content-Security-Policy.</dd>
<dt><strong><code>user_agent</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Specific user agent to use in this context.</dd>
<dt><strong><code>locale</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Specify user locale, for example <code>en-GB</code>, <code>de-DE</code>, etc. Locale will affect <code>navigator.language</code> value, <code>Accept-Language</code>
request header value as well as number and date formatting rules.</dd>
<dt><strong><code>timezone_id</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Changes the timezone of the context. See
<a href="https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1">ICU's metaZones.txt</a>
for a list of supported timezone IDs.</dd>
<dt><strong><code>geolocation</code></strong> :&ensp;<code>Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code>Union[List[str], NoneType]</code></dt>
<dd>A list of permissions to grant to all pages in this context. See <code>browser_context.grant_permissions()</code> for more
details.</dd>
<dt><strong><code>extra_http_headers</code></strong> :&ensp;<code>Union[Dict[str, str], NoneType]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
<dt><strong><code>offline</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to emulate network being offline. Defaults to <code>false</code>.</dd>
<dt><strong><code>http_credentials</code></strong> :&ensp;<code>Union[{username: str, password: str}, NoneType]</code></dt>
<dd>Credentials for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication">HTTP authentication</a>.</dd>
<dt><strong><code>device_scale_factor</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Specify device scale factor (can be thought of as dpr). Defaults to <code>1</code>.</dd>
<dt><strong><code>is_mobile</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether the <code>meta viewport</code> tag is taken into account and touch events are enabled. Defaults to <code>false</code>. Not supported
in Firefox.</dd>
<dt><strong><code>has_touch</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Specifies if viewport supports touch events. Defaults to false.</dd>
<dt><strong><code>color_scheme</code></strong> :&ensp;<code>Union["dark", "light", "no-preference", NoneType]</code></dt>
<dd>Emulates <code>'prefers-colors-scheme'</code> media feature, supported values are <code>'light'</code>, <code>'dark'</code>, <code>'no-preference'</code>. See
<code>page.emulate_media()</code> for more details. Defaults to '<code>light</code>'.</dd>
<dt><strong><code>accept_downloads</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to automatically download all the attachments. Defaults to <code>false</code> where all the downloads are canceled.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]</code></dt>
<dd>Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this
option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example
<code>launch({ proxy: { server: 'per-context' } })</code>.</dd>
<dt><strong><code>record_har_path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path on the filesystem to write the HAR file to.</dd>
<dt><strong><code>record_har_omit_content</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Optional setting to control whether to omit request content from the HAR. Defaults to <code>false</code>.</dd>
<dt><strong><code>record_video_dir</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the directory to put videos into.</dd>
<dt><strong><code>record_video_size</code></strong> :&ensp;<code>Union[{width: int, height: int}, NoneType]</code></dt>
<dd>Optional dimensions of the recorded videos. If not specified the size will be equal to <code>viewport</code>.</dd>
<dt><strong><code>storage_state</code></strong> :&ensp;<code>Union[pathlib.Path, str, {cookies: Union[List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union["Lax", "None", "Strict", NoneType]}], NoneType], origins: Union[List[{origin: str, localStorage: List[{name: str, value: str}]}], NoneType]}, NoneType]</code></dt>
<dd>Populates context with given storage state. This method can be used to initialize context with logged-in information
obtained via <code>browser_context.storage_state()</code>. Either a path to the file with saved storage, or an object with
the following fields:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def new_page(
    self,
    viewport: ViewportSize = None,
    no_viewport: bool = None,
    ignore_https_errors: bool = None,
    java_script_enabled: bool = None,
    bypass_csp: bool = None,
    user_agent: str = None,
    locale: str = None,
    timezone_id: str = None,
    geolocation: Geolocation = None,
    permissions: typing.List[str] = None,
    extra_http_headers: typing.Union[typing.Dict[str, str]] = None,
    offline: bool = None,
    http_credentials: HttpCredentials = None,
    device_scale_factor: float = None,
    is_mobile: bool = None,
    has_touch: bool = None,
    color_scheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
    accept_downloads: bool = None,
    default_browser_type: str = None,
    proxy: ProxySettings = None,
    record_har_path: typing.Union[str, pathlib.Path] = None,
    record_har_omit_content: bool = None,
    record_video_dir: typing.Union[str, pathlib.Path] = None,
    record_video_size: ViewportSize = None,
    storage_state: typing.Union[StorageState, str, pathlib.Path] = None,
) -&gt; &#34;Page&#34;:
    &#34;&#34;&#34;Browser.new_page

    Creates a new page in a new browser context. Closing this page will close the context as well.

    This is a convenience API that should only be used for the single-page scenarios and short snippets. Production code and
    testing frameworks should explicitly create `browser.new_context()` followed by the
    `browser_context.new_page()` to control their exact life times.

    Parameters
    ----------
    viewport : Union[{width: int, height: int}, NoneType]
        Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed viewport.
    no_viewport : Union[bool, NoneType]
        Does not enforce fixed viewport, allows resizing window in the headed mode.
    ignore_https_errors : Union[bool, NoneType]
        Whether to ignore HTTPS errors during navigation. Defaults to `false`.
    java_script_enabled : Union[bool, NoneType]
        Whether or not to enable JavaScript in the context. Defaults to `true`.
    bypass_csp : Union[bool, NoneType]
        Toggles bypassing page&#39;s Content-Security-Policy.
    user_agent : Union[str, NoneType]
        Specific user agent to use in this context.
    locale : Union[str, NoneType]
        Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language`
        request header value as well as number and date formatting rules.
    timezone_id : Union[str, NoneType]
        Changes the timezone of the context. See
        [ICU&#39;s metaZones.txt](https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1)
        for a list of supported timezone IDs.
    geolocation : Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]
    permissions : Union[List[str], NoneType]
        A list of permissions to grant to all pages in this context. See `browser_context.grant_permissions()` for more
        details.
    extra_http_headers : Union[Dict[str, str], NoneType]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    offline : Union[bool, NoneType]
        Whether to emulate network being offline. Defaults to `false`.
    http_credentials : Union[{username: str, password: str}, NoneType]
        Credentials for [HTTP authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication).
    device_scale_factor : Union[float, NoneType]
        Specify device scale factor (can be thought of as dpr). Defaults to `1`.
    is_mobile : Union[bool, NoneType]
        Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported
        in Firefox.
    has_touch : Union[bool, NoneType]
        Specifies if viewport supports touch events. Defaults to false.
    color_scheme : Union[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;, NoneType]
        Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See
        `page.emulate_media()` for more details. Defaults to &#39;`light`&#39;.
    accept_downloads : Union[bool, NoneType]
        Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
    proxy : Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]
        Network proxy settings to use with this context. Note that browser needs to be launched with the global proxy for this
        option to work. If all contexts override the proxy, global proxy will be never used and can be any string, for example
        `launch({ proxy: { server: &#39;per-context&#39; } })`.
    record_har_path : Union[pathlib.Path, str, NoneType]
        Path on the filesystem to write the HAR file to.
    record_har_omit_content : Union[bool, NoneType]
        Optional setting to control whether to omit request content from the HAR. Defaults to `false`.
    record_video_dir : Union[pathlib.Path, str, NoneType]
        Path to the directory to put videos into.
    record_video_size : Union[{width: int, height: int}, NoneType]
        Optional dimensions of the recorded videos. If not specified the size will be equal to `viewport`.
    storage_state : Union[pathlib.Path, str, {cookies: Union[List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}], NoneType], origins: Union[List[{origin: str, localStorage: List[{name: str, value: str}]}], NoneType]}, NoneType]
        Populates context with given storage state. This method can be used to initialize context with logged-in information
        obtained via `browser_context.storage_state()`. Either a path to the file with saved storage, or an object with
        the following fields:

    Returns
    -------
    Page
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser.new_page started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.new_page(
                viewport=viewport,
                noViewport=no_viewport,
                ignoreHTTPSErrors=ignore_https_errors,
                javaScriptEnabled=java_script_enabled,
                bypassCSP=bypass_csp,
                userAgent=user_agent,
                locale=locale,
                timezoneId=timezone_id,
                geolocation=geolocation,
                permissions=permissions,
                extraHTTPHeaders=mapping.to_impl(extra_http_headers),
                offline=offline,
                httpCredentials=http_credentials,
                deviceScaleFactor=device_scale_factor,
                isMobile=is_mobile,
                hasTouch=has_touch,
                colorScheme=color_scheme,
                acceptDownloads=accept_downloads,
                defaultBrowserType=default_browser_type,
                proxy=proxy,
                recordHarPath=record_har_path,
                recordHarOmitContent=record_har_omit_content,
                recordVideoDir=record_video_dir,
                recordVideoSize=record_video_size,
                storageState=storage_state,
            )
        )
        log_api(&#34;&lt;= browser.new_page succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser.new_page failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.BrowserContext"><code class="flex name class">
<span>class <span class="ident">BrowserContext</span></span>
<span>(</span><span>obj: playwright._impl._browser_context.BrowserContext)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BrowserContext(AsyncBase):
    def __init__(self, obj: BrowserContextImpl):
        super().__init__(obj)

    @property
    def pages(self) -&gt; typing.List[&#34;Page&#34;]:
        &#34;&#34;&#34;BrowserContext.pages

        Returns all open pages in the context. Non visible pages, such as `\&#34;background_page\&#34;`, will not be listed here. You can
        find them using `chromium_browser_context.background_pages()`.

        Returns
        -------
        List[Page]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.pages)

    @property
    def browser(self) -&gt; typing.Union[&#34;Browser&#34;, NoneType]:
        &#34;&#34;&#34;BrowserContext.browser

        Returns the browser instance of the context. If it was launched as a persistent context null gets returned.

        Returns
        -------
        Union[Browser, NoneType]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.browser)

    def set_default_navigation_timeout(self, timeout: float) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.set_default_navigation_timeout

        This setting will change the default maximum navigation time for the following methods and related shortcuts:
        - `page.go_back()`
        - `page.go_forward()`
        - `page.goto()`
        - `page.reload()`
        - `page.set_content()`
        - `page.wait_for_navigation()`

        &gt; NOTE: `page.set_default_navigation_timeout()` and `page.set_default_timeout()` take priority over
        `browser_context.set_default_navigation_timeout()`.

        Parameters
        ----------
        timeout : float
            Maximum navigation time in milliseconds
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.set_default_navigation_timeout started&#34;)
            result = mapping.from_maybe_impl(
                self._impl_obj.set_default_navigation_timeout(timeout=timeout)
            )
            log_api(&#34;&lt;= browser_context.set_default_navigation_timeout succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.set_default_navigation_timeout failed&#34;)
            raise e

    def set_default_timeout(self, timeout: float) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.set_default_timeout

        This setting will change the default maximum time for all the methods accepting `timeout` option.

        &gt; NOTE: `page.set_default_navigation_timeout()`, `page.set_default_timeout()` and
        `browser_context.set_default_navigation_timeout()` take priority over `browser_context.set_default_timeout()`.

        Parameters
        ----------
        timeout : float
            Maximum time in milliseconds
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.set_default_timeout started&#34;)
            result = mapping.from_maybe_impl(
                self._impl_obj.set_default_timeout(timeout=timeout)
            )
            log_api(&#34;&lt;= browser_context.set_default_timeout succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.set_default_timeout failed&#34;)
            raise e

    async def new_page(self) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;BrowserContext.new_page

        Creates a new page in the browser context.

        Returns
        -------
        Page
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.new_page started&#34;)
            result = mapping.from_impl(await self._impl_obj.new_page())
            log_api(&#34;&lt;= browser_context.new_page succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.new_page failed&#34;)
            raise e

    async def cookies(
        self, urls: typing.Union[str, typing.List[str]] = None
    ) -&gt; typing.List[Cookie]:
        &#34;&#34;&#34;BrowserContext.cookies

        If no URLs are specified, this method returns all cookies. If URLs are specified, only cookies that affect those URLs
        are returned.

        Parameters
        ----------
        urls : Union[List[str], str, NoneType]
            Optional list of URLs.

        Returns
        -------
        List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.cookies started&#34;)
            result = mapping.from_impl_list(await self._impl_obj.cookies(urls=urls))
            log_api(&#34;&lt;= browser_context.cookies succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.cookies failed&#34;)
            raise e

    async def add_cookies(self, cookies: typing.List[Cookie]) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.add_cookies

        Adds cookies into this browser context. All pages within this context will have these cookies installed. Cookies can be
        obtained via `browser_context.cookies()`.

        ```py
        await browser_context.add_cookies([cookie_object1, cookie_object2])
        ```

        Parameters
        ----------
        cookies : List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.add_cookies started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.add_cookies(cookies=cookies)
            )
            log_api(&#34;&lt;= browser_context.add_cookies succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.add_cookies failed&#34;)
            raise e

    async def clear_cookies(self) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.clear_cookies

        Clears context cookies.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.clear_cookies started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.clear_cookies())
            log_api(&#34;&lt;= browser_context.clear_cookies succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.clear_cookies failed&#34;)
            raise e

    async def grant_permissions(
        self, permissions: typing.List[str], origin: str = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.grant_permissions

        Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if
        specified.

        Parameters
        ----------
        permissions : List[str]
            A permission or an array of permissions to grant. Permissions can be one of the following values:
            - `&#39;geolocation&#39;`
            - `&#39;midi&#39;`
            - `&#39;midi-sysex&#39;` (system-exclusive midi)
            - `&#39;notifications&#39;`
            - `&#39;push&#39;`
            - `&#39;camera&#39;`
            - `&#39;microphone&#39;`
            - `&#39;background-sync&#39;`
            - `&#39;ambient-light-sensor&#39;`
            - `&#39;accelerometer&#39;`
            - `&#39;gyroscope&#39;`
            - `&#39;magnetometer&#39;`
            - `&#39;accessibility-events&#39;`
            - `&#39;clipboard-read&#39;`
            - `&#39;clipboard-write&#39;`
            - `&#39;payment-handler&#39;`
        origin : Union[str, NoneType]
            The [origin] to grant permissions to, e.g. &#34;https://example.com&#34;.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.grant_permissions started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.grant_permissions(
                    permissions=permissions, origin=origin
                )
            )
            log_api(&#34;&lt;= browser_context.grant_permissions succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.grant_permissions failed&#34;)
            raise e

    async def clear_permissions(self) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.clear_permissions

        Clears all permission overrides for the browser context.

        ```py
        context = await browser.new_context()
        await context.grant_permissions([\&#34;clipboard-read\&#34;])
        # do stuff ..
        context.clear_permissions()
        ```
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.clear_permissions started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.clear_permissions())
            log_api(&#34;&lt;= browser_context.clear_permissions succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.clear_permissions failed&#34;)
            raise e

    async def set_geolocation(self, geolocation: Geolocation = None) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.set_geolocation

        Sets the context&#39;s geolocation. Passing `null` or `undefined` emulates position unavailable.

        ```py
        await browser_context.set_geolocation({\&#34;latitude\&#34;: 59.95, \&#34;longitude\&#34;: 30.31667})
        ```

        &gt; NOTE: Consider using `browser_context.grant_permissions()` to grant permissions for the browser context pages to
        read its geolocation.

        Parameters
        ----------
        geolocation : Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.set_geolocation started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_geolocation(geolocation=geolocation)
            )
            log_api(&#34;&lt;= browser_context.set_geolocation succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.set_geolocation failed&#34;)
            raise e

    async def set_extra_http_headers(self, headers: typing.Dict[str, str]) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.set_extra_http_headers

        The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged
        with page-specific extra HTTP headers set with `page.set_extra_http_headers()`. If page overrides a particular
        header, page-specific header value will be used instead of the browser context header value.

        &gt; NOTE: `browser_context.set_extra_http_headers()` does not guarantee the order of headers in the outgoing requests.

        Parameters
        ----------
        headers : Dict[str, str]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.set_extra_http_headers started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_extra_http_headers(
                    headers=mapping.to_impl(headers)
                )
            )
            log_api(&#34;&lt;= browser_context.set_extra_http_headers succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.set_extra_http_headers failed&#34;)
            raise e

    async def set_offline(self, offline: bool) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.set_offline

        Parameters
        ----------
        offline : bool
            Whether to emulate network being offline for the browser context.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.set_offline started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_offline(offline=offline)
            )
            log_api(&#34;&lt;= browser_context.set_offline succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.set_offline failed&#34;)
            raise e

    async def add_init_script(
        self, script: str = None, path: typing.Union[str, pathlib.Path] = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.add_init_script

        Adds a script which would be evaluated in one of the following scenarios:
        - Whenever a page is created in the browser context or is navigated.
        - Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is
          evaluated in the context of the newly attached frame.

        The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
        the JavaScript environment, e.g. to seed `Math.random`.

        An example of overriding `Math.random` before the page loads:

        ```py
        # in your playwright script, assuming the preload.js file is in same directory.
        await browser_context.add_init_script(path=\&#34;preload.js\&#34;)
        ```

        &gt; NOTE: The order of evaluation of multiple scripts installed via `browser_context.add_init_script()` and
        `page.add_init_script()` is not defined.

        Parameters
        ----------
        script : Union[str, NoneType]
            Script to be evaluated in all pages in the browser context. Optional.
        path : Union[pathlib.Path, str, NoneType]
            Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to the current working
            directory. Optional.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.add_init_script started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.add_init_script(script=script, path=path)
            )
            log_api(&#34;&lt;= browser_context.add_init_script succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.add_init_script failed&#34;)
            raise e

    async def expose_binding(
        self, name: str, callback: typing.Callable, handle: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.expose_binding

        The method adds a function called `name` on the `window` object of every frame in every page in the context. When
        called, the function executes `callback` and returns a [Promise] which resolves to the return value of `callback`. If
        the `callback` returns a [Promise], it will be awaited.

        The first argument of the `callback` function contains information about the caller: `{ browserContext: BrowserContext,
        page: Page, frame: Frame }`.

        See `page.expose_binding()` for page-only version.

        An example of exposing page URL to all frames in all pages in the context:

        ```py
        import asyncio
        from playwright.async_api import async_playwright

        async def run(playwright):
            webkit = playwright.webkit
            browser = await webkit.launch(headless=false)
            context = await browser.new_context()
            await context.expose_binding(\&#34;pageURL\&#34;, lambda source: source[\&#34;page\&#34;].url)
            page = await context.new_page()
            await page.set_content(\&#34;\&#34;\&#34;
            &lt;script&gt;
              async function onClick() {
                document.querySelector(&#39;div&#39;).textContent = await window.pageURL();
              }
            &lt;/script&gt;
            &lt;button onclick=\&#34;onClick()\&#34;&gt;Click me&lt;/button&gt;
            &lt;div&gt;&lt;/div&gt;
            \&#34;\&#34;\&#34;)
            await page.click(\&#34;button\&#34;)

        async def main():
            async with async_playwright() as playwright:
                await run(playwright)
        asyncio.run(main())
        ```

        An example of passing an element handle:

        ```py
        async def print(source, element):
            print(await element.text_content())

        await context.expose_binding(\&#34;clicked\&#34;, print, handle=true)
        await page.set_content(\&#34;\&#34;\&#34;
          &lt;script&gt;
            document.addEventListener(&#39;click&#39;, event =&gt; window.clicked(event.target));
          &lt;/script&gt;
          &lt;div&gt;Click me&lt;/div&gt;
          &lt;div&gt;Or click me&lt;/div&gt;
        \&#34;\&#34;\&#34;)
        ```

        Parameters
        ----------
        name : str
            Name of the function on the window object.
        callback : Callable
            Callback function that will be called in the Playwright&#39;s context.
        handle : Union[bool, NoneType]
            Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is
            supported. When passing by value, multiple arguments are supported.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.expose_binding started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.expose_binding(
                    name=name, callback=self._wrap_handler(callback), handle=handle
                )
            )
            log_api(&#34;&lt;= browser_context.expose_binding succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.expose_binding failed&#34;)
            raise e

    async def expose_function(self, name: str, callback: typing.Callable) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.expose_function

        The method adds a function called `name` on the `window` object of every frame in every page in the context. When
        called, the function executes `callback` and returns a [Promise] which resolves to the return value of `callback`.

        If the `callback` returns a [Promise], it will be awaited.

        See `page.expose_function()` for page-only version.

        An example of adding an `md5` function to all pages in the context:

        ```py
        import asyncio
        import hashlib
        from playwright.async_api import async_playwright

        async def sha1(text):
            m = hashlib.sha1()
            m.update(bytes(text, \&#34;utf8\&#34;))
            return m.hexdigest()

        async def run(playwright):
            webkit = playwright.webkit
            browser = await webkit.launch(headless=False)
            context = await browser.new_context()
            await context.expose_function(\&#34;sha1\&#34;, sha1)
            page = await context.new_page()
            await page.set_content(\&#34;\&#34;\&#34;
                &lt;script&gt;
                  async function onClick() {
                    document.querySelector(&#39;div&#39;).textContent = await window.sha1(&#39;PLAYWRIGHT&#39;);
                  }
                &lt;/script&gt;
                &lt;button onclick=\&#34;onClick()\&#34;&gt;Click me&lt;/button&gt;
                &lt;div&gt;&lt;/div&gt;
            \&#34;\&#34;\&#34;)
            await page.click(\&#34;button\&#34;)

        async def main():
            async with async_playwright() as playwright:
                await run(playwright)
        asyncio.run(main())
        ```

        Parameters
        ----------
        name : str
            Name of the function on the window object.
        callback : Callable
            Callback function that will be called in the Playwright&#39;s context.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.expose_function started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.expose_function(
                    name=name, callback=self._wrap_handler(callback)
                )
            )
            log_api(&#34;&lt;= browser_context.expose_function succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.expose_function failed&#34;)
            raise e

    async def route(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Union[
            typing.Callable[[&#34;Route&#34;], typing.Any],
            typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
        ],
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.route

        Routing provides the capability to modify network requests that are made by any page in the browser context. Once route
        is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.

        An example of a naïve handler that aborts all image requests:

        ```py
        context = await browser.new_context()
        page = await context.new_page()
        await context.route(\&#34;**/*.{png,jpg,jpeg}\&#34;, lambda route: route.abort())
        await page.goto(\&#34;https://example.com\&#34;)
        await browser.close()
        ```

        or the same snippet using a regex pattern instead:

        ```py
        context = await browser.new_context()
        page = await context.new_page()
        await context.route(r\&#34;(\\.png$)|(\\.jpg$)\&#34;, lambda page = await context.new_page()
        await page.goto(\&#34;https://example.com\&#34;)
        await browser.close()
        ```

        Page routes (set up with `page.route()`) take precedence over browser context routes when request matches both
        handlers.

        &gt; NOTE: Enabling routing disables http cache.

        Parameters
        ----------
        url : Union[Callable[[str], bool], Pattern, str]
            A glob pattern, regex pattern or predicate receiving [URL] to match while routing.
        handler : Union[Callable[[Route, Request], Any], Callable[[Route], Any]]
            handler function to route the request.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.route started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.route(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
            log_api(&#34;&lt;= browser_context.route succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.route failed&#34;)
            raise e

    async def unroute(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Union[
            typing.Callable[[&#34;Route&#34;], typing.Any],
            typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
        ] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.unroute

        Removes a route created with `browser_context.route()`. When `handler` is not specified, removes all routes for
        the `url`.

        Parameters
        ----------
        url : Union[Callable[[str], bool], Pattern, str]
            A glob pattern, regex pattern or predicate receiving [URL] used to register a routing with
            `browser_context.route()`.
        handler : Union[Callable[[Route, Request], Any], Callable[[Route], Any], NoneType]
            Optional handler function used to register a routing with `browser_context.route()`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.unroute started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.unroute(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
            log_api(&#34;&lt;= browser_context.unroute succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.unroute failed&#34;)
            raise e

    def expect_event(
        self, event: str, predicate: typing.Callable = None, timeout: float = None
    ) -&gt; AsyncEventContextManager:
        &#34;&#34;&#34;BrowserContext.expect_event

        Performs action and waits for given `event` to fire. If predicate is provided, it passes event&#39;s value into the
        `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if browser context
        is closed before the `event` is fired.

        ```py
        async with context.expect_event(\&#34;page\&#34;) as event_info:
            await context.click(\&#34;button\&#34;)
        page = await event_info.value
        ```

        Parameters
        ----------
        event : str
            Event name, same one typically passed into `*.on(event)`.
        predicate : Union[Callable, NoneType]
            Receives the event data and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_event(
                event=event, predicate=self._wrap_handler(predicate), timeout=timeout
            ).future
        )

    async def close(self) -&gt; NoneType:
        &#34;&#34;&#34;BrowserContext.close

        Closes the browser context. All the pages that belong to the browser context will be closed.

        &gt; NOTE: The default browser context cannot be closed.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.close started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.close())
            log_api(&#34;&lt;= browser_context.close succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.close failed&#34;)
            raise e

    async def storage_state(
        self, path: typing.Union[str, pathlib.Path] = None
    ) -&gt; StorageState:
        &#34;&#34;&#34;BrowserContext.storage_state

        Returns storage state for this browser context, contains current cookies and local storage snapshot.

        Parameters
        ----------
        path : Union[pathlib.Path, str, NoneType]
            The file path to save the storage state to. If `path` is a relative path, then it is resolved relative to
            [current working directory](https://nodejs.org/api/process.html#process_process_cwd). If no path is provided, storage
            state is still returned, but won&#39;t be saved to the disk.

        Returns
        -------
        {cookies: Union[List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}], NoneType], origins: Union[List[{origin: str, localStorage: List[{name: str, value: str}]}], NoneType]}
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.storage_state started&#34;)
            result = mapping.from_impl(await self._impl_obj.storage_state(path=path))
            log_api(&#34;&lt;= browser_context.storage_state succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.storage_state failed&#34;)
            raise e

    async def wait_for_event(
        self, event: str, predicate: typing.Callable = None, timeout: float = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;BrowserContext.wait_for_event

        Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
        value. Will throw an error if the context closes before the event is fired. Returns the event data value.

        ```py
        context = await browser.new_context()
        await context.grant_permissions([\&#34;geolocation\&#34;])
        ```

        Parameters
        ----------
        event : str
            Event name, same one would pass into `browserContext.on(event)`.
        predicate : Union[Callable, NoneType]
            Receives the event data and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_context.wait_for_event started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.wait_for_event(
                    event=event,
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
            log_api(&#34;&lt;= browser_context.wait_for_event succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_context.wait_for_event failed&#34;)
            raise e

    def expect_page(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
        timeout: float = None,
    ) -&gt; AsyncEventContextManager[&#34;Page&#34;]:
        &#34;&#34;&#34;BrowserContext.expect_page

        Performs action and waits for `page` event to fire. If predicate is provided, it passes `Page` value into the
        `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
        closed before the worker event is fired.

        Parameters
        ----------
        predicate : Union[Callable[[Page], bool], NoneType]
            Receives the `Page` object and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager[Page]
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_page(
                predicate=self._wrap_handler(predicate), timeout=timeout
            ).future
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>playwright.async_api._generated.ChromiumBrowserContext</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.BrowserContext.browser"><code class="name">var <span class="ident">browser</span> : Union[playwright.async_api._generated.Browser, NoneType]</code></dt>
<dd>
<div class="desc"><p>BrowserContext.browser</p>
<p>Returns the browser instance of the context. If it was launched as a persistent context null gets returned.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Browser" href="#playwright.async_api.Browser">Browser</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def browser(self) -&gt; typing.Union[&#34;Browser&#34;, NoneType]:
    &#34;&#34;&#34;BrowserContext.browser

    Returns the browser instance of the context. If it was launched as a persistent context null gets returned.

    Returns
    -------
    Union[Browser, NoneType]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.browser)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.pages"><code class="name">var <span class="ident">pages</span> : List[playwright.async_api._generated.Page]</code></dt>
<dd>
<div class="desc"><p>BrowserContext.pages</p>
<p>Returns all open pages in the context. Non visible pages, such as <code>"background_page"</code>, will not be listed here. You can
find them using <code>chromium_browser_context.background_pages()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pages(self) -&gt; typing.List[&#34;Page&#34;]:
    &#34;&#34;&#34;BrowserContext.pages

    Returns all open pages in the context. Non visible pages, such as `\&#34;background_page\&#34;`, will not be listed here. You can
    find them using `chromium_browser_context.background_pages()`.

    Returns
    -------
    List[Page]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.pages)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.BrowserContext.add_cookies"><code class="name flex">
<span>async def <span class="ident">add_cookies</span></span>(<span>self, cookies: List[playwright._impl._api_structures.Cookie]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.add_cookies</p>
<p>Adds cookies into this browser context. All pages within this context will have these cookies installed. Cookies can be
obtained via <code>browser_context.cookies()</code>.</p>
<pre><code class="language-py">await browser_context.add_cookies([cookie_object1, cookie_object2])
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cookies</code></strong> :&ensp;<code>List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union["Lax", "None", "Strict", NoneType]}]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_cookies(self, cookies: typing.List[Cookie]) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.add_cookies

    Adds cookies into this browser context. All pages within this context will have these cookies installed. Cookies can be
    obtained via `browser_context.cookies()`.

    ```py
    await browser_context.add_cookies([cookie_object1, cookie_object2])
    ```

    Parameters
    ----------
    cookies : List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.add_cookies started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.add_cookies(cookies=cookies)
        )
        log_api(&#34;&lt;= browser_context.add_cookies succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.add_cookies failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.add_init_script"><code class="name flex">
<span>async def <span class="ident">add_init_script</span></span>(<span>self, script: str = None, path: Union[str, pathlib.Path] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.add_init_script</p>
<p>Adds a script which would be evaluated in one of the following scenarios:
- Whenever a page is created in the browser context or is navigated.
- Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is
evaluated in the context of the newly attached frame.</p>
<p>The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
the JavaScript environment, e.g. to seed <code>Math.random</code>.</p>
<p>An example of overriding <code>Math.random</code> before the page loads:</p>
<pre><code class="language-py"># in your playwright script, assuming the preload.js file is in same directory.
await browser_context.add_init_script(path=&quot;preload.js&quot;)
</code></pre>
<blockquote>
<p>NOTE: The order of evaluation of multiple scripts installed via <code>browser_context.add_init_script()</code> and
<code>page.add_init_script()</code> is not defined.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>script</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Script to be evaluated in all pages in the browser context. Optional.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the JavaScript file. If <code>path</code> is a relative path, then it is resolved relative to the current working
directory. Optional.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_init_script(
    self, script: str = None, path: typing.Union[str, pathlib.Path] = None
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.add_init_script

    Adds a script which would be evaluated in one of the following scenarios:
    - Whenever a page is created in the browser context or is navigated.
    - Whenever a child frame is attached or navigated in any page in the browser context. In this case, the script is
      evaluated in the context of the newly attached frame.

    The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
    the JavaScript environment, e.g. to seed `Math.random`.

    An example of overriding `Math.random` before the page loads:

    ```py
    # in your playwright script, assuming the preload.js file is in same directory.
    await browser_context.add_init_script(path=\&#34;preload.js\&#34;)
    ```

    &gt; NOTE: The order of evaluation of multiple scripts installed via `browser_context.add_init_script()` and
    `page.add_init_script()` is not defined.

    Parameters
    ----------
    script : Union[str, NoneType]
        Script to be evaluated in all pages in the browser context. Optional.
    path : Union[pathlib.Path, str, NoneType]
        Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to the current working
        directory. Optional.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.add_init_script started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.add_init_script(script=script, path=path)
        )
        log_api(&#34;&lt;= browser_context.add_init_script succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.add_init_script failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.clear_cookies"><code class="name flex">
<span>async def <span class="ident">clear_cookies</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.clear_cookies</p>
<p>Clears context cookies.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_cookies(self) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.clear_cookies

    Clears context cookies.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.clear_cookies started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.clear_cookies())
        log_api(&#34;&lt;= browser_context.clear_cookies succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.clear_cookies failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.clear_permissions"><code class="name flex">
<span>async def <span class="ident">clear_permissions</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.clear_permissions</p>
<p>Clears all permission overrides for the browser context.</p>
<pre><code class="language-py">context = await browser.new_context()
await context.grant_permissions([&quot;clipboard-read&quot;])
# do stuff ..
context.clear_permissions()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_permissions(self) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.clear_permissions

    Clears all permission overrides for the browser context.

    ```py
    context = await browser.new_context()
    await context.grant_permissions([\&#34;clipboard-read\&#34;])
    # do stuff ..
    context.clear_permissions()
    ```
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.clear_permissions started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.clear_permissions())
        log_api(&#34;&lt;= browser_context.clear_permissions succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.clear_permissions failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.close</p>
<p>Closes the browser context. All the pages that belong to the browser context will be closed.</p>
<blockquote>
<p>NOTE: The default browser context cannot be closed.</p>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.close

    Closes the browser context. All the pages that belong to the browser context will be closed.

    &gt; NOTE: The default browser context cannot be closed.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.close started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.close())
        log_api(&#34;&lt;= browser_context.close succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.close failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.cookies"><code class="name flex">
<span>async def <span class="ident">cookies</span></span>(<span>self, urls: Union[str, List[str]] = None) ‑> List[playwright._impl._api_structures.Cookie]</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.cookies</p>
<p>If no URLs are specified, this method returns all cookies. If URLs are specified, only cookies that affect those URLs
are returned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>urls</code></strong> :&ensp;<code>Union[List[str], str, NoneType]</code></dt>
<dd>Optional list of URLs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union["Lax", "None", "Strict", NoneType]}]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def cookies(
    self, urls: typing.Union[str, typing.List[str]] = None
) -&gt; typing.List[Cookie]:
    &#34;&#34;&#34;BrowserContext.cookies

    If no URLs are specified, this method returns all cookies. If URLs are specified, only cookies that affect those URLs
    are returned.

    Parameters
    ----------
    urls : Union[List[str], str, NoneType]
        Optional list of URLs.

    Returns
    -------
    List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.cookies started&#34;)
        result = mapping.from_impl_list(await self._impl_obj.cookies(urls=urls))
        log_api(&#34;&lt;= browser_context.cookies succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.cookies failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.expect_event"><code class="name flex">
<span>def <span class="ident">expect_event</span></span>(<span>self, event: str, predicate: Callable = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.expect_event</p>
<p>Performs action and waits for given <code>event</code> to fire. If predicate is provided, it passes event's value into the
<code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if browser context
is closed before the <code>event</code> is fired.</p>
<pre><code class="language-py">async with context.expect_event(&quot;page&quot;) as event_info:
    await context.click(&quot;button&quot;)
page = await event_info.value
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>Event name, same one typically passed into <code>*.on(event)</code>.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable, NoneType]</code></dt>
<dd>Receives the event data and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_event(
    self, event: str, predicate: typing.Callable = None, timeout: float = None
) -&gt; AsyncEventContextManager:
    &#34;&#34;&#34;BrowserContext.expect_event

    Performs action and waits for given `event` to fire. If predicate is provided, it passes event&#39;s value into the
    `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if browser context
    is closed before the `event` is fired.

    ```py
    async with context.expect_event(\&#34;page\&#34;) as event_info:
        await context.click(\&#34;button\&#34;)
    page = await event_info.value
    ```

    Parameters
    ----------
    event : str
        Event name, same one typically passed into `*.on(event)`.
    predicate : Union[Callable, NoneType]
        Receives the event data and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_event(
            event=event, predicate=self._wrap_handler(predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.expect_page"><code class="name flex">
<span>def <span class="ident">expect_page</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>')], bool] = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager[playwright.async_api._generated.Page]</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.expect_page</p>
<p>Performs action and waits for <code>page</code> event to fire. If predicate is provided, it passes <code><a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a></code> value into the
<code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the page is
closed before the worker event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>], bool], NoneType]</code></dt>
<dd>Receives the <code><a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a></code> object and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager[<a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_page(
    self,
    predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
    timeout: float = None,
) -&gt; AsyncEventContextManager[&#34;Page&#34;]:
    &#34;&#34;&#34;BrowserContext.expect_page

    Performs action and waits for `page` event to fire. If predicate is provided, it passes `Page` value into the
    `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
    closed before the worker event is fired.

    Parameters
    ----------
    predicate : Union[Callable[[Page], bool], NoneType]
        Receives the `Page` object and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager[Page]
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_page(
            predicate=self._wrap_handler(predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.expose_binding"><code class="name flex">
<span>async def <span class="ident">expose_binding</span></span>(<span>self, name: str, callback: Callable, handle: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.expose_binding</p>
<p>The method adds a function called <code>name</code> on the <code>window</code> object of every frame in every page in the context. When
called, the function executes <code>callback</code> and returns a [Promise] which resolves to the return value of <code>callback</code>. If
the <code>callback</code> returns a [Promise], it will be awaited.</p>
<p>The first argument of the <code>callback</code> function contains information about the caller: <code>{ browserContext: BrowserContext,
page: Page, frame: Frame }</code>.</p>
<p>See <code>page.expose_binding()</code> for page-only version.</p>
<p>An example of exposing page URL to all frames in all pages in the context:</p>
<pre><code class="language-py">import asyncio
from playwright.async_api import async_playwright

async def run(playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=false)
    context = await browser.new_context()
    await context.expose_binding(&quot;pageURL&quot;, lambda source: source[&quot;page&quot;].url)
    page = await context.new_page()
    await page.set_content(&quot;&quot;&quot;
    &lt;script&gt;
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    &lt;/script&gt;
    &lt;button onclick=&quot;onClick()&quot;&gt;Click me&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &quot;&quot;&quot;)
    await page.click(&quot;button&quot;)

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
</code></pre>
<p>An example of passing an element handle:</p>
<pre><code class="language-py">async def print(source, element):
    print(await element.text_content())

await context.expose_binding(&quot;clicked&quot;, print, handle=true)
await page.set_content(&quot;&quot;&quot;
  &lt;script&gt;
    document.addEventListener('click', event =&gt; window.clicked(event.target));
  &lt;/script&gt;
  &lt;div&gt;Click me&lt;/div&gt;
  &lt;div&gt;Or click me&lt;/div&gt;
&quot;&quot;&quot;)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the function on the window object.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Callback function that will be called in the Playwright's context.</dd>
<dt><strong><code>handle</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is
supported. When passing by value, multiple arguments are supported.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def expose_binding(
    self, name: str, callback: typing.Callable, handle: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.expose_binding

    The method adds a function called `name` on the `window` object of every frame in every page in the context. When
    called, the function executes `callback` and returns a [Promise] which resolves to the return value of `callback`. If
    the `callback` returns a [Promise], it will be awaited.

    The first argument of the `callback` function contains information about the caller: `{ browserContext: BrowserContext,
    page: Page, frame: Frame }`.

    See `page.expose_binding()` for page-only version.

    An example of exposing page URL to all frames in all pages in the context:

    ```py
    import asyncio
    from playwright.async_api import async_playwright

    async def run(playwright):
        webkit = playwright.webkit
        browser = await webkit.launch(headless=false)
        context = await browser.new_context()
        await context.expose_binding(\&#34;pageURL\&#34;, lambda source: source[\&#34;page\&#34;].url)
        page = await context.new_page()
        await page.set_content(\&#34;\&#34;\&#34;
        &lt;script&gt;
          async function onClick() {
            document.querySelector(&#39;div&#39;).textContent = await window.pageURL();
          }
        &lt;/script&gt;
        &lt;button onclick=\&#34;onClick()\&#34;&gt;Click me&lt;/button&gt;
        &lt;div&gt;&lt;/div&gt;
        \&#34;\&#34;\&#34;)
        await page.click(\&#34;button\&#34;)

    async def main():
        async with async_playwright() as playwright:
            await run(playwright)
    asyncio.run(main())
    ```

    An example of passing an element handle:

    ```py
    async def print(source, element):
        print(await element.text_content())

    await context.expose_binding(\&#34;clicked\&#34;, print, handle=true)
    await page.set_content(\&#34;\&#34;\&#34;
      &lt;script&gt;
        document.addEventListener(&#39;click&#39;, event =&gt; window.clicked(event.target));
      &lt;/script&gt;
      &lt;div&gt;Click me&lt;/div&gt;
      &lt;div&gt;Or click me&lt;/div&gt;
    \&#34;\&#34;\&#34;)
    ```

    Parameters
    ----------
    name : str
        Name of the function on the window object.
    callback : Callable
        Callback function that will be called in the Playwright&#39;s context.
    handle : Union[bool, NoneType]
        Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is
        supported. When passing by value, multiple arguments are supported.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.expose_binding started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.expose_binding(
                name=name, callback=self._wrap_handler(callback), handle=handle
            )
        )
        log_api(&#34;&lt;= browser_context.expose_binding succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.expose_binding failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.expose_function"><code class="name flex">
<span>async def <span class="ident">expose_function</span></span>(<span>self, name: str, callback: Callable) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.expose_function</p>
<p>The method adds a function called <code>name</code> on the <code>window</code> object of every frame in every page in the context. When
called, the function executes <code>callback</code> and returns a [Promise] which resolves to the return value of <code>callback</code>.</p>
<p>If the <code>callback</code> returns a [Promise], it will be awaited.</p>
<p>See <code>page.expose_function()</code> for page-only version.</p>
<p>An example of adding an <code>md5</code> function to all pages in the context:</p>
<pre><code class="language-py">import asyncio
import hashlib
from playwright.async_api import async_playwright

async def sha1(text):
    m = hashlib.sha1()
    m.update(bytes(text, &quot;utf8&quot;))
    return m.hexdigest()

async def run(playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    context = await browser.new_context()
    await context.expose_function(&quot;sha1&quot;, sha1)
    page = await context.new_page()
    await page.set_content(&quot;&quot;&quot;
        &lt;script&gt;
          async function onClick() {
            document.querySelector('div').textContent = await window.sha1('PLAYWRIGHT');
          }
        &lt;/script&gt;
        &lt;button onclick=&quot;onClick()&quot;&gt;Click me&lt;/button&gt;
        &lt;div&gt;&lt;/div&gt;
    &quot;&quot;&quot;)
    await page.click(&quot;button&quot;)

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the function on the window object.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Callback function that will be called in the Playwright's context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def expose_function(self, name: str, callback: typing.Callable) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.expose_function

    The method adds a function called `name` on the `window` object of every frame in every page in the context. When
    called, the function executes `callback` and returns a [Promise] which resolves to the return value of `callback`.

    If the `callback` returns a [Promise], it will be awaited.

    See `page.expose_function()` for page-only version.

    An example of adding an `md5` function to all pages in the context:

    ```py
    import asyncio
    import hashlib
    from playwright.async_api import async_playwright

    async def sha1(text):
        m = hashlib.sha1()
        m.update(bytes(text, \&#34;utf8\&#34;))
        return m.hexdigest()

    async def run(playwright):
        webkit = playwright.webkit
        browser = await webkit.launch(headless=False)
        context = await browser.new_context()
        await context.expose_function(\&#34;sha1\&#34;, sha1)
        page = await context.new_page()
        await page.set_content(\&#34;\&#34;\&#34;
            &lt;script&gt;
              async function onClick() {
                document.querySelector(&#39;div&#39;).textContent = await window.sha1(&#39;PLAYWRIGHT&#39;);
              }
            &lt;/script&gt;
            &lt;button onclick=\&#34;onClick()\&#34;&gt;Click me&lt;/button&gt;
            &lt;div&gt;&lt;/div&gt;
        \&#34;\&#34;\&#34;)
        await page.click(\&#34;button\&#34;)

    async def main():
        async with async_playwright() as playwright:
            await run(playwright)
    asyncio.run(main())
    ```

    Parameters
    ----------
    name : str
        Name of the function on the window object.
    callback : Callable
        Callback function that will be called in the Playwright&#39;s context.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.expose_function started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.expose_function(
                name=name, callback=self._wrap_handler(callback)
            )
        )
        log_api(&#34;&lt;= browser_context.expose_function succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.expose_function failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.grant_permissions"><code class="name flex">
<span>async def <span class="ident">grant_permissions</span></span>(<span>self, permissions: List[str], origin: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.grant_permissions</p>
<p>Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if
specified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>permissions</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>A permission or an array of permissions to grant. Permissions can be one of the following values:
- <code>'geolocation'</code>
- <code>'midi'</code>
- <code>'midi-sysex'</code> (system-exclusive midi)
- <code>'notifications'</code>
- <code>'push'</code>
- <code>'camera'</code>
- <code>'microphone'</code>
- <code>'background-sync'</code>
- <code>'ambient-light-sensor'</code>
- <code>'accelerometer'</code>
- <code>'gyroscope'</code>
- <code>'magnetometer'</code>
- <code>'accessibility-events'</code>
- <code>'clipboard-read'</code>
- <code>'clipboard-write'</code>
- <code>'payment-handler'</code></dd>
<dt><strong><code>origin</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>The [origin] to grant permissions to, e.g. "https://example.com".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def grant_permissions(
    self, permissions: typing.List[str], origin: str = None
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.grant_permissions

    Grants specified permissions to the browser context. Only grants corresponding permissions to the given origin if
    specified.

    Parameters
    ----------
    permissions : List[str]
        A permission or an array of permissions to grant. Permissions can be one of the following values:
        - `&#39;geolocation&#39;`
        - `&#39;midi&#39;`
        - `&#39;midi-sysex&#39;` (system-exclusive midi)
        - `&#39;notifications&#39;`
        - `&#39;push&#39;`
        - `&#39;camera&#39;`
        - `&#39;microphone&#39;`
        - `&#39;background-sync&#39;`
        - `&#39;ambient-light-sensor&#39;`
        - `&#39;accelerometer&#39;`
        - `&#39;gyroscope&#39;`
        - `&#39;magnetometer&#39;`
        - `&#39;accessibility-events&#39;`
        - `&#39;clipboard-read&#39;`
        - `&#39;clipboard-write&#39;`
        - `&#39;payment-handler&#39;`
    origin : Union[str, NoneType]
        The [origin] to grant permissions to, e.g. &#34;https://example.com&#34;.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.grant_permissions started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.grant_permissions(
                permissions=permissions, origin=origin
            )
        )
        log_api(&#34;&lt;= browser_context.grant_permissions succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.grant_permissions failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.new_page"><code class="name flex">
<span>async def <span class="ident">new_page</span></span>(<span>self) ‑> playwright.async_api._generated.Page</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.new_page</p>
<p>Creates a new page in the browser context.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def new_page(self) -&gt; &#34;Page&#34;:
    &#34;&#34;&#34;BrowserContext.new_page

    Creates a new page in the browser context.

    Returns
    -------
    Page
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.new_page started&#34;)
        result = mapping.from_impl(await self._impl_obj.new_page())
        log_api(&#34;&lt;= browser_context.new_page succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.new_page failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.route"><code class="name flex">
<span>async def <span class="ident">route</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]], handler: Union[Callable[[ForwardRef('<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>')], Any], Callable[[ForwardRef('<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>'), ForwardRef('<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>')], Any]]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.route</p>
<p>Routing provides the capability to modify network requests that are made by any page in the browser context. Once route
is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.</p>
<p>An example of a naïve handler that aborts all image requests:</p>
<pre><code class="language-py">context = await browser.new_context()
page = await context.new_page()
await context.route(&quot;**/*.{png,jpg,jpeg}&quot;, lambda route: route.abort())
await page.goto(&quot;https://example.com&quot;)
await browser.close()
</code></pre>
<p>or the same snippet using a regex pattern instead:</p>
<pre><code class="language-py">context = await browser.new_context()
page = await context.new_page()
await context.route(r&quot;(\.png$)|(\.jpg$)&quot;, lambda page = await context.new_page()
await page.goto(&quot;https://example.com&quot;)
await browser.close()
</code></pre>
<p>Page routes (set up with <code>page.route()</code>) take precedence over browser context routes when request matches both
handlers.</p>
<blockquote>
<p>NOTE: Enabling routing disables http cache.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[Callable[[str], bool], Pattern, str]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving [URL] to match while routing.</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>, <a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>], Any], Callable[[<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>], Any]]</code></dt>
<dd>handler function to route the request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def route(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
    handler: typing.Union[
        typing.Callable[[&#34;Route&#34;], typing.Any],
        typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
    ],
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.route

    Routing provides the capability to modify network requests that are made by any page in the browser context. Once route
    is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.

    An example of a naïve handler that aborts all image requests:

    ```py
    context = await browser.new_context()
    page = await context.new_page()
    await context.route(\&#34;**/*.{png,jpg,jpeg}\&#34;, lambda route: route.abort())
    await page.goto(\&#34;https://example.com\&#34;)
    await browser.close()
    ```

    or the same snippet using a regex pattern instead:

    ```py
    context = await browser.new_context()
    page = await context.new_page()
    await context.route(r\&#34;(\\.png$)|(\\.jpg$)\&#34;, lambda page = await context.new_page()
    await page.goto(\&#34;https://example.com\&#34;)
    await browser.close()
    ```

    Page routes (set up with `page.route()`) take precedence over browser context routes when request matches both
    handlers.

    &gt; NOTE: Enabling routing disables http cache.

    Parameters
    ----------
    url : Union[Callable[[str], bool], Pattern, str]
        A glob pattern, regex pattern or predicate receiving [URL] to match while routing.
    handler : Union[Callable[[Route, Request], Any], Callable[[Route], Any]]
        handler function to route the request.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.route started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.route(
                url=self._wrap_handler(url), handler=self._wrap_handler(handler)
            )
        )
        log_api(&#34;&lt;= browser_context.route succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.route failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.set_default_navigation_timeout"><code class="name flex">
<span>def <span class="ident">set_default_navigation_timeout</span></span>(<span>self, timeout: float) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.set_default_navigation_timeout</p>
<p>This setting will change the default maximum navigation time for the following methods and related shortcuts:
- <code>page.go_back()</code>
- <code>page.go_forward()</code>
- <code>page.goto()</code>
- <code>page.reload()</code>
- <code>page.set_content()</code>
- <code>page.wait_for_navigation()</code></p>
<blockquote>
<p>NOTE: <code>page.set_default_navigation_timeout()</code> and <code>page.set_default_timeout()</code> take priority over
<code>browser_context.set_default_navigation_timeout()</code>.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum navigation time in milliseconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_navigation_timeout(self, timeout: float) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.set_default_navigation_timeout

    This setting will change the default maximum navigation time for the following methods and related shortcuts:
    - `page.go_back()`
    - `page.go_forward()`
    - `page.goto()`
    - `page.reload()`
    - `page.set_content()`
    - `page.wait_for_navigation()`

    &gt; NOTE: `page.set_default_navigation_timeout()` and `page.set_default_timeout()` take priority over
    `browser_context.set_default_navigation_timeout()`.

    Parameters
    ----------
    timeout : float
        Maximum navigation time in milliseconds
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.set_default_navigation_timeout started&#34;)
        result = mapping.from_maybe_impl(
            self._impl_obj.set_default_navigation_timeout(timeout=timeout)
        )
        log_api(&#34;&lt;= browser_context.set_default_navigation_timeout succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.set_default_navigation_timeout failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.set_default_timeout"><code class="name flex">
<span>def <span class="ident">set_default_timeout</span></span>(<span>self, timeout: float) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.set_default_timeout</p>
<p>This setting will change the default maximum time for all the methods accepting <code>timeout</code> option.</p>
<blockquote>
<p>NOTE: <code>page.set_default_navigation_timeout()</code>, <code>page.set_default_timeout()</code> and
<code>browser_context.set_default_navigation_timeout()</code> take priority over <code>browser_context.set_default_timeout()</code>.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum time in milliseconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_timeout(self, timeout: float) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.set_default_timeout

    This setting will change the default maximum time for all the methods accepting `timeout` option.

    &gt; NOTE: `page.set_default_navigation_timeout()`, `page.set_default_timeout()` and
    `browser_context.set_default_navigation_timeout()` take priority over `browser_context.set_default_timeout()`.

    Parameters
    ----------
    timeout : float
        Maximum time in milliseconds
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.set_default_timeout started&#34;)
        result = mapping.from_maybe_impl(
            self._impl_obj.set_default_timeout(timeout=timeout)
        )
        log_api(&#34;&lt;= browser_context.set_default_timeout succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.set_default_timeout failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.set_extra_http_headers"><code class="name flex">
<span>async def <span class="ident">set_extra_http_headers</span></span>(<span>self, headers: Dict[str, str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.set_extra_http_headers</p>
<p>The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged
with page-specific extra HTTP headers set with <code>page.set_extra_http_headers()</code>. If page overrides a particular
header, page-specific header value will be used instead of the browser context header value.</p>
<blockquote>
<p>NOTE: <code>browser_context.set_extra_http_headers()</code> does not guarantee the order of headers in the outgoing requests.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>headers</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_extra_http_headers(self, headers: typing.Dict[str, str]) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.set_extra_http_headers

    The extra HTTP headers will be sent with every request initiated by any page in the context. These headers are merged
    with page-specific extra HTTP headers set with `page.set_extra_http_headers()`. If page overrides a particular
    header, page-specific header value will be used instead of the browser context header value.

    &gt; NOTE: `browser_context.set_extra_http_headers()` does not guarantee the order of headers in the outgoing requests.

    Parameters
    ----------
    headers : Dict[str, str]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.set_extra_http_headers started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_extra_http_headers(
                headers=mapping.to_impl(headers)
            )
        )
        log_api(&#34;&lt;= browser_context.set_extra_http_headers succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.set_extra_http_headers failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.set_geolocation"><code class="name flex">
<span>async def <span class="ident">set_geolocation</span></span>(<span>self, geolocation: playwright._impl._api_structures.Geolocation = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.set_geolocation</p>
<p>Sets the context's geolocation. Passing <code>null</code> or <code>undefined</code> emulates position unavailable.</p>
<pre><code class="language-py">await browser_context.set_geolocation({&quot;latitude&quot;: 59.95, &quot;longitude&quot;: 30.31667})
</code></pre>
<blockquote>
<p>NOTE: Consider using <code>browser_context.grant_permissions()</code> to grant permissions for the browser context pages to
read its geolocation.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>geolocation</code></strong> :&ensp;<code>Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_geolocation(self, geolocation: Geolocation = None) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.set_geolocation

    Sets the context&#39;s geolocation. Passing `null` or `undefined` emulates position unavailable.

    ```py
    await browser_context.set_geolocation({\&#34;latitude\&#34;: 59.95, \&#34;longitude\&#34;: 30.31667})
    ```

    &gt; NOTE: Consider using `browser_context.grant_permissions()` to grant permissions for the browser context pages to
    read its geolocation.

    Parameters
    ----------
    geolocation : Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.set_geolocation started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_geolocation(geolocation=geolocation)
        )
        log_api(&#34;&lt;= browser_context.set_geolocation succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.set_geolocation failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.set_offline"><code class="name flex">
<span>async def <span class="ident">set_offline</span></span>(<span>self, offline: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.set_offline</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>offline</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to emulate network being offline for the browser context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_offline(self, offline: bool) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.set_offline

    Parameters
    ----------
    offline : bool
        Whether to emulate network being offline for the browser context.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.set_offline started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_offline(offline=offline)
        )
        log_api(&#34;&lt;= browser_context.set_offline succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.set_offline failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.storage_state"><code class="name flex">
<span>async def <span class="ident">storage_state</span></span>(<span>self, path: Union[str, pathlib.Path] = None) ‑> playwright._impl._api_structures.StorageState</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.storage_state</p>
<p>Returns storage state for this browser context, contains current cookies and local storage snapshot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>The file path to save the storage state to. If <code>path</code> is a relative path, then it is resolved relative to
<a href="https://nodejs.org/api/process.html#process_process_cwd">current working directory</a>. If no path is provided, storage
state is still returned, but won't be saved to the disk.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>{cookies: Union[List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union["Lax", "None", "Strict", NoneType]}], NoneType], origins: Union[List[{origin: str, localStorage: List[{name: str, value: str}]}], NoneType]}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def storage_state(
    self, path: typing.Union[str, pathlib.Path] = None
) -&gt; StorageState:
    &#34;&#34;&#34;BrowserContext.storage_state

    Returns storage state for this browser context, contains current cookies and local storage snapshot.

    Parameters
    ----------
    path : Union[pathlib.Path, str, NoneType]
        The file path to save the storage state to. If `path` is a relative path, then it is resolved relative to
        [current working directory](https://nodejs.org/api/process.html#process_process_cwd). If no path is provided, storage
        state is still returned, but won&#39;t be saved to the disk.

    Returns
    -------
    {cookies: Union[List[{name: str, value: str, url: Union[str, NoneType], domain: Union[str, NoneType], path: Union[str, NoneType], expires: Union[float, NoneType], httpOnly: Union[bool, NoneType], secure: Union[bool, NoneType], sameSite: Union[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;, NoneType]}], NoneType], origins: Union[List[{origin: str, localStorage: List[{name: str, value: str}]}], NoneType]}
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.storage_state started&#34;)
        result = mapping.from_impl(await self._impl_obj.storage_state(path=path))
        log_api(&#34;&lt;= browser_context.storage_state succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.storage_state failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.unroute"><code class="name flex">
<span>async def <span class="ident">unroute</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]], handler: Union[Callable[[ForwardRef('<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>')], Any], Callable[[ForwardRef('<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>'), ForwardRef('<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>')], Any]] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.unroute</p>
<p>Removes a route created with <code>browser_context.route()</code>. When <code>handler</code> is not specified, removes all routes for
the <code>url</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[Callable[[str], bool], Pattern, str]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving [URL] used to register a routing with
<code>browser_context.route()</code>.</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>, <a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>], Any], Callable[[<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>], Any], NoneType]</code></dt>
<dd>Optional handler function used to register a routing with <code>browser_context.route()</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def unroute(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
    handler: typing.Union[
        typing.Callable[[&#34;Route&#34;], typing.Any],
        typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
    ] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;BrowserContext.unroute

    Removes a route created with `browser_context.route()`. When `handler` is not specified, removes all routes for
    the `url`.

    Parameters
    ----------
    url : Union[Callable[[str], bool], Pattern, str]
        A glob pattern, regex pattern or predicate receiving [URL] used to register a routing with
        `browser_context.route()`.
    handler : Union[Callable[[Route, Request], Any], Callable[[Route], Any], NoneType]
        Optional handler function used to register a routing with `browser_context.route()`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.unroute started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.unroute(
                url=self._wrap_handler(url), handler=self._wrap_handler(handler)
            )
        )
        log_api(&#34;&lt;= browser_context.unroute succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.unroute failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserContext.wait_for_event"><code class="name flex">
<span>async def <span class="ident">wait_for_event</span></span>(<span>self, event: str, predicate: Callable = None, timeout: float = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserContext.wait_for_event</p>
<p>Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
value. Will throw an error if the context closes before the event is fired. Returns the event data value.</p>
<pre><code class="language-py">context = await browser.new_context()
await context.grant_permissions([&quot;geolocation&quot;])
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>Event name, same one would pass into <code>browserContext.on(event)</code>.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable, NoneType]</code></dt>
<dd>Receives the event data and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_event(
    self, event: str, predicate: typing.Callable = None, timeout: float = None
) -&gt; typing.Any:
    &#34;&#34;&#34;BrowserContext.wait_for_event

    Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
    value. Will throw an error if the context closes before the event is fired. Returns the event data value.

    ```py
    context = await browser.new_context()
    await context.grant_permissions([\&#34;geolocation\&#34;])
    ```

    Parameters
    ----------
    event : str
        Event name, same one would pass into `browserContext.on(event)`.
    predicate : Union[Callable, NoneType]
        Receives the event data and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_context.wait_for_event started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.wait_for_event(
                event=event,
                predicate=self._wrap_handler(predicate),
                timeout=timeout,
            )
        )
        log_api(&#34;&lt;= browser_context.wait_for_event succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_context.wait_for_event failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.BrowserType"><code class="flex name class">
<span>class <span class="ident">BrowserType</span></span>
<span>(</span><span>obj: playwright._impl._browser_type.BrowserType)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BrowserType(AsyncBase):
    def __init__(self, obj: BrowserTypeImpl):
        super().__init__(obj)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;BrowserType.name

        Returns browser name. For example: `&#39;chromium&#39;`, `&#39;webkit&#39;` or `&#39;firefox&#39;`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.name)

    @property
    def executable_path(self) -&gt; str:
        &#34;&#34;&#34;BrowserType.executable_path

        A path where Playwright expects to find a bundled browser executable.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.executable_path)

    async def launch(
        self,
        executable_path: typing.Union[str, pathlib.Path] = None,
        args: typing.List[str] = None,
        ignore_default_args: typing.Union[bool, typing.List[str]] = None,
        handle_sigint: bool = None,
        handle_sigterm: bool = None,
        handle_sighup: bool = None,
        timeout: float = None,
        env: typing.Union[typing.Dict[str, typing.Union[str, float, bool]]] = None,
        headless: bool = None,
        devtools: bool = None,
        proxy: ProxySettings = None,
        downloads_path: typing.Union[str, pathlib.Path] = None,
        slow_mo: float = None,
        chromium_sandbox: bool = None,
        firefox_user_prefs: typing.Union[
            typing.Dict[str, typing.Union[str, float, bool]]
        ] = None,
    ) -&gt; &#34;Browser&#34;:
        &#34;&#34;&#34;BrowserType.launch

        Returns the browser instance.

        You can use `ignoreDefaultArgs` to filter out `--mute-audio` from default arguments:

        ```py
        browser = await playwright.chromium.launch( # or \&#34;firefox\&#34; or \&#34;webkit\&#34;.
            ignore_default_args=[\&#34;--mute-audio\&#34;]
        )
        ```

        &gt; **Chromium-only** Playwright can also be used to control the Chrome browser, but it works best with the version of
        Chromium it is bundled with. There is no guarantee it will work with any other version. Use `executablePath` option with
        extreme caution.
        &gt;
        &gt; If Google Chrome (rather than Chromium) is preferred, a
        [Chrome Canary](https://www.google.com/chrome/browser/canary.html) or
        [Dev Channel](https://www.chromium.org/getting-involved/dev-channel) build is suggested.
        &gt;
        &gt; In `browser_type.launch()` above, any mention of Chromium also applies to Chrome.
        &gt;
        &gt; See [`this article`](https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/) for
        a description of the differences between Chromium and Chrome.
        [`This article`](https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md)
        describes some differences for Linux users.

        Parameters
        ----------
        executable_path : Union[pathlib.Path, str, NoneType]
            Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is
            resolved relative to the current working directory. Note that Playwright only works with the bundled Chromium, Firefox
            or WebKit, use at your own risk.
        args : Union[List[str], NoneType]
            Additional arguments to pass to the browser instance. The list of Chromium flags can be found
            [here](http://peter.sh/experiments/chromium-command-line-switches/).
        ignore_default_args : Union[List[str], bool, NoneType]
            If `true`, Playwright does not pass its own configurations args and only uses the ones from `args`. If an array is
            given, then filters out the given default arguments. Dangerous option; use with care. Defaults to `false`.
        handle_sigint : Union[bool, NoneType]
            Close the browser process on Ctrl-C. Defaults to `true`.
        handle_sigterm : Union[bool, NoneType]
            Close the browser process on SIGTERM. Defaults to `true`.
        handle_sighup : Union[bool, NoneType]
            Close the browser process on SIGHUP. Defaults to `true`.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to
            disable timeout.
        env : Union[Dict[str, Union[bool, float, str]], NoneType]
            Specify environment variables that will be visible to the browser. Defaults to `process.env`.
        headless : Union[bool, NoneType]
            Whether to run browser in headless mode. More details for
            [Chromium](https://developers.google.com/web/updates/2017/04/headless-chrome) and
            [Firefox](https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode). Defaults to `true` unless the
            `devtools` option is `true`.
        devtools : Union[bool, NoneType]
            **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless`
            option will be set `false`.
        proxy : Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]
            Network proxy settings.
        downloads_path : Union[pathlib.Path, str, NoneType]
            If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is
            deleted when browser is closed.
        slow_mo : Union[float, NoneType]
            Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.
        chromium_sandbox : Union[bool, NoneType]
            Enable Chromium sandboxing. Defaults to `false`.
        firefox_user_prefs : Union[Dict[str, Union[bool, float, str]], NoneType]
            Firefox user preferences. Learn more about the Firefox user preferences at
            [`about:config`](https://support.mozilla.org/en-US/kb/about-config-editor-firefox).

        Returns
        -------
        Browser
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_type.launch started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.launch(
                    executablePath=executable_path,
                    args=args,
                    ignoreDefaultArgs=ignore_default_args,
                    handleSIGINT=handle_sigint,
                    handleSIGTERM=handle_sigterm,
                    handleSIGHUP=handle_sighup,
                    timeout=timeout,
                    env=mapping.to_impl(env),
                    headless=headless,
                    devtools=devtools,
                    proxy=proxy,
                    downloadsPath=downloads_path,
                    slowMo=slow_mo,
                    chromiumSandbox=chromium_sandbox,
                    firefoxUserPrefs=mapping.to_impl(firefox_user_prefs),
                )
            )
            log_api(&#34;&lt;= browser_type.launch succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_type.launch failed&#34;)
            raise e

    async def launch_persistent_context(
        self,
        user_data_dir: typing.Union[str, pathlib.Path],
        executable_path: typing.Union[str, pathlib.Path] = None,
        args: typing.List[str] = None,
        ignore_default_args: typing.Union[bool, typing.List[str]] = None,
        handle_sigint: bool = None,
        handle_sigterm: bool = None,
        handle_sighup: bool = None,
        timeout: float = None,
        env: typing.Union[typing.Dict[str, typing.Union[str, float, bool]]] = None,
        headless: bool = None,
        devtools: bool = None,
        proxy: ProxySettings = None,
        downloads_path: typing.Union[str, pathlib.Path] = None,
        slow_mo: float = None,
        viewport: ViewportSize = None,
        no_viewport: bool = None,
        ignore_https_errors: bool = None,
        java_script_enabled: bool = None,
        bypass_csp: bool = None,
        user_agent: str = None,
        locale: str = None,
        timezone_id: str = None,
        geolocation: Geolocation = None,
        permissions: typing.List[str] = None,
        extra_http_headers: typing.Union[typing.Dict[str, str]] = None,
        offline: bool = None,
        http_credentials: HttpCredentials = None,
        device_scale_factor: float = None,
        is_mobile: bool = None,
        has_touch: bool = None,
        color_scheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
        accept_downloads: bool = None,
        chromium_sandbox: bool = None,
        record_har_path: typing.Union[str, pathlib.Path] = None,
        record_har_omit_content: bool = None,
        record_video_dir: typing.Union[str, pathlib.Path] = None,
        record_video_size: ViewportSize = None,
    ) -&gt; &#34;BrowserContext&#34;:
        &#34;&#34;&#34;BrowserType.launch_persistent_context

        Returns the persistent browser context instance.

        Launches browser that uses persistent storage located at `userDataDir` and returns the only context. Closing this
        context will automatically close the browser.

        Parameters
        ----------
        user_data_dir : Union[pathlib.Path, str]
            Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for
            [Chromium](https://chromium.googlesource.com/chromium/src/+/master/docs/user_data_dir.md) and
            [Firefox](https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options#User_Profile).
        executable_path : Union[pathlib.Path, str, NoneType]
            Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is
            resolved relative to the current working directory. **BEWARE**: Playwright is only guaranteed to work with the bundled
            Chromium, Firefox or WebKit, use at your own risk.
        args : Union[List[str], NoneType]
            Additional arguments to pass to the browser instance. The list of Chromium flags can be found
            [here](http://peter.sh/experiments/chromium-command-line-switches/).
        ignore_default_args : Union[List[str], bool, NoneType]
            If `true`, then do not use any of the default arguments. If an array is given, then filter out the given default
            arguments. Dangerous option; use with care. Defaults to `false`.
        handle_sigint : Union[bool, NoneType]
            Close the browser process on Ctrl-C. Defaults to `true`.
        handle_sigterm : Union[bool, NoneType]
            Close the browser process on SIGTERM. Defaults to `true`.
        handle_sighup : Union[bool, NoneType]
            Close the browser process on SIGHUP. Defaults to `true`.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to
            disable timeout.
        env : Union[Dict[str, Union[bool, float, str]], NoneType]
            Specify environment variables that will be visible to the browser. Defaults to `process.env`.
        headless : Union[bool, NoneType]
            Whether to run browser in headless mode. More details for
            [Chromium](https://developers.google.com/web/updates/2017/04/headless-chrome) and
            [Firefox](https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode). Defaults to `true` unless the
            `devtools` option is `true`.
        devtools : Union[bool, NoneType]
            **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless`
            option will be set `false`.
        proxy : Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]
            Network proxy settings.
        downloads_path : Union[pathlib.Path, str, NoneType]
            If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is
            deleted when browser is closed.
        slow_mo : Union[float, NoneType]
            Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.
            Defaults to 0.
        viewport : Union[{width: int, height: int}, NoneType]
            Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed viewport.
        no_viewport : Union[bool, NoneType]
            Does not enforce fixed viewport, allows resizing window in the headed mode.
        ignore_https_errors : Union[bool, NoneType]
            Whether to ignore HTTPS errors during navigation. Defaults to `false`.
        java_script_enabled : Union[bool, NoneType]
            Whether or not to enable JavaScript in the context. Defaults to `true`.
        bypass_csp : Union[bool, NoneType]
            Toggles bypassing page&#39;s Content-Security-Policy.
        user_agent : Union[str, NoneType]
            Specific user agent to use in this context.
        locale : Union[str, NoneType]
            Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language`
            request header value as well as number and date formatting rules.
        timezone_id : Union[str, NoneType]
            Changes the timezone of the context. See
            [ICU&#39;s metaZones.txt](https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1)
            for a list of supported timezone IDs.
        geolocation : Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]
        permissions : Union[List[str], NoneType]
            A list of permissions to grant to all pages in this context. See `browser_context.grant_permissions()` for more
            details.
        extra_http_headers : Union[Dict[str, str], NoneType]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        offline : Union[bool, NoneType]
            Whether to emulate network being offline. Defaults to `false`.
        http_credentials : Union[{username: str, password: str}, NoneType]
            Credentials for [HTTP authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication).
        device_scale_factor : Union[float, NoneType]
            Specify device scale factor (can be thought of as dpr). Defaults to `1`.
        is_mobile : Union[bool, NoneType]
            Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported
            in Firefox.
        has_touch : Union[bool, NoneType]
            Specifies if viewport supports touch events. Defaults to false.
        color_scheme : Union[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;, NoneType]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See
            `page.emulate_media()` for more details. Defaults to &#39;`light`&#39;.
        accept_downloads : Union[bool, NoneType]
            Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
        chromium_sandbox : Union[bool, NoneType]
            Enable Chromium sandboxing. Defaults to `true`.
        record_har_path : Union[pathlib.Path, str, NoneType]
            Path on the filesystem to write the HAR file to.
        record_har_omit_content : Union[bool, NoneType]
            Optional setting to control whether to omit request content from the HAR. Defaults to `false`.
        record_video_dir : Union[pathlib.Path, str, NoneType]
            Path to the directory to put videos into.
        record_video_size : Union[{width: int, height: int}, NoneType]
            Optional dimensions of the recorded videos. If not specified the size will be equal to `viewport`.

        Returns
        -------
        BrowserContext
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; browser_type.launch_persistent_context started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.launch_persistent_context(
                    userDataDir=user_data_dir,
                    executablePath=executable_path,
                    args=args,
                    ignoreDefaultArgs=ignore_default_args,
                    handleSIGINT=handle_sigint,
                    handleSIGTERM=handle_sigterm,
                    handleSIGHUP=handle_sighup,
                    timeout=timeout,
                    env=mapping.to_impl(env),
                    headless=headless,
                    devtools=devtools,
                    proxy=proxy,
                    downloadsPath=downloads_path,
                    slowMo=slow_mo,
                    viewport=viewport,
                    noViewport=no_viewport,
                    ignoreHTTPSErrors=ignore_https_errors,
                    javaScriptEnabled=java_script_enabled,
                    bypassCSP=bypass_csp,
                    userAgent=user_agent,
                    locale=locale,
                    timezoneId=timezone_id,
                    geolocation=geolocation,
                    permissions=permissions,
                    extraHTTPHeaders=mapping.to_impl(extra_http_headers),
                    offline=offline,
                    httpCredentials=http_credentials,
                    deviceScaleFactor=device_scale_factor,
                    isMobile=is_mobile,
                    hasTouch=has_touch,
                    colorScheme=color_scheme,
                    acceptDownloads=accept_downloads,
                    chromiumSandbox=chromium_sandbox,
                    recordHarPath=record_har_path,
                    recordHarOmitContent=record_har_omit_content,
                    recordVideoDir=record_video_dir,
                    recordVideoSize=record_video_size,
                )
            )
            log_api(&#34;&lt;= browser_type.launch_persistent_context succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= browser_type.launch_persistent_context failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.BrowserType.executable_path"><code class="name">var <span class="ident">executable_path</span> : str</code></dt>
<dd>
<div class="desc"><p>BrowserType.executable_path</p>
<p>A path where Playwright expects to find a bundled browser executable.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def executable_path(self) -&gt; str:
    &#34;&#34;&#34;BrowserType.executable_path

    A path where Playwright expects to find a bundled browser executable.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.executable_path)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserType.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>BrowserType.name</p>
<p>Returns browser name. For example: <code>'chromium'</code>, <code>'webkit'</code> or <code>'firefox'</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;BrowserType.name

    Returns browser name. For example: `&#39;chromium&#39;`, `&#39;webkit&#39;` or `&#39;firefox&#39;`.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.name)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.BrowserType.launch"><code class="name flex">
<span>async def <span class="ident">launch</span></span>(<span>self, executable_path: Union[str, pathlib.Path] = None, args: List[str] = None, ignore_default_args: Union[bool, List[str]] = None, handle_sigint: bool = None, handle_sigterm: bool = None, handle_sighup: bool = None, timeout: float = None, env: Dict[str, Union[str, float, bool]] = None, headless: bool = None, devtools: bool = None, proxy: playwright._impl._api_structures.ProxySettings = None, downloads_path: Union[str, pathlib.Path] = None, slow_mo: float = None, chromium_sandbox: bool = None, firefox_user_prefs: Dict[str, Union[str, float, bool]] = None) ‑> playwright.async_api._generated.Browser</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserType.launch</p>
<p>Returns the browser instance.</p>
<p>You can use <code>ignoreDefaultArgs</code> to filter out <code>--mute-audio</code> from default arguments:</p>
<pre><code class="language-py">browser = await playwright.chromium.launch( # or &quot;firefox&quot; or &quot;webkit&quot;.
    ignore_default_args=[&quot;--mute-audio&quot;]
)
</code></pre>
<blockquote>
<p><strong>Chromium-only</strong> Playwright can also be used to control the Chrome browser, but it works best with the version of
Chromium it is bundled with. There is no guarantee it will work with any other version. Use <code>executablePath</code> option with
extreme caution.</p>
<p>If Google Chrome (rather than Chromium) is preferred, a
<a href="https://www.google.com/chrome/browser/canary.html">Chrome Canary</a> or
<a href="https://www.chromium.org/getting-involved/dev-channel">Dev Channel</a> build is suggested.</p>
<p>In <code>browser_type.launch()</code> above, any mention of Chromium also applies to Chrome.</p>
<p>See <a href="https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/"><code>this article</code></a> for
a description of the differences between Chromium and Chrome.
<a href="https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md"><code>This article</code></a>
describes some differences for Linux users.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>executable_path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to a browser executable to run instead of the bundled one. If <code>executablePath</code> is a relative path, then it is
resolved relative to the current working directory. Note that Playwright only works with the bundled Chromium, Firefox
or WebKit, use at your own risk.</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>Union[List[str], NoneType]</code></dt>
<dd>Additional arguments to pass to the browser instance. The list of Chromium flags can be found
<a href="http://peter.sh/experiments/chromium-command-line-switches/">here</a>.</dd>
<dt><strong><code>ignore_default_args</code></strong> :&ensp;<code>Union[List[str], bool, NoneType]</code></dt>
<dd>If <code>true</code>, Playwright does not pass its own configurations args and only uses the ones from <code>args</code>. If an array is
given, then filters out the given default arguments. Dangerous option; use with care. Defaults to <code>false</code>.</dd>
<dt><strong><code>handle_sigint</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Close the browser process on Ctrl-C. Defaults to <code>true</code>.</dd>
<dt><strong><code>handle_sigterm</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Close the browser process on SIGTERM. Defaults to <code>true</code>.</dd>
<dt><strong><code>handle_sighup</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Close the browser process on SIGHUP. Defaults to <code>true</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds to wait for the browser instance to start. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to
disable timeout.</dd>
<dt><strong><code>env</code></strong> :&ensp;<code>Union[Dict[str, Union[bool, float, str]], NoneType]</code></dt>
<dd>Specify environment variables that will be visible to the browser. Defaults to <code>process.env</code>.</dd>
<dt><strong><code>headless</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to run browser in headless mode. More details for
<a href="https://developers.google.com/web/updates/2017/04/headless-chrome">Chromium</a> and
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode">Firefox</a>. Defaults to <code>true</code> unless the
<code>devtools</code> option is <code>true</code>.</dd>
<dt><strong><code>devtools</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd><strong>Chromium-only</strong> Whether to auto-open a Developer Tools panel for each tab. If this option is <code>true</code>, the <code>headless</code>
option will be set <code>false</code>.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]</code></dt>
<dd>Network proxy settings.</dd>
<dt><strong><code>downloads_path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is
deleted when browser is closed.</dd>
<dt><strong><code>slow_mo</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.</dd>
<dt><strong><code>chromium_sandbox</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Enable Chromium sandboxing. Defaults to <code>false</code>.</dd>
<dt><strong><code>firefox_user_prefs</code></strong> :&ensp;<code>Union[Dict[str, Union[bool, float, str]], NoneType]</code></dt>
<dd>Firefox user preferences. Learn more about the Firefox user preferences at
<a href="https://support.mozilla.org/en-US/kb/about-config-editor-firefox"><code>about:config</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Browser" href="#playwright.async_api.Browser">Browser</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def launch(
    self,
    executable_path: typing.Union[str, pathlib.Path] = None,
    args: typing.List[str] = None,
    ignore_default_args: typing.Union[bool, typing.List[str]] = None,
    handle_sigint: bool = None,
    handle_sigterm: bool = None,
    handle_sighup: bool = None,
    timeout: float = None,
    env: typing.Union[typing.Dict[str, typing.Union[str, float, bool]]] = None,
    headless: bool = None,
    devtools: bool = None,
    proxy: ProxySettings = None,
    downloads_path: typing.Union[str, pathlib.Path] = None,
    slow_mo: float = None,
    chromium_sandbox: bool = None,
    firefox_user_prefs: typing.Union[
        typing.Dict[str, typing.Union[str, float, bool]]
    ] = None,
) -&gt; &#34;Browser&#34;:
    &#34;&#34;&#34;BrowserType.launch

    Returns the browser instance.

    You can use `ignoreDefaultArgs` to filter out `--mute-audio` from default arguments:

    ```py
    browser = await playwright.chromium.launch( # or \&#34;firefox\&#34; or \&#34;webkit\&#34;.
        ignore_default_args=[\&#34;--mute-audio\&#34;]
    )
    ```

    &gt; **Chromium-only** Playwright can also be used to control the Chrome browser, but it works best with the version of
    Chromium it is bundled with. There is no guarantee it will work with any other version. Use `executablePath` option with
    extreme caution.
    &gt;
    &gt; If Google Chrome (rather than Chromium) is preferred, a
    [Chrome Canary](https://www.google.com/chrome/browser/canary.html) or
    [Dev Channel](https://www.chromium.org/getting-involved/dev-channel) build is suggested.
    &gt;
    &gt; In `browser_type.launch()` above, any mention of Chromium also applies to Chrome.
    &gt;
    &gt; See [`this article`](https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/) for
    a description of the differences between Chromium and Chrome.
    [`This article`](https://chromium.googlesource.com/chromium/src/+/lkgr/docs/chromium_browser_vs_google_chrome.md)
    describes some differences for Linux users.

    Parameters
    ----------
    executable_path : Union[pathlib.Path, str, NoneType]
        Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is
        resolved relative to the current working directory. Note that Playwright only works with the bundled Chromium, Firefox
        or WebKit, use at your own risk.
    args : Union[List[str], NoneType]
        Additional arguments to pass to the browser instance. The list of Chromium flags can be found
        [here](http://peter.sh/experiments/chromium-command-line-switches/).
    ignore_default_args : Union[List[str], bool, NoneType]
        If `true`, Playwright does not pass its own configurations args and only uses the ones from `args`. If an array is
        given, then filters out the given default arguments. Dangerous option; use with care. Defaults to `false`.
    handle_sigint : Union[bool, NoneType]
        Close the browser process on Ctrl-C. Defaults to `true`.
    handle_sigterm : Union[bool, NoneType]
        Close the browser process on SIGTERM. Defaults to `true`.
    handle_sighup : Union[bool, NoneType]
        Close the browser process on SIGHUP. Defaults to `true`.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to
        disable timeout.
    env : Union[Dict[str, Union[bool, float, str]], NoneType]
        Specify environment variables that will be visible to the browser. Defaults to `process.env`.
    headless : Union[bool, NoneType]
        Whether to run browser in headless mode. More details for
        [Chromium](https://developers.google.com/web/updates/2017/04/headless-chrome) and
        [Firefox](https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode). Defaults to `true` unless the
        `devtools` option is `true`.
    devtools : Union[bool, NoneType]
        **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless`
        option will be set `false`.
    proxy : Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]
        Network proxy settings.
    downloads_path : Union[pathlib.Path, str, NoneType]
        If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is
        deleted when browser is closed.
    slow_mo : Union[float, NoneType]
        Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.
    chromium_sandbox : Union[bool, NoneType]
        Enable Chromium sandboxing. Defaults to `false`.
    firefox_user_prefs : Union[Dict[str, Union[bool, float, str]], NoneType]
        Firefox user preferences. Learn more about the Firefox user preferences at
        [`about:config`](https://support.mozilla.org/en-US/kb/about-config-editor-firefox).

    Returns
    -------
    Browser
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_type.launch started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.launch(
                executablePath=executable_path,
                args=args,
                ignoreDefaultArgs=ignore_default_args,
                handleSIGINT=handle_sigint,
                handleSIGTERM=handle_sigterm,
                handleSIGHUP=handle_sighup,
                timeout=timeout,
                env=mapping.to_impl(env),
                headless=headless,
                devtools=devtools,
                proxy=proxy,
                downloadsPath=downloads_path,
                slowMo=slow_mo,
                chromiumSandbox=chromium_sandbox,
                firefoxUserPrefs=mapping.to_impl(firefox_user_prefs),
            )
        )
        log_api(&#34;&lt;= browser_type.launch succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_type.launch failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.BrowserType.launch_persistent_context"><code class="name flex">
<span>async def <span class="ident">launch_persistent_context</span></span>(<span>self, user_data_dir: Union[str, pathlib.Path], executable_path: Union[str, pathlib.Path] = None, args: List[str] = None, ignore_default_args: Union[bool, List[str]] = None, handle_sigint: bool = None, handle_sigterm: bool = None, handle_sighup: bool = None, timeout: float = None, env: Dict[str, Union[str, float, bool]] = None, headless: bool = None, devtools: bool = None, proxy: playwright._impl._api_structures.ProxySettings = None, downloads_path: Union[str, pathlib.Path] = None, slow_mo: float = None, viewport: playwright._impl._api_structures.ViewportSize = None, no_viewport: bool = None, ignore_https_errors: bool = None, java_script_enabled: bool = None, bypass_csp: bool = None, user_agent: str = None, locale: str = None, timezone_id: str = None, geolocation: playwright._impl._api_structures.Geolocation = None, permissions: List[str] = None, extra_http_headers: Dict[str, str] = None, offline: bool = None, http_credentials: playwright._impl._api_structures.HttpCredentials = None, device_scale_factor: float = None, is_mobile: bool = None, has_touch: bool = None, color_scheme: Literal['dark', 'light', 'no-preference'] = None, accept_downloads: bool = None, chromium_sandbox: bool = None, record_har_path: Union[str, pathlib.Path] = None, record_har_omit_content: bool = None, record_video_dir: Union[str, pathlib.Path] = None, record_video_size: playwright._impl._api_structures.ViewportSize = None) ‑> playwright.async_api._generated.BrowserContext</span>
</code></dt>
<dd>
<div class="desc"><p>BrowserType.launch_persistent_context</p>
<p>Returns the persistent browser context instance.</p>
<p>Launches browser that uses persistent storage located at <code>userDataDir</code> and returns the only context. Closing this
context will automatically close the browser.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>user_data_dir</code></strong> :&ensp;<code>Union[pathlib.Path, str]</code></dt>
<dd>Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for
<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/user_data_dir.md">Chromium</a> and
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options#User_Profile">Firefox</a>.</dd>
<dt><strong><code>executable_path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to a browser executable to run instead of the bundled one. If <code>executablePath</code> is a relative path, then it is
resolved relative to the current working directory. <strong>BEWARE</strong>: Playwright is only guaranteed to work with the bundled
Chromium, Firefox or WebKit, use at your own risk.</dd>
<dt><strong><code>args</code></strong> :&ensp;<code>Union[List[str], NoneType]</code></dt>
<dd>Additional arguments to pass to the browser instance. The list of Chromium flags can be found
<a href="http://peter.sh/experiments/chromium-command-line-switches/">here</a>.</dd>
<dt><strong><code>ignore_default_args</code></strong> :&ensp;<code>Union[List[str], bool, NoneType]</code></dt>
<dd>If <code>true</code>, then do not use any of the default arguments. If an array is given, then filter out the given default
arguments. Dangerous option; use with care. Defaults to <code>false</code>.</dd>
<dt><strong><code>handle_sigint</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Close the browser process on Ctrl-C. Defaults to <code>true</code>.</dd>
<dt><strong><code>handle_sigterm</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Close the browser process on SIGTERM. Defaults to <code>true</code>.</dd>
<dt><strong><code>handle_sighup</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Close the browser process on SIGHUP. Defaults to <code>true</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds to wait for the browser instance to start. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to
disable timeout.</dd>
<dt><strong><code>env</code></strong> :&ensp;<code>Union[Dict[str, Union[bool, float, str]], NoneType]</code></dt>
<dd>Specify environment variables that will be visible to the browser. Defaults to <code>process.env</code>.</dd>
<dt><strong><code>headless</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to run browser in headless mode. More details for
<a href="https://developers.google.com/web/updates/2017/04/headless-chrome">Chromium</a> and
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode">Firefox</a>. Defaults to <code>true</code> unless the
<code>devtools</code> option is <code>true</code>.</dd>
<dt><strong><code>devtools</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd><strong>Chromium-only</strong> Whether to auto-open a Developer Tools panel for each tab. If this option is <code>true</code>, the <code>headless</code>
option will be set <code>false</code>.</dd>
<dt><strong><code>proxy</code></strong> :&ensp;<code>Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]</code></dt>
<dd>Network proxy settings.</dd>
<dt><strong><code>downloads_path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is
deleted when browser is closed.</dd>
<dt><strong><code>slow_mo</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.
Defaults to 0.</dd>
<dt><strong><code>viewport</code></strong> :&ensp;<code>Union[{width: int, height: int}, NoneType]</code></dt>
<dd>Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. <code>no_viewport</code> disables the fixed viewport.</dd>
<dt><strong><code>no_viewport</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Does not enforce fixed viewport, allows resizing window in the headed mode.</dd>
<dt><strong><code>ignore_https_errors</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to ignore HTTPS errors during navigation. Defaults to <code>false</code>.</dd>
<dt><strong><code>java_script_enabled</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether or not to enable JavaScript in the context. Defaults to <code>true</code>.</dd>
<dt><strong><code>bypass_csp</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Toggles bypassing page's Content-Security-Policy.</dd>
<dt><strong><code>user_agent</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Specific user agent to use in this context.</dd>
<dt><strong><code>locale</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Specify user locale, for example <code>en-GB</code>, <code>de-DE</code>, etc. Locale will affect <code>navigator.language</code> value, <code>Accept-Language</code>
request header value as well as number and date formatting rules.</dd>
<dt><strong><code>timezone_id</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Changes the timezone of the context. See
<a href="https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1">ICU's metaZones.txt</a>
for a list of supported timezone IDs.</dd>
<dt><strong><code>geolocation</code></strong> :&ensp;<code>Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>permissions</code></strong> :&ensp;<code>Union[List[str], NoneType]</code></dt>
<dd>A list of permissions to grant to all pages in this context. See <code>browser_context.grant_permissions()</code> for more
details.</dd>
<dt><strong><code>extra_http_headers</code></strong> :&ensp;<code>Union[Dict[str, str], NoneType]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
<dt><strong><code>offline</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to emulate network being offline. Defaults to <code>false</code>.</dd>
<dt><strong><code>http_credentials</code></strong> :&ensp;<code>Union[{username: str, password: str}, NoneType]</code></dt>
<dd>Credentials for <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication">HTTP authentication</a>.</dd>
<dt><strong><code>device_scale_factor</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Specify device scale factor (can be thought of as dpr). Defaults to <code>1</code>.</dd>
<dt><strong><code>is_mobile</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether the <code>meta viewport</code> tag is taken into account and touch events are enabled. Defaults to <code>false</code>. Not supported
in Firefox.</dd>
<dt><strong><code>has_touch</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Specifies if viewport supports touch events. Defaults to false.</dd>
<dt><strong><code>color_scheme</code></strong> :&ensp;<code>Union["dark", "light", "no-preference", NoneType]</code></dt>
<dd>Emulates <code>'prefers-colors-scheme'</code> media feature, supported values are <code>'light'</code>, <code>'dark'</code>, <code>'no-preference'</code>. See
<code>page.emulate_media()</code> for more details. Defaults to '<code>light</code>'.</dd>
<dt><strong><code>accept_downloads</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to automatically download all the attachments. Defaults to <code>false</code> where all the downloads are canceled.</dd>
<dt><strong><code>chromium_sandbox</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Enable Chromium sandboxing. Defaults to <code>true</code>.</dd>
<dt><strong><code>record_har_path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path on the filesystem to write the HAR file to.</dd>
<dt><strong><code>record_har_omit_content</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Optional setting to control whether to omit request content from the HAR. Defaults to <code>false</code>.</dd>
<dt><strong><code>record_video_dir</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the directory to put videos into.</dd>
<dt><strong><code>record_video_size</code></strong> :&ensp;<code>Union[{width: int, height: int}, NoneType]</code></dt>
<dd>Optional dimensions of the recorded videos. If not specified the size will be equal to <code>viewport</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.BrowserContext" href="#playwright.async_api.BrowserContext">BrowserContext</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def launch_persistent_context(
    self,
    user_data_dir: typing.Union[str, pathlib.Path],
    executable_path: typing.Union[str, pathlib.Path] = None,
    args: typing.List[str] = None,
    ignore_default_args: typing.Union[bool, typing.List[str]] = None,
    handle_sigint: bool = None,
    handle_sigterm: bool = None,
    handle_sighup: bool = None,
    timeout: float = None,
    env: typing.Union[typing.Dict[str, typing.Union[str, float, bool]]] = None,
    headless: bool = None,
    devtools: bool = None,
    proxy: ProxySettings = None,
    downloads_path: typing.Union[str, pathlib.Path] = None,
    slow_mo: float = None,
    viewport: ViewportSize = None,
    no_viewport: bool = None,
    ignore_https_errors: bool = None,
    java_script_enabled: bool = None,
    bypass_csp: bool = None,
    user_agent: str = None,
    locale: str = None,
    timezone_id: str = None,
    geolocation: Geolocation = None,
    permissions: typing.List[str] = None,
    extra_http_headers: typing.Union[typing.Dict[str, str]] = None,
    offline: bool = None,
    http_credentials: HttpCredentials = None,
    device_scale_factor: float = None,
    is_mobile: bool = None,
    has_touch: bool = None,
    color_scheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
    accept_downloads: bool = None,
    chromium_sandbox: bool = None,
    record_har_path: typing.Union[str, pathlib.Path] = None,
    record_har_omit_content: bool = None,
    record_video_dir: typing.Union[str, pathlib.Path] = None,
    record_video_size: ViewportSize = None,
) -&gt; &#34;BrowserContext&#34;:
    &#34;&#34;&#34;BrowserType.launch_persistent_context

    Returns the persistent browser context instance.

    Launches browser that uses persistent storage located at `userDataDir` and returns the only context. Closing this
    context will automatically close the browser.

    Parameters
    ----------
    user_data_dir : Union[pathlib.Path, str]
        Path to a User Data Directory, which stores browser session data like cookies and local storage. More details for
        [Chromium](https://chromium.googlesource.com/chromium/src/+/master/docs/user_data_dir.md) and
        [Firefox](https://developer.mozilla.org/en-US/docs/Mozilla/Command_Line_Options#User_Profile).
    executable_path : Union[pathlib.Path, str, NoneType]
        Path to a browser executable to run instead of the bundled one. If `executablePath` is a relative path, then it is
        resolved relative to the current working directory. **BEWARE**: Playwright is only guaranteed to work with the bundled
        Chromium, Firefox or WebKit, use at your own risk.
    args : Union[List[str], NoneType]
        Additional arguments to pass to the browser instance. The list of Chromium flags can be found
        [here](http://peter.sh/experiments/chromium-command-line-switches/).
    ignore_default_args : Union[List[str], bool, NoneType]
        If `true`, then do not use any of the default arguments. If an array is given, then filter out the given default
        arguments. Dangerous option; use with care. Defaults to `false`.
    handle_sigint : Union[bool, NoneType]
        Close the browser process on Ctrl-C. Defaults to `true`.
    handle_sigterm : Union[bool, NoneType]
        Close the browser process on SIGTERM. Defaults to `true`.
    handle_sighup : Union[bool, NoneType]
        Close the browser process on SIGHUP. Defaults to `true`.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds to wait for the browser instance to start. Defaults to `30000` (30 seconds). Pass `0` to
        disable timeout.
    env : Union[Dict[str, Union[bool, float, str]], NoneType]
        Specify environment variables that will be visible to the browser. Defaults to `process.env`.
    headless : Union[bool, NoneType]
        Whether to run browser in headless mode. More details for
        [Chromium](https://developers.google.com/web/updates/2017/04/headless-chrome) and
        [Firefox](https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Headless_mode). Defaults to `true` unless the
        `devtools` option is `true`.
    devtools : Union[bool, NoneType]
        **Chromium-only** Whether to auto-open a Developer Tools panel for each tab. If this option is `true`, the `headless`
        option will be set `false`.
    proxy : Union[{server: str, bypass: Union[str, NoneType], username: Union[str, NoneType], password: Union[str, NoneType]}, NoneType]
        Network proxy settings.
    downloads_path : Union[pathlib.Path, str, NoneType]
        If specified, accepted downloads are downloaded into this directory. Otherwise, temporary directory is created and is
        deleted when browser is closed.
    slow_mo : Union[float, NoneType]
        Slows down Playwright operations by the specified amount of milliseconds. Useful so that you can see what is going on.
        Defaults to 0.
    viewport : Union[{width: int, height: int}, NoneType]
        Sets a consistent viewport for each page. Defaults to an 1280x720 viewport. `no_viewport` disables the fixed viewport.
    no_viewport : Union[bool, NoneType]
        Does not enforce fixed viewport, allows resizing window in the headed mode.
    ignore_https_errors : Union[bool, NoneType]
        Whether to ignore HTTPS errors during navigation. Defaults to `false`.
    java_script_enabled : Union[bool, NoneType]
        Whether or not to enable JavaScript in the context. Defaults to `true`.
    bypass_csp : Union[bool, NoneType]
        Toggles bypassing page&#39;s Content-Security-Policy.
    user_agent : Union[str, NoneType]
        Specific user agent to use in this context.
    locale : Union[str, NoneType]
        Specify user locale, for example `en-GB`, `de-DE`, etc. Locale will affect `navigator.language` value, `Accept-Language`
        request header value as well as number and date formatting rules.
    timezone_id : Union[str, NoneType]
        Changes the timezone of the context. See
        [ICU&#39;s metaZones.txt](https://cs.chromium.org/chromium/src/third_party/icu/source/data/misc/metaZones.txt?rcl=faee8bc70570192d82d2978a71e2a615788597d1)
        for a list of supported timezone IDs.
    geolocation : Union[{latitude: float, longitude: float, accuracy: Union[float, NoneType]}, NoneType]
    permissions : Union[List[str], NoneType]
        A list of permissions to grant to all pages in this context. See `browser_context.grant_permissions()` for more
        details.
    extra_http_headers : Union[Dict[str, str], NoneType]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    offline : Union[bool, NoneType]
        Whether to emulate network being offline. Defaults to `false`.
    http_credentials : Union[{username: str, password: str}, NoneType]
        Credentials for [HTTP authentication](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication).
    device_scale_factor : Union[float, NoneType]
        Specify device scale factor (can be thought of as dpr). Defaults to `1`.
    is_mobile : Union[bool, NoneType]
        Whether the `meta viewport` tag is taken into account and touch events are enabled. Defaults to `false`. Not supported
        in Firefox.
    has_touch : Union[bool, NoneType]
        Specifies if viewport supports touch events. Defaults to false.
    color_scheme : Union[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;, NoneType]
        Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. See
        `page.emulate_media()` for more details. Defaults to &#39;`light`&#39;.
    accept_downloads : Union[bool, NoneType]
        Whether to automatically download all the attachments. Defaults to `false` where all the downloads are canceled.
    chromium_sandbox : Union[bool, NoneType]
        Enable Chromium sandboxing. Defaults to `true`.
    record_har_path : Union[pathlib.Path, str, NoneType]
        Path on the filesystem to write the HAR file to.
    record_har_omit_content : Union[bool, NoneType]
        Optional setting to control whether to omit request content from the HAR. Defaults to `false`.
    record_video_dir : Union[pathlib.Path, str, NoneType]
        Path to the directory to put videos into.
    record_video_size : Union[{width: int, height: int}, NoneType]
        Optional dimensions of the recorded videos. If not specified the size will be equal to `viewport`.

    Returns
    -------
    BrowserContext
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; browser_type.launch_persistent_context started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.launch_persistent_context(
                userDataDir=user_data_dir,
                executablePath=executable_path,
                args=args,
                ignoreDefaultArgs=ignore_default_args,
                handleSIGINT=handle_sigint,
                handleSIGTERM=handle_sigterm,
                handleSIGHUP=handle_sighup,
                timeout=timeout,
                env=mapping.to_impl(env),
                headless=headless,
                devtools=devtools,
                proxy=proxy,
                downloadsPath=downloads_path,
                slowMo=slow_mo,
                viewport=viewport,
                noViewport=no_viewport,
                ignoreHTTPSErrors=ignore_https_errors,
                javaScriptEnabled=java_script_enabled,
                bypassCSP=bypass_csp,
                userAgent=user_agent,
                locale=locale,
                timezoneId=timezone_id,
                geolocation=geolocation,
                permissions=permissions,
                extraHTTPHeaders=mapping.to_impl(extra_http_headers),
                offline=offline,
                httpCredentials=http_credentials,
                deviceScaleFactor=device_scale_factor,
                isMobile=is_mobile,
                hasTouch=has_touch,
                colorScheme=color_scheme,
                acceptDownloads=accept_downloads,
                chromiumSandbox=chromium_sandbox,
                recordHarPath=record_har_path,
                recordHarOmitContent=record_har_omit_content,
                recordVideoDir=record_video_dir,
                recordVideoSize=record_video_size,
            )
        )
        log_api(&#34;&lt;= browser_type.launch_persistent_context succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= browser_type.launch_persistent_context failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.CDPSession"><code class="flex name class">
<span>class <span class="ident">CDPSession</span></span>
<span>(</span><span>obj: playwright._impl._cdp_session.CDPSession)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CDPSession(AsyncBase):
    def __init__(self, obj: CDPSessionImpl):
        super().__init__(obj)

    async def send(self, method: str, params: typing.Dict = None) -&gt; typing.Dict:
        &#34;&#34;&#34;CDPSession.send

        Parameters
        ----------
        method : str
            protocol method name
        params : Union[Dict, NoneType]
            Optional method parameters

        Returns
        -------
        Dict
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; cdp_session.send started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.send(method=method, params=mapping.to_impl(params))
            )
            log_api(&#34;&lt;= cdp_session.send succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= cdp_session.send failed&#34;)
            raise e

    async def detach(self) -&gt; NoneType:
        &#34;&#34;&#34;CDPSession.detach

        Detaches the CDPSession from the target. Once detached, the CDPSession object won&#39;t emit any events and can&#39;t be used to
        send messages.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; cdp_session.detach started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.detach())
            log_api(&#34;&lt;= cdp_session.detach succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= cdp_session.detach failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.CDPSession.detach"><code class="name flex">
<span>async def <span class="ident">detach</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>CDPSession.detach</p>
<p>Detaches the CDPSession from the target. Once detached, the CDPSession object won't emit any events and can't be used to
send messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def detach(self) -&gt; NoneType:
    &#34;&#34;&#34;CDPSession.detach

    Detaches the CDPSession from the target. Once detached, the CDPSession object won&#39;t emit any events and can&#39;t be used to
    send messages.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; cdp_session.detach started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.detach())
        log_api(&#34;&lt;= cdp_session.detach succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= cdp_session.detach failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.CDPSession.send"><code class="name flex">
<span>async def <span class="ident">send</span></span>(<span>self, method: str, params: Dict = None) ‑> Dict</span>
</code></dt>
<dd>
<div class="desc"><p>CDPSession.send</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>protocol method name</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Union[Dict, NoneType]</code></dt>
<dd>Optional method parameters</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send(self, method: str, params: typing.Dict = None) -&gt; typing.Dict:
    &#34;&#34;&#34;CDPSession.send

    Parameters
    ----------
    method : str
        protocol method name
    params : Union[Dict, NoneType]
        Optional method parameters

    Returns
    -------
    Dict
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; cdp_session.send started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.send(method=method, params=mapping.to_impl(params))
        )
        log_api(&#34;&lt;= cdp_session.send succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= cdp_session.send failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.ChromiumBrowserContext"><code class="flex name class">
<span>class <span class="ident">ChromiumBrowserContext</span></span>
<span>(</span><span>obj: playwright._impl._chromium_browser_context.ChromiumBrowserContext)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChromiumBrowserContext(BrowserContext):
    def __init__(self, obj: ChromiumBrowserContextImpl):
        super().__init__(obj)

    @property
    def background_pages(self) -&gt; typing.List[&#34;Page&#34;]:
        &#34;&#34;&#34;ChromiumBrowserContext.background_pages

        All existing background pages in the context.

        Returns
        -------
        List[Page]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.background_pages)

    @property
    def service_workers(self) -&gt; typing.List[&#34;Worker&#34;]:
        &#34;&#34;&#34;ChromiumBrowserContext.service_workers

        All existing service workers in the context.

        Returns
        -------
        List[Worker]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.service_workers)

    async def new_cdp_session(self, page: &#34;Page&#34;) -&gt; &#34;CDPSession&#34;:
        &#34;&#34;&#34;ChromiumBrowserContext.new_cdp_session

        Returns the newly created session.

        Parameters
        ----------
        page : Page
            Page to create new session for.

        Returns
        -------
        CDPSession
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; chromium_browser_context.new_cdp_session started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.new_cdp_session(page=page._impl_obj)
            )
            log_api(&#34;&lt;= chromium_browser_context.new_cdp_session succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= chromium_browser_context.new_cdp_session failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.async_api._generated.BrowserContext</li>
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.ChromiumBrowserContext.background_pages"><code class="name">var <span class="ident">background_pages</span> : List[playwright.async_api._generated.Page]</code></dt>
<dd>
<div class="desc"><p>ChromiumBrowserContext.background_pages</p>
<p>All existing background pages in the context.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def background_pages(self) -&gt; typing.List[&#34;Page&#34;]:
    &#34;&#34;&#34;ChromiumBrowserContext.background_pages

    All existing background pages in the context.

    Returns
    -------
    List[Page]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.background_pages)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ChromiumBrowserContext.service_workers"><code class="name">var <span class="ident">service_workers</span> : List[playwright.async_api._generated.Worker]</code></dt>
<dd>
<div class="desc"><p>ChromiumBrowserContext.service_workers</p>
<p>All existing service workers in the context.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.Worker" href="#playwright.async_api.Worker">Worker</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def service_workers(self) -&gt; typing.List[&#34;Worker&#34;]:
    &#34;&#34;&#34;ChromiumBrowserContext.service_workers

    All existing service workers in the context.

    Returns
    -------
    List[Worker]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.service_workers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.ChromiumBrowserContext.new_cdp_session"><code class="name flex">
<span>async def <span class="ident">new_cdp_session</span></span>(<span>self, page: <a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>) ‑> playwright.async_api._generated.CDPSession</span>
</code></dt>
<dd>
<div class="desc"><p>ChromiumBrowserContext.new_cdp_session</p>
<p>Returns the newly created session.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>page</code></strong> :&ensp;<code><a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a></code></dt>
<dd>Page to create new session for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.CDPSession" href="#playwright.async_api.CDPSession">CDPSession</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def new_cdp_session(self, page: &#34;Page&#34;) -&gt; &#34;CDPSession&#34;:
    &#34;&#34;&#34;ChromiumBrowserContext.new_cdp_session

    Returns the newly created session.

    Parameters
    ----------
    page : Page
        Page to create new session for.

    Returns
    -------
    CDPSession
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; chromium_browser_context.new_cdp_session started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.new_cdp_session(page=page._impl_obj)
        )
        log_api(&#34;&lt;= chromium_browser_context.new_cdp_session succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= chromium_browser_context.new_cdp_session failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.ConsoleMessage"><code class="flex name class">
<span>class <span class="ident">ConsoleMessage</span></span>
<span>(</span><span>obj: playwright._impl._console_message.ConsoleMessage)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConsoleMessage(AsyncBase):
    def __init__(self, obj: ConsoleMessageImpl):
        super().__init__(obj)

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;ConsoleMessage.type

        One of the following values: `&#39;log&#39;`, `&#39;debug&#39;`, `&#39;info&#39;`, `&#39;error&#39;`, `&#39;warning&#39;`, `&#39;dir&#39;`, `&#39;dirxml&#39;`, `&#39;table&#39;`,
        `&#39;trace&#39;`, `&#39;clear&#39;`, `&#39;startGroup&#39;`, `&#39;startGroupCollapsed&#39;`, `&#39;endGroup&#39;`, `&#39;assert&#39;`, `&#39;profile&#39;`, `&#39;profileEnd&#39;`,
        `&#39;count&#39;`, `&#39;timeEnd&#39;`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.type)

    @property
    def text(self) -&gt; str:
        &#34;&#34;&#34;ConsoleMessage.text

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.text)

    @property
    def args(self) -&gt; typing.List[&#34;JSHandle&#34;]:
        &#34;&#34;&#34;ConsoleMessage.args

        Returns
        -------
        List[JSHandle]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.args)

    @property
    def location(self) -&gt; SourceLocation:
        &#34;&#34;&#34;ConsoleMessage.location

        Returns
        -------
        {url: str, lineNumber: int, columnNumber: int}
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.location)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.ConsoleMessage.args"><code class="name">var <span class="ident">args</span> : List[playwright.async_api._generated.JSHandle]</code></dt>
<dd>
<div class="desc"><p>ConsoleMessage.args</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def args(self) -&gt; typing.List[&#34;JSHandle&#34;]:
    &#34;&#34;&#34;ConsoleMessage.args

    Returns
    -------
    List[JSHandle]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.args)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ConsoleMessage.location"><code class="name">var <span class="ident">location</span> : playwright._impl._api_structures.SourceLocation</code></dt>
<dd>
<div class="desc"><p>ConsoleMessage.location</p>
<h2 id="returns">Returns</h2>
<p>{url: str, lineNumber: int, columnNumber: int}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def location(self) -&gt; SourceLocation:
    &#34;&#34;&#34;ConsoleMessage.location

    Returns
    -------
    {url: str, lineNumber: int, columnNumber: int}
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.location)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ConsoleMessage.text"><code class="name">var <span class="ident">text</span> : str</code></dt>
<dd>
<div class="desc"><p>ConsoleMessage.text</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text(self) -&gt; str:
    &#34;&#34;&#34;ConsoleMessage.text

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.text)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ConsoleMessage.type"><code class="name">var <span class="ident">type</span> : str</code></dt>
<dd>
<div class="desc"><p>ConsoleMessage.type</p>
<p>One of the following values: <code>'log'</code>, <code>'debug'</code>, <code>'info'</code>, <code>'error'</code>, <code>'warning'</code>, <code>'dir'</code>, <code>'dirxml'</code>, <code>'table'</code>,
<code>'trace'</code>, <code>'clear'</code>, <code>'startGroup'</code>, <code>'startGroupCollapsed'</code>, <code>'endGroup'</code>, <code>'assert'</code>, <code>'profile'</code>, <code>'profileEnd'</code>,
<code>'count'</code>, <code>'timeEnd'</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; str:
    &#34;&#34;&#34;ConsoleMessage.type

    One of the following values: `&#39;log&#39;`, `&#39;debug&#39;`, `&#39;info&#39;`, `&#39;error&#39;`, `&#39;warning&#39;`, `&#39;dir&#39;`, `&#39;dirxml&#39;`, `&#39;table&#39;`,
    `&#39;trace&#39;`, `&#39;clear&#39;`, `&#39;startGroup&#39;`, `&#39;startGroupCollapsed&#39;`, `&#39;endGroup&#39;`, `&#39;assert&#39;`, `&#39;profile&#39;`, `&#39;profileEnd&#39;`,
    `&#39;count&#39;`, `&#39;timeEnd&#39;`.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.type)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Cookie"><code class="flex name class">
<span>class <span class="ident">Cookie</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cookie(TypedDict, total=False):
    name: str
    value: str
    url: Optional[str]
    domain: Optional[str]
    path: Optional[str]
    expires: Optional[float]
    httpOnly: Optional[bool]
    secure: Optional[bool]
    sameSite: Optional[Literal[&#34;Lax&#34;, &#34;None&#34;, &#34;Strict&#34;]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.Cookie.domain"><code class="name">var <span class="ident">domain</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Cookie.expires"><code class="name">var <span class="ident">expires</span> : Union[float, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Cookie.httpOnly"><code class="name">var <span class="ident">httpOnly</span> : Union[bool, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Cookie.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Cookie.path"><code class="name">var <span class="ident">path</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Cookie.sameSite"><code class="name">var <span class="ident">sameSite</span> : Union[Literal['Lax', 'None', 'Strict'], NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Cookie.secure"><code class="name">var <span class="ident">secure</span> : Union[bool, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Cookie.url"><code class="name">var <span class="ident">url</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Cookie.value"><code class="name">var <span class="ident">value</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Dialog"><code class="flex name class">
<span>class <span class="ident">Dialog</span></span>
<span>(</span><span>obj: playwright._impl._dialog.Dialog)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dialog(AsyncBase):
    def __init__(self, obj: DialogImpl):
        super().__init__(obj)

    @property
    def type(self) -&gt; str:
        &#34;&#34;&#34;Dialog.type

        Returns dialog&#39;s type, can be one of `alert`, `beforeunload`, `confirm` or `prompt`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.type)

    @property
    def message(self) -&gt; str:
        &#34;&#34;&#34;Dialog.message

        A message displayed in the dialog.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.message)

    @property
    def default_value(self) -&gt; str:
        &#34;&#34;&#34;Dialog.default_value

        If dialog is prompt, returns default prompt value. Otherwise, returns empty string.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.default_value)

    async def accept(self, prompt_text: str = None) -&gt; NoneType:
        &#34;&#34;&#34;Dialog.accept

        Returns when the dialog has been accepted.

        Parameters
        ----------
        prompt_text : Union[str, NoneType]
            A text to enter in prompt. Does not cause any effects if the dialog&#39;s `type` is not prompt. Optional.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; dialog.accept started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.accept(promptText=prompt_text)
            )
            log_api(&#34;&lt;= dialog.accept succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= dialog.accept failed&#34;)
            raise e

    async def dismiss(self) -&gt; NoneType:
        &#34;&#34;&#34;Dialog.dismiss

        Returns when the dialog has been dismissed.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; dialog.dismiss started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.dismiss())
            log_api(&#34;&lt;= dialog.dismiss succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= dialog.dismiss failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Dialog.default_value"><code class="name">var <span class="ident">default_value</span> : str</code></dt>
<dd>
<div class="desc"><p>Dialog.default_value</p>
<p>If dialog is prompt, returns default prompt value. Otherwise, returns empty string.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default_value(self) -&gt; str:
    &#34;&#34;&#34;Dialog.default_value

    If dialog is prompt, returns default prompt value. Otherwise, returns empty string.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.default_value)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Dialog.message"><code class="name">var <span class="ident">message</span> : str</code></dt>
<dd>
<div class="desc"><p>Dialog.message</p>
<p>A message displayed in the dialog.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def message(self) -&gt; str:
    &#34;&#34;&#34;Dialog.message

    A message displayed in the dialog.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.message)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Dialog.type"><code class="name">var <span class="ident">type</span> : str</code></dt>
<dd>
<div class="desc"><p>Dialog.type</p>
<p>Returns dialog's type, can be one of <code>alert</code>, <code>beforeunload</code>, <code>confirm</code> or <code>prompt</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; str:
    &#34;&#34;&#34;Dialog.type

    Returns dialog&#39;s type, can be one of `alert`, `beforeunload`, `confirm` or `prompt`.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.type)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Dialog.accept"><code class="name flex">
<span>async def <span class="ident">accept</span></span>(<span>self, prompt_text: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Dialog.accept</p>
<p>Returns when the dialog has been accepted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>prompt_text</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>A text to enter in prompt. Does not cause any effects if the dialog's <code>type</code> is not prompt. Optional.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def accept(self, prompt_text: str = None) -&gt; NoneType:
    &#34;&#34;&#34;Dialog.accept

    Returns when the dialog has been accepted.

    Parameters
    ----------
    prompt_text : Union[str, NoneType]
        A text to enter in prompt. Does not cause any effects if the dialog&#39;s `type` is not prompt. Optional.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; dialog.accept started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.accept(promptText=prompt_text)
        )
        log_api(&#34;&lt;= dialog.accept succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= dialog.accept failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Dialog.dismiss"><code class="name flex">
<span>async def <span class="ident">dismiss</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Dialog.dismiss</p>
<p>Returns when the dialog has been dismissed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dismiss(self) -&gt; NoneType:
    &#34;&#34;&#34;Dialog.dismiss

    Returns when the dialog has been dismissed.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; dialog.dismiss started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.dismiss())
        log_api(&#34;&lt;= dialog.dismiss succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= dialog.dismiss failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Download"><code class="flex name class">
<span>class <span class="ident">Download</span></span>
<span>(</span><span>obj: playwright._impl._download.Download)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Download(AsyncBase):
    def __init__(self, obj: DownloadImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Download.url

        Returns downloaded url.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def suggested_filename(self) -&gt; str:
        &#34;&#34;&#34;Download.suggested_filename

        Returns suggested filename for this download. It is typically computed by the browser from the
        [`Content-Disposition`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) response header
        or the `download` attribute. See the spec on [whatwg](https://html.spec.whatwg.org/#downloading-resources). Different
        browsers can use different logic for computing it.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.suggested_filename)

    async def delete(self) -&gt; NoneType:
        &#34;&#34;&#34;Download.delete

        Deletes the downloaded file.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; download.delete started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.delete())
            log_api(&#34;&lt;= download.delete succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= download.delete failed&#34;)
            raise e

    async def failure(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Download.failure

        Returns download error if any.

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; download.failure started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.failure())
            log_api(&#34;&lt;= download.failure succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= download.failure failed&#34;)
            raise e

    async def path(self) -&gt; typing.Union[pathlib.Path, NoneType]:
        &#34;&#34;&#34;Download.path

        Returns path to the downloaded file in case of successful download.

        Returns
        -------
        Union[pathlib.Path, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; download.path started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.path())
            log_api(&#34;&lt;= download.path succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= download.path failed&#34;)
            raise e

    async def save_as(self, path: typing.Union[str, pathlib.Path]) -&gt; NoneType:
        &#34;&#34;&#34;Download.save_as

        Saves the download to a user-specified path.

        Parameters
        ----------
        path : Union[pathlib.Path, str]
            Path where the download should be saved.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; download.save_as started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.save_as(path=path))
            log_api(&#34;&lt;= download.save_as succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= download.save_as failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Download.suggested_filename"><code class="name">var <span class="ident">suggested_filename</span> : str</code></dt>
<dd>
<div class="desc"><p>Download.suggested_filename</p>
<p>Returns suggested filename for this download. It is typically computed by the browser from the
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition"><code>Content-Disposition</code></a> response header
or the <code>download</code> attribute. See the spec on <a href="https://html.spec.whatwg.org/#downloading-resources">whatwg</a>. Different
browsers can use different logic for computing it.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def suggested_filename(self) -&gt; str:
    &#34;&#34;&#34;Download.suggested_filename

    Returns suggested filename for this download. It is typically computed by the browser from the
    [`Content-Disposition`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) response header
    or the `download` attribute. See the spec on [whatwg](https://html.spec.whatwg.org/#downloading-resources). Different
    browsers can use different logic for computing it.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.suggested_filename)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Download.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Download.url</p>
<p>Returns downloaded url.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Download.url

    Returns downloaded url.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Download.delete"><code class="name flex">
<span>async def <span class="ident">delete</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Download.delete</p>
<p>Deletes the downloaded file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete(self) -&gt; NoneType:
    &#34;&#34;&#34;Download.delete

    Deletes the downloaded file.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; download.delete started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.delete())
        log_api(&#34;&lt;= download.delete succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= download.delete failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Download.failure"><code class="name flex">
<span>async def <span class="ident">failure</span></span>(<span>self) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Download.failure</p>
<p>Returns download error if any.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def failure(self) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Download.failure

    Returns download error if any.

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; download.failure started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.failure())
        log_api(&#34;&lt;= download.failure succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= download.failure failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Download.path"><code class="name flex">
<span>async def <span class="ident">path</span></span>(<span>self) ‑> Union[pathlib.Path, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Download.path</p>
<p>Returns path to the downloaded file in case of successful download.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[pathlib.Path, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def path(self) -&gt; typing.Union[pathlib.Path, NoneType]:
    &#34;&#34;&#34;Download.path

    Returns path to the downloaded file in case of successful download.

    Returns
    -------
    Union[pathlib.Path, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; download.path started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.path())
        log_api(&#34;&lt;= download.path succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= download.path failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Download.save_as"><code class="name flex">
<span>async def <span class="ident">save_as</span></span>(<span>self, path: Union[str, pathlib.Path]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Download.save_as</p>
<p>Saves the download to a user-specified path.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str]</code></dt>
<dd>Path where the download should be saved.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def save_as(self, path: typing.Union[str, pathlib.Path]) -&gt; NoneType:
    &#34;&#34;&#34;Download.save_as

    Saves the download to a user-specified path.

    Parameters
    ----------
    path : Union[pathlib.Path, str]
        Path where the download should be saved.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; download.save_as started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.save_as(path=path))
        log_api(&#34;&lt;= download.save_as succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= download.save_as failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.ElementHandle"><code class="flex name class">
<span>class <span class="ident">ElementHandle</span></span>
<span>(</span><span>obj: playwright._impl._element_handle.ElementHandle)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ElementHandle(JSHandle):
    def __init__(self, obj: ElementHandleImpl):
        super().__init__(obj)

    def as_element(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.as_element

        Returns either `null` or the object handle itself, if the object handle is an instance of `ElementHandle`.

        Returns
        -------
        Union[ElementHandle, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.as_element started&#34;)
            result = mapping.from_impl_nullable(self._impl_obj.as_element())
            log_api(&#34;&lt;= element_handle.as_element succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.as_element failed&#34;)
            raise e

    async def owner_frame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.owner_frame

        Returns the frame containing the given element.

        Returns
        -------
        Union[Frame, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.owner_frame started&#34;)
            result = mapping.from_impl_nullable(await self._impl_obj.owner_frame())
            log_api(&#34;&lt;= element_handle.owner_frame succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.owner_frame failed&#34;)
            raise e

    async def content_frame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.content_frame

        Returns the content frame for element handles referencing iframe nodes, or `null` otherwise

        Returns
        -------
        Union[Frame, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.content_frame started&#34;)
            result = mapping.from_impl_nullable(await self._impl_obj.content_frame())
            log_api(&#34;&lt;= element_handle.content_frame succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.content_frame failed&#34;)
            raise e

    async def get_attribute(self, name: str) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;ElementHandle.get_attribute

        Returns element attribute value.

        Parameters
        ----------
        name : str
            Attribute name to get the value for.

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.get_attribute started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.get_attribute(name=name)
            )
            log_api(&#34;&lt;= element_handle.get_attribute succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.get_attribute failed&#34;)
            raise e

    async def text_content(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;ElementHandle.text_content

        Returns the `node.textContent`.

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.text_content started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.text_content())
            log_api(&#34;&lt;= element_handle.text_content succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.text_content failed&#34;)
            raise e

    async def inner_text(self) -&gt; str:
        &#34;&#34;&#34;ElementHandle.inner_text

        Returns the `element.innerText`.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.inner_text started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.inner_text())
            log_api(&#34;&lt;= element_handle.inner_text succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.inner_text failed&#34;)
            raise e

    async def inner_html(self) -&gt; str:
        &#34;&#34;&#34;ElementHandle.inner_html

        Returns the `element.innerHTML`.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.inner_html started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.inner_html())
            log_api(&#34;&lt;= element_handle.inner_html succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.inner_html failed&#34;)
            raise e

    async def is_checked(self) -&gt; bool:
        &#34;&#34;&#34;ElementHandle.is_checked

        Returns whether the element is checked. Throws if the element is not a checkbox or radio input.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.is_checked started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.is_checked())
            log_api(&#34;&lt;= element_handle.is_checked succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.is_checked failed&#34;)
            raise e

    async def is_disabled(self) -&gt; bool:
        &#34;&#34;&#34;ElementHandle.is_disabled

        Returns whether the element is disabled, the opposite of [enabled](./actionability.md#enabled).

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.is_disabled started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.is_disabled())
            log_api(&#34;&lt;= element_handle.is_disabled succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.is_disabled failed&#34;)
            raise e

    async def is_editable(self) -&gt; bool:
        &#34;&#34;&#34;ElementHandle.is_editable

        Returns whether the element is [editable](./actionability.md#editable).

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.is_editable started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.is_editable())
            log_api(&#34;&lt;= element_handle.is_editable succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.is_editable failed&#34;)
            raise e

    async def is_enabled(self) -&gt; bool:
        &#34;&#34;&#34;ElementHandle.is_enabled

        Returns whether the element is [enabled](./actionability.md#enabled).

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.is_enabled started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.is_enabled())
            log_api(&#34;&lt;= element_handle.is_enabled succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.is_enabled failed&#34;)
            raise e

    async def is_hidden(self) -&gt; bool:
        &#34;&#34;&#34;ElementHandle.is_hidden

        Returns whether the element is hidden, the opposite of [visible](./actionability.md#visible).

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.is_hidden started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.is_hidden())
            log_api(&#34;&lt;= element_handle.is_hidden succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.is_hidden failed&#34;)
            raise e

    async def is_visible(self) -&gt; bool:
        &#34;&#34;&#34;ElementHandle.is_visible

        Returns whether the element is [visible](./actionability.md#visible).

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.is_visible started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.is_visible())
            log_api(&#34;&lt;= element_handle.is_visible succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.is_visible failed&#34;)
            raise e

    async def dispatch_event(
        self, type: str, event_init: typing.Dict = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.dispatch_event

        The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click`
        is dispatched. This is equivalend to calling
        [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

        ```py
        await element_handle.dispatch_event(\&#34;click\&#34;)
        ```

        Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties
        and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.

        Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:
        - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
        - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
        - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
        - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
        - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
        - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
        - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)

        You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

        ```py
        # note you can only create data_transfer in chromium and firefox
        data_transfer = await page.evaluate_handle(\&#34;new DataTransfer()\&#34;)
        await element_handle.dispatch_event(\&#34;#source\&#34;, \&#34;dragstart\&#34;, {\&#34;dataTransfer\&#34;: data_transfer})
        ```

        Parameters
        ----------
        type : str
            DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
        event_init : Union[Dict, NoneType]
            Optional event-specific initialization properties.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.dispatch_event started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.dispatch_event(
                    type=type, eventInit=mapping.to_impl(event_init)
                )
            )
            log_api(&#34;&lt;= element_handle.dispatch_event succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.dispatch_event failed&#34;)
            raise e

    async def scroll_into_view_if_needed(self, timeout: float = None) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.scroll_into_view_if_needed

        This method waits for [actionability](./actionability.md) checks, then tries to scroll element into view, unless it is
        completely visible as defined by
        [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)&#39;s `ratio`.

        Throws when `elementHandle` does not point to an element
        [connected](https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected) to a Document or a ShadowRoot.

        Parameters
        ----------
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.scroll_into_view_if_needed started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.scroll_into_view_if_needed(timeout=timeout)
            )
            log_api(&#34;&lt;= element_handle.scroll_into_view_if_needed succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.scroll_into_view_if_needed failed&#34;)
            raise e

    async def hover(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        timeout: float = None,
        force: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.hover

        This method hovers over the element by performing the following steps:
        1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to hover over the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        If the element is detached from the DOM at any moment during the action, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Parameters
        ----------
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.hover started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.hover(
                    modifiers=modifiers, position=position, timeout=timeout, force=force
                )
            )
            log_api(&#34;&lt;= element_handle.hover succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.hover failed&#34;)
            raise e

    async def click(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        delay: float = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        click_count: int = None,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.click

        This method clicks the element by performing the following steps:
        1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to click in the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        If the element is detached from the DOM at any moment during the action, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Parameters
        ----------
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        delay : Union[float, NoneType]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        click_count : Union[int, NoneType]
            defaults to 1. See [UIEvent.detail].
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.click started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.click(
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    clickCount=click_count,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= element_handle.click succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.click failed&#34;)
            raise e

    async def dblclick(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        delay: float = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.dblclick

        This method double clicks the element by performing the following steps:
        1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to double click in the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the
           first click of the `dblclick()` triggers a navigation event, this method will reject.

        If the element is detached from the DOM at any moment during the action, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        &gt; NOTE: `elementHandle.dblclick()` dispatches two `click` events and a single `dblclick` event.

        Parameters
        ----------
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        delay : Union[float, NoneType]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.dblclick started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.dblclick(
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= element_handle.dblclick succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.dblclick failed&#34;)
            raise e

    async def select_option(
        self,
        value: typing.Union[str, typing.List[str]] = None,
        index: typing.Union[int, typing.List[int]] = None,
        label: typing.Union[str, typing.List[str]] = None,
        element: typing.Union[&#34;ElementHandle&#34;, typing.List[&#34;ElementHandle&#34;]] = None,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; typing.List[str]:
        &#34;&#34;&#34;ElementHandle.select_option

        Returns the array of option values that have been successfully selected.

        Triggers a `change` and `input` event once all the provided options have been selected. If element is not a `&lt;select&gt;`
        element, the method throws an error.

        ```py
        # single selection matching the value
        await handle.select_option(\&#34;select#colors\&#34;, \&#34;blue\&#34;)
        # single selection matching the label
        await handle.select_option(\&#34;select#colors\&#34;, label=\&#34;blue\&#34;)
        # multiple selection
        await handle.select_option(\&#34;select#colors\&#34;, value=[\&#34;red\&#34;, \&#34;green\&#34;, \&#34;blue\&#34;])
        ```

        Parameters
        ----------
        value : Union[List[str], str, NoneType]
            Options to select by value. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
            only the first option matching one of the passed options is selected. Optional.
        index : Union[List[int], int, NoneType]
            Options to select by index. Optional.
        label : Union[List[str], str, NoneType]
            Options to select by label. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
            only the first option matching one of the passed options is selected. Optional.
        element : Union[ElementHandle, List[ElementHandle], NoneType]
            Option elements to select. Optional.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.

        Returns
        -------
        List[str]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.select_option started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.select_option(
                    value=value,
                    index=index,
                    label=label,
                    element=mapping.to_impl(element),
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= element_handle.select_option succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.select_option failed&#34;)
            raise e

    async def tap(
        self,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.tap

        This method taps the element by performing the following steps:
        1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
        1. Scroll the element into view if needed.
        1. Use `page.touchscreen` to tap the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        If the element is detached from the DOM at any moment during the action, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        &gt; NOTE: `elementHandle.tap()` requires that the `hasTouch` option of the browser context be set to true.

        Parameters
        ----------
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.tap started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.tap(
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= element_handle.tap succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.tap failed&#34;)
            raise e

    async def fill(
        self, value: str, timeout: float = None, no_wait_after: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.fill

        This method waits for [actionability](./actionability.md) checks, focuses the element, fills it and triggers an `input`
        event after filling. If the element is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws
        an error. Note that you can pass an empty string to clear the input field.

        Parameters
        ----------
        value : str
            Value to set for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.fill started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.fill(
                    value=value, timeout=timeout, noWaitAfter=no_wait_after
                )
            )
            log_api(&#34;&lt;= element_handle.fill succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.fill failed&#34;)
            raise e

    async def select_text(self, timeout: float = None) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.select_text

        This method waits for [actionability](./actionability.md) checks, then focuses the element and selects all its text
        content.

        Parameters
        ----------
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.select_text started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.select_text(timeout=timeout)
            )
            log_api(&#34;&lt;= element_handle.select_text succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.select_text failed&#34;)
            raise e

    async def set_input_files(
        self,
        files: typing.Union[
            str,
            pathlib.Path,
            FilePayload,
            typing.List[typing.Union[str, pathlib.Path]],
            typing.List[FilePayload],
        ],
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.set_input_files

        This method expects `elementHandle` to point to an
        [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).

        Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
        are resolved relative to the the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        files : Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.set_input_files started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_input_files(
                    files=files, timeout=timeout, noWaitAfter=no_wait_after
                )
            )
            log_api(&#34;&lt;= element_handle.set_input_files succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.set_input_files failed&#34;)
            raise e

    async def focus(self) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.focus

        Calls [focus](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) on the element.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.focus started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.focus())
            log_api(&#34;&lt;= element_handle.focus succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.focus failed&#34;)
            raise e

    async def type(
        self,
        text: str,
        delay: float = None,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.type

        Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.

        To press a special key, like `Control` or `ArrowDown`, use `element_handle.press()`.

        ```py
        await element_handle.type(\&#34;hello\&#34;) # types instantly
        await element_handle.type(\&#34;world\&#34;, delay=100) # types slower, like a user
        ```

        An example of typing into a text field and then submitting the form:

        ```py
        element_handle = await page.query_selector(\&#34;input\&#34;)
        await element_handle.type(\&#34;some text\&#34;)
        await element_handle.press(\&#34;Enter\&#34;)
        ```

        Parameters
        ----------
        text : str
            A text to type into a focused element.
        delay : Union[float, NoneType]
            Time to wait between key presses in milliseconds. Defaults to 0.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.type started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.type(
                    text=text, delay=delay, timeout=timeout, noWaitAfter=no_wait_after
                )
            )
            log_api(&#34;&lt;= element_handle.type succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.type failed&#34;)
            raise e

    async def press(
        self,
        key: str,
        delay: float = None,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.press

        Focuses the element, and then uses `keyboard.down()` and `keyboard.up()`.

        `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
        value or a single character to generate the text for. A superset of the `key` values can be found
        [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
        `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

        Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
        texts.

        Shortcuts such as `key: \&#34;Control+o\&#34;` or `key: \&#34;Control+Shift+T\&#34;` are supported as well. When speficied with the
        modifier, modifier is pressed and being held while the subsequent key is being pressed.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Union[float, NoneType]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.press started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.press(
                    key=key, delay=delay, timeout=timeout, noWaitAfter=no_wait_after
                )
            )
            log_api(&#34;&lt;= element_handle.press succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.press failed&#34;)
            raise e

    async def check(
        self, timeout: float = None, force: bool = None, no_wait_after: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.check

        This method checks the element by performing the following steps:
        1. Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already
           checked, this method returns immediately.
        1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to click in the center of the element.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        1. Ensure that the element is now checked. If not, this method rejects.

        If the element is detached from the DOM at any moment during the action, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Parameters
        ----------
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.check started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.check(
                    timeout=timeout, force=force, noWaitAfter=no_wait_after
                )
            )
            log_api(&#34;&lt;= element_handle.check succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.check failed&#34;)
            raise e

    async def uncheck(
        self, timeout: float = None, force: bool = None, no_wait_after: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.uncheck

        This method checks the element by performing the following steps:
        1. Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already
           unchecked, this method returns immediately.
        1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to click in the center of the element.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        1. Ensure that the element is now unchecked. If not, this method rejects.

        If the element is detached from the DOM at any moment during the action, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Parameters
        ----------
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.uncheck started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.uncheck(
                    timeout=timeout, force=force, noWaitAfter=no_wait_after
                )
            )
            log_api(&#34;&lt;= element_handle.uncheck succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.uncheck failed&#34;)
            raise e

    async def bounding_box(self) -&gt; typing.Union[FloatRect, NoneType]:
        &#34;&#34;&#34;ElementHandle.bounding_box

        This method returns the bounding box of the element, or `null` if the element is not visible. The bounding box is
        calculated relative to the main frame viewport - which is usually the same as the browser window.

        Scrolling affects the returned bonding box, similarly to
        [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect). That
        means `x` and/or `y` may be negative.

        Elements from child frames return the bounding box relative to the main frame, unlike the
        [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).

        Assuming the page is static, it is safe to use bounding box coordinates to perform input. For example, the following
        snippet should click the center of the element.

        ```py
        box = await element_handle.bounding_box()
        await page.mouse.click(box[\&#34;x\&#34;] + box[\&#34;width\&#34;] / 2, box[\&#34;y\&#34;] + box[\&#34;height\&#34;] / 2)
        ```

        Returns
        -------
        Union[{x: float, y: float, width: float, height: float}, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.bounding_box started&#34;)
            result = mapping.from_impl_nullable(await self._impl_obj.bounding_box())
            log_api(&#34;&lt;= element_handle.bounding_box succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.bounding_box failed&#34;)
            raise e

    async def screenshot(
        self,
        timeout: float = None,
        type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
        path: typing.Union[str, pathlib.Path] = None,
        quality: int = None,
        omit_background: bool = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;ElementHandle.screenshot

        Returns the buffer with the captured screenshot.

        This method waits for the [actionability](./actionability.md) checks, then scrolls element into view before taking a
        screenshot. If the element is detached from DOM, the method throws an error.

        Parameters
        ----------
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        type : Union[&#34;jpeg&#34;, &#34;png&#34;, NoneType]
            Specify screenshot type, defaults to `png`.
        path : Union[pathlib.Path, str, NoneType]
            The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative
            path, then it is resolved relative to the current working directory. If no path is provided, the image won&#39;t be saved to
            the disk.
        quality : Union[int, NoneType]
            The quality of the image, between 0-100. Not applicable to `png` images.
        omit_background : Union[bool, NoneType]
            Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images.
            Defaults to `false`.

        Returns
        -------
        bytes
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.screenshot started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.screenshot(
                    timeout=timeout,
                    type=type,
                    path=path,
                    quality=quality,
                    omitBackground=omit_background,
                )
            )
            log_api(&#34;&lt;= element_handle.screenshot succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.screenshot failed&#34;)
            raise e

    async def query_selector(
        self, selector: str
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.query_selector

        The method finds an element matching the specified selector in the `ElementHandle`&#39;s subtree. See
        [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements match the selector,
        returns `null`.

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

        Returns
        -------
        Union[ElementHandle, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.query_selector started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.query_selector(selector=selector)
            )
            log_api(&#34;&lt;= element_handle.query_selector succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.query_selector failed&#34;)
            raise e

    async def query_selector_all(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
        &#34;&#34;&#34;ElementHandle.query_selector_all

        The method finds all elements matching the specified selector in the `ElementHandle`s subtree. See
        [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements match the selector,
        returns empty array.

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

        Returns
        -------
        List[ElementHandle]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.query_selector_all started&#34;)
            result = mapping.from_impl_list(
                await self._impl_obj.query_selector_all(selector=selector)
            )
            log_api(&#34;&lt;= element_handle.query_selector_all succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.query_selector_all failed&#34;)
            raise e

    async def eval_on_selector(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;ElementHandle.eval_on_selector

        Returns the return value of `pageFunction`

        The method finds an element matching the specified selector in the `ElementHandle`s subtree and passes it as a first
        argument to `pageFunction`. See [Working with selectors](./selectors.md#working-with-selectors) for more details. If no
        elements match the selector, the method throws an error.

        If `pageFunction` returns a [Promise], then `frame.$eval` would wait for the promise to resolve and return its value.

        Examples:

        ```py
        tweet_handle = await page.query_selector(\&#34;.tweet\&#34;)
        assert await tweet_handle.eval_on_selector(\&#34;.like\&#34;, \&#34;node =&gt; node.innerText\&#34;) == \&#34;100\&#34;
        assert await tweet_handle.eval_on_selector(\&#34;.retweets\&#34;, \&#34;node =&gt; node.innerText\&#34;) = \&#34;10\&#34;
        ```

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.eval_on_selector started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.eval_on_selector(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= element_handle.eval_on_selector succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.eval_on_selector failed&#34;)
            raise e

    async def eval_on_selector_all(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;ElementHandle.eval_on_selector_all

        Returns the return value of `pageFunction`

        The method finds all elements matching the specified selector in the `ElementHandle`&#39;s subtree and passes an array of
        matched elements as a first argument to `pageFunction`. See
        [Working with selectors](./selectors.md#working-with-selectors) for more details.

        If `pageFunction` returns a [Promise], then `frame.$$eval` would wait for the promise to resolve and return its value.

        Examples:

        ```html
        &lt;div class=\&#34;feed\&#34;&gt;
          &lt;div class=\&#34;tweet\&#34;&gt;Hello!&lt;/div&gt;
          &lt;div class=\&#34;tweet\&#34;&gt;Hi!&lt;/div&gt;
        &lt;/div&gt;
        ```

        ```py
        # FIXME
        feed_handle = await page.query_selector(\&#34;.feed\&#34;)
        assert await feed_handle.eval_on_selector_all(\&#34;.tweet\&#34;, \&#34;nodes =&gt; nodes.map(n =&gt; n.innerText)\&#34;) == [\&#34;hello!\&#34;, \&#34;hi!\&#34;]
        ```

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.eval_on_selector_all started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.eval_on_selector_all(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= element_handle.eval_on_selector_all succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.eval_on_selector_all failed&#34;)
            raise e

    async def wait_for_element_state(
        self,
        state: Literal[
            &#34;disabled&#34;, &#34;editable&#34;, &#34;enabled&#34;, &#34;hidden&#34;, &#34;stable&#34;, &#34;visible&#34;
        ],
        timeout: float = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;ElementHandle.wait_for_element_state

        Returns when the element satisfies the `state`.

        Depending on the `state` parameter, this method waits for one of the [actionability](./actionability.md) checks to pass.
        This method throws when the element is detached while waiting, unless waiting for the `\&#34;hidden\&#34;` state.
        - `\&#34;visible\&#34;` Wait until the element is [visible](./actionability.md#visible).
        - `\&#34;hidden\&#34;` Wait until the element is [not visible](./actionability.md#visible) or
          [not attached](./actionability.md#attached). Note that waiting for hidden does not throw when the element detaches.
        - `\&#34;stable\&#34;` Wait until the element is both [visible](./actionability.md#visible) and
          [stable](./actionability.md#stable).
        - `\&#34;enabled\&#34;` Wait until the element is [enabled](./actionability.md#enabled).
        - `\&#34;disabled\&#34;` Wait until the element is [not enabled](./actionability.md#enabled).
        - `\&#34;editable\&#34;` Wait until the element is [editable](./actionability.md#editable).

        If the element does not satisfy the condition for the `timeout` milliseconds, this method will throw.

        Parameters
        ----------
        state : Union[&#34;disabled&#34;, &#34;editable&#34;, &#34;enabled&#34;, &#34;hidden&#34;, &#34;stable&#34;, &#34;visible&#34;]
            A state to wait for, see below for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.wait_for_element_state started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.wait_for_element_state(
                    state=state, timeout=timeout
                )
            )
            log_api(&#34;&lt;= element_handle.wait_for_element_state succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.wait_for_element_state failed&#34;)
            raise e

    async def wait_for_selector(
        self,
        selector: str,
        state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
        timeout: float = None,
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;ElementHandle.wait_for_selector

        Returns element specified by selector when it satisfies `state` option. Returns `null` if waiting for `hidden` or
        `detached`.

        Wait for the `selector` relative to the element handle to satisfy `state` option (either appear/disappear from dom, or
        become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method
        will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will
        throw.

        ```py
        await page.set_content(\&#34;&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;\&#34;)
        div = await page.query_selector(\&#34;div\&#34;)
        # waiting for the \&#34;span\&#34; selector relative to the div.
        span = await div.wait_for_selector(\&#34;span\&#34;, state=\&#34;attached\&#34;)
        ```

        &gt; NOTE: This method does not work across navigations, use `page.wait_for_selector()` instead.

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        state : Union[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;, NoneType]
            Defaults to `&#39;visible&#39;`. Can be either:
            - `&#39;attached&#39;` - wait for element to be present in DOM.
            - `&#39;detached&#39;` - wait for element to not be present in DOM.
            - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without
              any content or with `display:none` has an empty bounding box and is not considered visible.
            - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`.
              This is opposite to the `&#39;visible&#39;` option.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        Union[ElementHandle, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; element_handle.wait_for_selector started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.wait_for_selector(
                    selector=selector, state=state, timeout=timeout
                )
            )
            log_api(&#34;&lt;= element_handle.wait_for_selector succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= element_handle.wait_for_selector failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright.async_api._generated.JSHandle</li>
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.ElementHandle.as_element"><code class="name flex">
<span>def <span class="ident">as_element</span></span>(<span>self) ‑> Union[playwright.async_api._generated.ElementHandle, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.as_element</p>
<p>Returns either <code>null</code> or the object handle itself, if the object handle is an instance of <code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_element(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.as_element

    Returns either `null` or the object handle itself, if the object handle is an instance of `ElementHandle`.

    Returns
    -------
    Union[ElementHandle, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.as_element started&#34;)
        result = mapping.from_impl_nullable(self._impl_obj.as_element())
        log_api(&#34;&lt;= element_handle.as_element succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.as_element failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.bounding_box"><code class="name flex">
<span>async def <span class="ident">bounding_box</span></span>(<span>self) ‑> Union[playwright._impl._api_structures.FloatRect, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.bounding_box</p>
<p>This method returns the bounding box of the element, or <code>null</code> if the element is not visible. The bounding box is
calculated relative to the main frame viewport - which is usually the same as the browser window.</p>
<p>Scrolling affects the returned bonding box, similarly to
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect">Element.getBoundingClientRect</a>. That
means <code>x</code> and/or <code>y</code> may be negative.</p>
<p>Elements from child frames return the bounding box relative to the main frame, unlike the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect">Element.getBoundingClientRect</a>.</p>
<p>Assuming the page is static, it is safe to use bounding box coordinates to perform input. For example, the following
snippet should click the center of the element.</p>
<pre><code class="language-py">box = await element_handle.bounding_box()
await page.mouse.click(box[&quot;x&quot;] + box[&quot;width&quot;] / 2, box[&quot;y&quot;] + box[&quot;height&quot;] / 2)
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[{x: float, y: float, width: float, height: float}, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def bounding_box(self) -&gt; typing.Union[FloatRect, NoneType]:
    &#34;&#34;&#34;ElementHandle.bounding_box

    This method returns the bounding box of the element, or `null` if the element is not visible. The bounding box is
    calculated relative to the main frame viewport - which is usually the same as the browser window.

    Scrolling affects the returned bonding box, similarly to
    [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect). That
    means `x` and/or `y` may be negative.

    Elements from child frames return the bounding box relative to the main frame, unlike the
    [Element.getBoundingClientRect](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).

    Assuming the page is static, it is safe to use bounding box coordinates to perform input. For example, the following
    snippet should click the center of the element.

    ```py
    box = await element_handle.bounding_box()
    await page.mouse.click(box[\&#34;x\&#34;] + box[\&#34;width\&#34;] / 2, box[\&#34;y\&#34;] + box[\&#34;height\&#34;] / 2)
    ```

    Returns
    -------
    Union[{x: float, y: float, width: float, height: float}, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.bounding_box started&#34;)
        result = mapping.from_impl_nullable(await self._impl_obj.bounding_box())
        log_api(&#34;&lt;= element_handle.bounding_box succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.bounding_box failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.check"><code class="name flex">
<span>async def <span class="ident">check</span></span>(<span>self, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.check</p>
<p>This method checks the element by performing the following steps:
1. Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already
checked, this method returns immediately.
1. Wait for <a href="./actionability.md">actionability</a> checks on the element, unless <code>force</code> option is set.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to click in the center of the element.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
1. Ensure that the element is now checked. If not, this method rejects.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check(
    self, timeout: float = None, force: bool = None, no_wait_after: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.check

    This method checks the element by performing the following steps:
    1. Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already
       checked, this method returns immediately.
    1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to click in the center of the element.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    1. Ensure that the element is now checked. If not, this method rejects.

    If the element is detached from the DOM at any moment during the action, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Parameters
    ----------
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.check started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.check(
                timeout=timeout, force=force, noWaitAfter=no_wait_after
            )
        )
        log_api(&#34;&lt;= element_handle.check succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.check failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.click"><code class="name flex">
<span>async def <span class="ident">click</span></span>(<span>self, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, delay: float = None, button: Literal['left', 'middle', 'right'] = None, click_count: int = None, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.click</p>
<p>This method clicks the element by performing the following steps:
1. Wait for <a href="./actionability.md">actionability</a> checks on the element, unless <code>force</code> option is set.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to click in the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>click_count</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>defaults to 1. See [UIEvent.detail].</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def click(
    self,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    delay: float = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    click_count: int = None,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.click

    This method clicks the element by performing the following steps:
    1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to click in the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    If the element is detached from the DOM at any moment during the action, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Parameters
    ----------
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    delay : Union[float, NoneType]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    click_count : Union[int, NoneType]
        defaults to 1. See [UIEvent.detail].
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.click started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.click(
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                clickCount=click_count,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= element_handle.click succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.click failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.content_frame"><code class="name flex">
<span>async def <span class="ident">content_frame</span></span>(<span>self) ‑> Union[playwright.async_api._generated.Frame, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.content_frame</p>
<p>Returns the content frame for element handles referencing iframe nodes, or <code>null</code> otherwise</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def content_frame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.content_frame

    Returns the content frame for element handles referencing iframe nodes, or `null` otherwise

    Returns
    -------
    Union[Frame, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.content_frame started&#34;)
        result = mapping.from_impl_nullable(await self._impl_obj.content_frame())
        log_api(&#34;&lt;= element_handle.content_frame succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.content_frame failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.dblclick"><code class="name flex">
<span>async def <span class="ident">dblclick</span></span>(<span>self, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, delay: float = None, button: Literal['left', 'middle', 'right'] = None, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.dblclick</p>
<p>This method double clicks the element by performing the following steps:
1. Wait for <a href="./actionability.md">actionability</a> checks on the element, unless <code>force</code> option is set.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to double click in the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set. Note that if the
first click of the <code>dblclick()</code> triggers a navigation event, this method will reject.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<blockquote>
<p>NOTE: <code>elementHandle.dblclick()</code> dispatches two <code>click</code> events and a single <code>dblclick</code> event.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dblclick(
    self,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    delay: float = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.dblclick

    This method double clicks the element by performing the following steps:
    1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to double click in the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the
       first click of the `dblclick()` triggers a navigation event, this method will reject.

    If the element is detached from the DOM at any moment during the action, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    &gt; NOTE: `elementHandle.dblclick()` dispatches two `click` events and a single `dblclick` event.

    Parameters
    ----------
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    delay : Union[float, NoneType]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.dblclick started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.dblclick(
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= element_handle.dblclick succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.dblclick failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.dispatch_event"><code class="name flex">
<span>async def <span class="ident">dispatch_event</span></span>(<span>self, type: str, event_init: Dict = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.dispatch_event</p>
<p>The snippet below dispatches the <code>click</code> event on the element. Regardless of the visibility state of the elment, <code>click</code>
is dispatched. This is equivalend to calling
<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click">element.click()</a>.</p>
<pre><code class="language-py">await element_handle.dispatch_event(&quot;click&quot;)
</code></pre>
<p>Under the hood, it creates an instance of an event based on the given <code>type</code>, initializes it with <code>eventInit</code> properties
and dispatches it on the element. Events are <code>composed</code>, <code>cancelable</code> and bubble by default.</p>
<p>Since <code>eventInit</code> is event-specific, please refer to the events documentation for the lists of initial properties:
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent">DragEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent">FocusEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent">KeyboardEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent">MouseEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent">PointerEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent">TouchEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event">Event</a></p>
<p>You can also specify <code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code> as the property value if you want live objects to be passed into the event:</p>
<pre><code class="language-py"># note you can only create data_transfer in chromium and firefox
data_transfer = await page.evaluate_handle(&quot;new DataTransfer()&quot;)
await element_handle.dispatch_event(&quot;#source&quot;, &quot;dragstart&quot;, {&quot;dataTransfer&quot;: data_transfer})
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>DOM event type: <code>"click"</code>, <code>"dragstart"</code>, etc.</dd>
<dt><strong><code>event_init</code></strong> :&ensp;<code>Union[Dict, NoneType]</code></dt>
<dd>Optional event-specific initialization properties.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dispatch_event(
    self, type: str, event_init: typing.Dict = None
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.dispatch_event

    The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click`
    is dispatched. This is equivalend to calling
    [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

    ```py
    await element_handle.dispatch_event(\&#34;click\&#34;)
    ```

    Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties
    and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.

    Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:
    - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
    - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
    - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
    - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
    - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
    - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
    - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)

    You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

    ```py
    # note you can only create data_transfer in chromium and firefox
    data_transfer = await page.evaluate_handle(\&#34;new DataTransfer()\&#34;)
    await element_handle.dispatch_event(\&#34;#source\&#34;, \&#34;dragstart\&#34;, {\&#34;dataTransfer\&#34;: data_transfer})
    ```

    Parameters
    ----------
    type : str
        DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
    event_init : Union[Dict, NoneType]
        Optional event-specific initialization properties.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.dispatch_event started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.dispatch_event(
                type=type, eventInit=mapping.to_impl(event_init)
            )
        )
        log_api(&#34;&lt;= element_handle.dispatch_event succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.dispatch_event failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.eval_on_selector"><code class="name flex">
<span>async def <span class="ident">eval_on_selector</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.eval_on_selector</p>
<p>Returns the return value of <code>pageFunction</code></p>
<p>The method finds an element matching the specified selector in the <code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code>s subtree and passes it as a first
argument to <code>pageFunction</code>. See <a href="./selectors.md#working-with-selectors">Working with selectors</a> for more details. If no
elements match the selector, the method throws an error.</p>
<p>If <code>pageFunction</code> returns a [Promise], then <code>frame.$eval</code> would wait for the promise to resolve and return its value.</p>
<p>Examples:</p>
<pre><code class="language-py">tweet_handle = await page.query_selector(&quot;.tweet&quot;)
assert await tweet_handle.eval_on_selector(&quot;.like&quot;, &quot;node =&gt; node.innerText&quot;) == &quot;100&quot;
assert await tweet_handle.eval_on_selector(&quot;.retweets&quot;, &quot;node =&gt; node.innerText&quot;) = &quot;10&quot;
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def eval_on_selector(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;ElementHandle.eval_on_selector

    Returns the return value of `pageFunction`

    The method finds an element matching the specified selector in the `ElementHandle`s subtree and passes it as a first
    argument to `pageFunction`. See [Working with selectors](./selectors.md#working-with-selectors) for more details. If no
    elements match the selector, the method throws an error.

    If `pageFunction` returns a [Promise], then `frame.$eval` would wait for the promise to resolve and return its value.

    Examples:

    ```py
    tweet_handle = await page.query_selector(\&#34;.tweet\&#34;)
    assert await tweet_handle.eval_on_selector(\&#34;.like\&#34;, \&#34;node =&gt; node.innerText\&#34;) == \&#34;100\&#34;
    assert await tweet_handle.eval_on_selector(\&#34;.retweets\&#34;, \&#34;node =&gt; node.innerText\&#34;) = \&#34;10\&#34;
    ```

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.eval_on_selector started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.eval_on_selector(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= element_handle.eval_on_selector succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.eval_on_selector failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.eval_on_selector_all"><code class="name flex">
<span>async def <span class="ident">eval_on_selector_all</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.eval_on_selector_all</p>
<p>Returns the return value of <code>pageFunction</code></p>
<p>The method finds all elements matching the specified selector in the <code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code>'s subtree and passes an array of
matched elements as a first argument to <code>pageFunction</code>. See
<a href="./selectors.md#working-with-selectors">Working with selectors</a> for more details.</p>
<p>If <code>pageFunction</code> returns a [Promise], then <code>frame.$$eval</code> would wait for the promise to resolve and return its value.</p>
<p>Examples:</p>
<pre><code class="language-html">&lt;div class=&quot;feed&quot;&gt;
  &lt;div class=&quot;tweet&quot;&gt;Hello!&lt;/div&gt;
  &lt;div class=&quot;tweet&quot;&gt;Hi!&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-py"># FIXME
feed_handle = await page.query_selector(&quot;.feed&quot;)
assert await feed_handle.eval_on_selector_all(&quot;.tweet&quot;, &quot;nodes =&gt; nodes.map(n =&gt; n.innerText)&quot;) == [&quot;hello!&quot;, &quot;hi!&quot;]
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def eval_on_selector_all(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;ElementHandle.eval_on_selector_all

    Returns the return value of `pageFunction`

    The method finds all elements matching the specified selector in the `ElementHandle`&#39;s subtree and passes an array of
    matched elements as a first argument to `pageFunction`. See
    [Working with selectors](./selectors.md#working-with-selectors) for more details.

    If `pageFunction` returns a [Promise], then `frame.$$eval` would wait for the promise to resolve and return its value.

    Examples:

    ```html
    &lt;div class=\&#34;feed\&#34;&gt;
      &lt;div class=\&#34;tweet\&#34;&gt;Hello!&lt;/div&gt;
      &lt;div class=\&#34;tweet\&#34;&gt;Hi!&lt;/div&gt;
    &lt;/div&gt;
    ```

    ```py
    # FIXME
    feed_handle = await page.query_selector(\&#34;.feed\&#34;)
    assert await feed_handle.eval_on_selector_all(\&#34;.tweet\&#34;, \&#34;nodes =&gt; nodes.map(n =&gt; n.innerText)\&#34;) == [\&#34;hello!\&#34;, \&#34;hi!\&#34;]
    ```

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.eval_on_selector_all started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.eval_on_selector_all(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= element_handle.eval_on_selector_all succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.eval_on_selector_all failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.fill"><code class="name flex">
<span>async def <span class="ident">fill</span></span>(<span>self, value: str, timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.fill</p>
<p>This method waits for <a href="./actionability.md">actionability</a> checks, focuses the element, fills it and triggers an <code>input</code>
event after filling. If the element is not an <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element, this method throws
an error. Note that you can pass an empty string to clear the input field.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to set for the <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fill(
    self, value: str, timeout: float = None, no_wait_after: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.fill

    This method waits for [actionability](./actionability.md) checks, focuses the element, fills it and triggers an `input`
    event after filling. If the element is not an `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element, this method throws
    an error. Note that you can pass an empty string to clear the input field.

    Parameters
    ----------
    value : str
        Value to set for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.fill started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.fill(
                value=value, timeout=timeout, noWaitAfter=no_wait_after
            )
        )
        log_api(&#34;&lt;= element_handle.fill succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.fill failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.focus"><code class="name flex">
<span>async def <span class="ident">focus</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.focus</p>
<p>Calls <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus">focus</a> on the element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def focus(self) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.focus

    Calls [focus](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) on the element.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.focus started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.focus())
        log_api(&#34;&lt;= element_handle.focus succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.focus failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.get_attribute"><code class="name flex">
<span>async def <span class="ident">get_attribute</span></span>(<span>self, name: str) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.get_attribute</p>
<p>Returns element attribute value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Attribute name to get the value for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_attribute(self, name: str) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;ElementHandle.get_attribute

    Returns element attribute value.

    Parameters
    ----------
    name : str
        Attribute name to get the value for.

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.get_attribute started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.get_attribute(name=name)
        )
        log_api(&#34;&lt;= element_handle.get_attribute succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.get_attribute failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.hover"><code class="name flex">
<span>async def <span class="ident">hover</span></span>(<span>self, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, timeout: float = None, force: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.hover</p>
<p>This method hovers over the element by performing the following steps:
1. Wait for <a href="./actionability.md">actionability</a> checks on the element, unless <code>force</code> option is set.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to hover over the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def hover(
    self,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    timeout: float = None,
    force: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.hover

    This method hovers over the element by performing the following steps:
    1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to hover over the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    If the element is detached from the DOM at any moment during the action, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Parameters
    ----------
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.hover started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.hover(
                modifiers=modifiers, position=position, timeout=timeout, force=force
            )
        )
        log_api(&#34;&lt;= element_handle.hover succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.hover failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.inner_html"><code class="name flex">
<span>async def <span class="ident">inner_html</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.inner_html</p>
<p>Returns the <code>element.innerHTML</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def inner_html(self) -&gt; str:
    &#34;&#34;&#34;ElementHandle.inner_html

    Returns the `element.innerHTML`.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.inner_html started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.inner_html())
        log_api(&#34;&lt;= element_handle.inner_html succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.inner_html failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.inner_text"><code class="name flex">
<span>async def <span class="ident">inner_text</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.inner_text</p>
<p>Returns the <code>element.innerText</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def inner_text(self) -&gt; str:
    &#34;&#34;&#34;ElementHandle.inner_text

    Returns the `element.innerText`.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.inner_text started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.inner_text())
        log_api(&#34;&lt;= element_handle.inner_text succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.inner_text failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.is_checked"><code class="name flex">
<span>async def <span class="ident">is_checked</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.is_checked</p>
<p>Returns whether the element is checked. Throws if the element is not a checkbox or radio input.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_checked(self) -&gt; bool:
    &#34;&#34;&#34;ElementHandle.is_checked

    Returns whether the element is checked. Throws if the element is not a checkbox or radio input.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.is_checked started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.is_checked())
        log_api(&#34;&lt;= element_handle.is_checked succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.is_checked failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.is_disabled"><code class="name flex">
<span>async def <span class="ident">is_disabled</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.is_disabled</p>
<p>Returns whether the element is disabled, the opposite of <a href="./actionability.md#enabled">enabled</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_disabled(self) -&gt; bool:
    &#34;&#34;&#34;ElementHandle.is_disabled

    Returns whether the element is disabled, the opposite of [enabled](./actionability.md#enabled).

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.is_disabled started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.is_disabled())
        log_api(&#34;&lt;= element_handle.is_disabled succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.is_disabled failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.is_editable"><code class="name flex">
<span>async def <span class="ident">is_editable</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.is_editable</p>
<p>Returns whether the element is <a href="./actionability.md#editable">editable</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_editable(self) -&gt; bool:
    &#34;&#34;&#34;ElementHandle.is_editable

    Returns whether the element is [editable](./actionability.md#editable).

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.is_editable started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.is_editable())
        log_api(&#34;&lt;= element_handle.is_editable succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.is_editable failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.is_enabled"><code class="name flex">
<span>async def <span class="ident">is_enabled</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.is_enabled</p>
<p>Returns whether the element is <a href="./actionability.md#enabled">enabled</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_enabled(self) -&gt; bool:
    &#34;&#34;&#34;ElementHandle.is_enabled

    Returns whether the element is [enabled](./actionability.md#enabled).

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.is_enabled started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.is_enabled())
        log_api(&#34;&lt;= element_handle.is_enabled succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.is_enabled failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.is_hidden"><code class="name flex">
<span>async def <span class="ident">is_hidden</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.is_hidden</p>
<p>Returns whether the element is hidden, the opposite of <a href="./actionability.md#visible">visible</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_hidden(self) -&gt; bool:
    &#34;&#34;&#34;ElementHandle.is_hidden

    Returns whether the element is hidden, the opposite of [visible](./actionability.md#visible).

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.is_hidden started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.is_hidden())
        log_api(&#34;&lt;= element_handle.is_hidden succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.is_hidden failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.is_visible"><code class="name flex">
<span>async def <span class="ident">is_visible</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.is_visible</p>
<p>Returns whether the element is <a href="./actionability.md#visible">visible</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_visible(self) -&gt; bool:
    &#34;&#34;&#34;ElementHandle.is_visible

    Returns whether the element is [visible](./actionability.md#visible).

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.is_visible started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.is_visible())
        log_api(&#34;&lt;= element_handle.is_visible succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.is_visible failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.owner_frame"><code class="name flex">
<span>async def <span class="ident">owner_frame</span></span>(<span>self) ‑> Union[playwright.async_api._generated.Frame, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.owner_frame</p>
<p>Returns the frame containing the given element.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def owner_frame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.owner_frame

    Returns the frame containing the given element.

    Returns
    -------
    Union[Frame, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.owner_frame started&#34;)
        result = mapping.from_impl_nullable(await self._impl_obj.owner_frame())
        log_api(&#34;&lt;= element_handle.owner_frame succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.owner_frame failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.press"><code class="name flex">
<span>async def <span class="ident">press</span></span>(<span>self, key: str, delay: float = None, timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.press</p>
<p>Focuses the element, and then uses <code>keyboard.down()</code> and <code>keyboard.up()</code>.</p>
<p><code>key</code> can specify the intended <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key">keyboardEvent.key</a>
value or a single character to generate the text for. A superset of the <code>key</code> values can be found
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">here</a>. Examples of the keys are:</p>
<p><code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>,
<code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.</p>
<p>Following modification shortcuts are also supported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.</p>
<p>Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.</p>
<p>If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective
texts.</p>
<p>Shortcuts such as <code>key: "Control+o"</code> or <code>key: "Control+Shift+T"</code> are supported as well. When speficied with the
modifier, modifier is pressed and being held while the subsequent key is being pressed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>keydown</code> and <code>keyup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def press(
    self,
    key: str,
    delay: float = None,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.press

    Focuses the element, and then uses `keyboard.down()` and `keyboard.up()`.

    `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
    value or a single character to generate the text for. A superset of the `key` values can be found
    [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
    `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

    Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
    texts.

    Shortcuts such as `key: \&#34;Control+o\&#34;` or `key: \&#34;Control+Shift+T\&#34;` are supported as well. When speficied with the
    modifier, modifier is pressed and being held while the subsequent key is being pressed.

    Parameters
    ----------
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    delay : Union[float, NoneType]
        Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.press started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.press(
                key=key, delay=delay, timeout=timeout, noWaitAfter=no_wait_after
            )
        )
        log_api(&#34;&lt;= element_handle.press succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.press failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.query_selector"><code class="name flex">
<span>async def <span class="ident">query_selector</span></span>(<span>self, selector: str) ‑> Union[playwright.async_api._generated.ElementHandle, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.query_selector</p>
<p>The method finds an element matching the specified selector in the <code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code>'s subtree. See
<a href="./selectors.md#working-with-selectors">Working with selectors</a> for more details. If no elements match the selector,
returns <code>null</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_selector(
    self, selector: str
) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.query_selector

    The method finds an element matching the specified selector in the `ElementHandle`&#39;s subtree. See
    [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements match the selector,
    returns `null`.

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

    Returns
    -------
    Union[ElementHandle, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.query_selector started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.query_selector(selector=selector)
        )
        log_api(&#34;&lt;= element_handle.query_selector succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.query_selector failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.query_selector_all"><code class="name flex">
<span>async def <span class="ident">query_selector_all</span></span>(<span>self, selector: str) ‑> List[playwright.async_api._generated.ElementHandle]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.query_selector_all</p>
<p>The method finds all elements matching the specified selector in the <code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code>s subtree. See
<a href="./selectors.md#working-with-selectors">Working with selectors</a> for more details. If no elements match the selector,
returns empty array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_selector_all(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
    &#34;&#34;&#34;ElementHandle.query_selector_all

    The method finds all elements matching the specified selector in the `ElementHandle`s subtree. See
    [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements match the selector,
    returns empty array.

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

    Returns
    -------
    List[ElementHandle]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.query_selector_all started&#34;)
        result = mapping.from_impl_list(
            await self._impl_obj.query_selector_all(selector=selector)
        )
        log_api(&#34;&lt;= element_handle.query_selector_all succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.query_selector_all failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.screenshot"><code class="name flex">
<span>async def <span class="ident">screenshot</span></span>(<span>self, timeout: float = None, type: Literal['jpeg', 'png'] = None, path: Union[str, pathlib.Path] = None, quality: int = None, omit_background: bool = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.screenshot</p>
<p>Returns the buffer with the captured screenshot.</p>
<p>This method waits for the <a href="./actionability.md">actionability</a> checks, then scrolls element into view before taking a
screenshot. If the element is detached from DOM, the method throws an error.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Union["jpeg", "png", NoneType]</code></dt>
<dd>Specify screenshot type, defaults to <code>png</code>.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>The file path to save the image to. The screenshot type will be inferred from file extension. If <code>path</code> is a relative
path, then it is resolved relative to the current working directory. If no path is provided, the image won't be saved to
the disk.</dd>
<dt><strong><code>quality</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>The quality of the image, between 0-100. Not applicable to <code>png</code> images.</dd>
<dt><strong><code>omit_background</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Hides default white background and allows capturing screenshots with transparency. Not applicable to <code>jpeg</code> images.
Defaults to <code>false</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def screenshot(
    self,
    timeout: float = None,
    type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
    path: typing.Union[str, pathlib.Path] = None,
    quality: int = None,
    omit_background: bool = None,
) -&gt; bytes:
    &#34;&#34;&#34;ElementHandle.screenshot

    Returns the buffer with the captured screenshot.

    This method waits for the [actionability](./actionability.md) checks, then scrolls element into view before taking a
    screenshot. If the element is detached from DOM, the method throws an error.

    Parameters
    ----------
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    type : Union[&#34;jpeg&#34;, &#34;png&#34;, NoneType]
        Specify screenshot type, defaults to `png`.
    path : Union[pathlib.Path, str, NoneType]
        The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative
        path, then it is resolved relative to the current working directory. If no path is provided, the image won&#39;t be saved to
        the disk.
    quality : Union[int, NoneType]
        The quality of the image, between 0-100. Not applicable to `png` images.
    omit_background : Union[bool, NoneType]
        Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images.
        Defaults to `false`.

    Returns
    -------
    bytes
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.screenshot started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.screenshot(
                timeout=timeout,
                type=type,
                path=path,
                quality=quality,
                omitBackground=omit_background,
            )
        )
        log_api(&#34;&lt;= element_handle.screenshot succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.screenshot failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.scroll_into_view_if_needed"><code class="name flex">
<span>async def <span class="ident">scroll_into_view_if_needed</span></span>(<span>self, timeout: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.scroll_into_view_if_needed</p>
<p>This method waits for <a href="./actionability.md">actionability</a> checks, then tries to scroll element into view, unless it is
completely visible as defined by
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">IntersectionObserver</a>'s <code>ratio</code>.</p>
<p>Throws when <code>elementHandle</code> does not point to an element
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected">connected</a> to a Document or a ShadowRoot.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def scroll_into_view_if_needed(self, timeout: float = None) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.scroll_into_view_if_needed

    This method waits for [actionability](./actionability.md) checks, then tries to scroll element into view, unless it is
    completely visible as defined by
    [IntersectionObserver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)&#39;s `ratio`.

    Throws when `elementHandle` does not point to an element
    [connected](https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected) to a Document or a ShadowRoot.

    Parameters
    ----------
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.scroll_into_view_if_needed started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.scroll_into_view_if_needed(timeout=timeout)
        )
        log_api(&#34;&lt;= element_handle.scroll_into_view_if_needed succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.scroll_into_view_if_needed failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.select_option"><code class="name flex">
<span>async def <span class="ident">select_option</span></span>(<span>self, value: Union[str, List[str]] = None, index: Union[int, List[int]] = None, label: Union[str, List[str]] = None, element: Union[ForwardRef('<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>'), List[ForwardRef('<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>')]] = None, timeout: float = None, no_wait_after: bool = None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.select_option</p>
<p>Returns the array of option values that have been successfully selected.</p>
<p>Triggers a <code>change</code> and <code>input</code> event once all the provided options have been selected. If element is not a <code>&lt;select&gt;</code>
element, the method throws an error.</p>
<pre><code class="language-py"># single selection matching the value
await handle.select_option(&quot;select#colors&quot;, &quot;blue&quot;)
# single selection matching the label
await handle.select_option(&quot;select#colors&quot;, label=&quot;blue&quot;)
# multiple selection
await handle.select_option(&quot;select#colors&quot;, value=[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;])
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>Union[List[str], str, NoneType]</code></dt>
<dd>Options to select by value. If the <code>&lt;select&gt;</code> has the <code>multiple</code> attribute, all given options are selected, otherwise
only the first option matching one of the passed options is selected. Optional.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>Union[List[int], int, NoneType]</code></dt>
<dd>Options to select by index. Optional.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>Union[List[str], str, NoneType]</code></dt>
<dd>Options to select by label. If the <code>&lt;select&gt;</code> has the <code>multiple</code> attribute, all given options are selected, otherwise
only the first option matching one of the passed options is selected. Optional.</dd>
<dt><strong><code>element</code></strong> :&ensp;<code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, List[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>], NoneType]</code></dt>
<dd>Option elements to select. Optional.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def select_option(
    self,
    value: typing.Union[str, typing.List[str]] = None,
    index: typing.Union[int, typing.List[int]] = None,
    label: typing.Union[str, typing.List[str]] = None,
    element: typing.Union[&#34;ElementHandle&#34;, typing.List[&#34;ElementHandle&#34;]] = None,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; typing.List[str]:
    &#34;&#34;&#34;ElementHandle.select_option

    Returns the array of option values that have been successfully selected.

    Triggers a `change` and `input` event once all the provided options have been selected. If element is not a `&lt;select&gt;`
    element, the method throws an error.

    ```py
    # single selection matching the value
    await handle.select_option(\&#34;select#colors\&#34;, \&#34;blue\&#34;)
    # single selection matching the label
    await handle.select_option(\&#34;select#colors\&#34;, label=\&#34;blue\&#34;)
    # multiple selection
    await handle.select_option(\&#34;select#colors\&#34;, value=[\&#34;red\&#34;, \&#34;green\&#34;, \&#34;blue\&#34;])
    ```

    Parameters
    ----------
    value : Union[List[str], str, NoneType]
        Options to select by value. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
        only the first option matching one of the passed options is selected. Optional.
    index : Union[List[int], int, NoneType]
        Options to select by index. Optional.
    label : Union[List[str], str, NoneType]
        Options to select by label. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
        only the first option matching one of the passed options is selected. Optional.
    element : Union[ElementHandle, List[ElementHandle], NoneType]
        Option elements to select. Optional.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.

    Returns
    -------
    List[str]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.select_option started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.select_option(
                value=value,
                index=index,
                label=label,
                element=mapping.to_impl(element),
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= element_handle.select_option succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.select_option failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.select_text"><code class="name flex">
<span>async def <span class="ident">select_text</span></span>(<span>self, timeout: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.select_text</p>
<p>This method waits for <a href="./actionability.md">actionability</a> checks, then focuses the element and selects all its text
content.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def select_text(self, timeout: float = None) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.select_text

    This method waits for [actionability](./actionability.md) checks, then focuses the element and selects all its text
    content.

    Parameters
    ----------
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.select_text started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.select_text(timeout=timeout)
        )
        log_api(&#34;&lt;= element_handle.select_text succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.select_text failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.set_input_files"><code class="name flex">
<span>async def <span class="ident">set_input_files</span></span>(<span>self, files: Union[str, pathlib.Path, playwright._impl._api_structures.FilePayload, List[Union[str, pathlib.Path]], List[playwright._impl._api_structures.FilePayload]], timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.set_input_files</p>
<p>This method expects <code>elementHandle</code> to point to an
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">input element</a>.</p>
<p>Sets the value of the file input to these file paths or files. If some of the <code>filePaths</code> are relative paths, then they
are resolved relative to the the current working directory. For empty array, clears the selected files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_input_files(
    self,
    files: typing.Union[
        str,
        pathlib.Path,
        FilePayload,
        typing.List[typing.Union[str, pathlib.Path]],
        typing.List[FilePayload],
    ],
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.set_input_files

    This method expects `elementHandle` to point to an
    [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).

    Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
    are resolved relative to the the current working directory. For empty array, clears the selected files.

    Parameters
    ----------
    files : Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.set_input_files started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_input_files(
                files=files, timeout=timeout, noWaitAfter=no_wait_after
            )
        )
        log_api(&#34;&lt;= element_handle.set_input_files succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.set_input_files failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.tap"><code class="name flex">
<span>async def <span class="ident">tap</span></span>(<span>self, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.tap</p>
<p>This method taps the element by performing the following steps:
1. Wait for <a href="./actionability.md">actionability</a> checks on the element, unless <code>force</code> option is set.
1. Scroll the element into view if needed.
1. Use <code>page.touchscreen</code> to tap the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<blockquote>
<p>NOTE: <code>elementHandle.tap()</code> requires that the <code>hasTouch</code> option of the browser context be set to true.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def tap(
    self,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.tap

    This method taps the element by performing the following steps:
    1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
    1. Scroll the element into view if needed.
    1. Use `page.touchscreen` to tap the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    If the element is detached from the DOM at any moment during the action, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    &gt; NOTE: `elementHandle.tap()` requires that the `hasTouch` option of the browser context be set to true.

    Parameters
    ----------
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.tap started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.tap(
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= element_handle.tap succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.tap failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.text_content"><code class="name flex">
<span>async def <span class="ident">text_content</span></span>(<span>self) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.text_content</p>
<p>Returns the <code>node.textContent</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def text_content(self) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;ElementHandle.text_content

    Returns the `node.textContent`.

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.text_content started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.text_content())
        log_api(&#34;&lt;= element_handle.text_content succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.text_content failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.type"><code class="name flex">
<span>async def <span class="ident">type</span></span>(<span>self, text: str, delay: float = None, timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.type</p>
<p>Focuses the element, and then sends a <code>keydown</code>, <code>keypress</code>/<code>input</code>, and <code>keyup</code> event for each character in the text.</p>
<p>To press a special key, like <code>Control</code> or <code>ArrowDown</code>, use <code>element_handle.press()</code>.</p>
<pre><code class="language-py">await element_handle.type(&quot;hello&quot;) # types instantly
await element_handle.type(&quot;world&quot;, delay=100) # types slower, like a user
</code></pre>
<p>An example of typing into a text field and then submitting the form:</p>
<pre><code class="language-py">element_handle = await page.query_selector(&quot;input&quot;)
await element_handle.type(&quot;some text&quot;)
await element_handle.press(&quot;Enter&quot;)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>A text to type into a focused element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between key presses in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def type(
    self,
    text: str,
    delay: float = None,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.type

    Focuses the element, and then sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.

    To press a special key, like `Control` or `ArrowDown`, use `element_handle.press()`.

    ```py
    await element_handle.type(\&#34;hello\&#34;) # types instantly
    await element_handle.type(\&#34;world\&#34;, delay=100) # types slower, like a user
    ```

    An example of typing into a text field and then submitting the form:

    ```py
    element_handle = await page.query_selector(\&#34;input\&#34;)
    await element_handle.type(\&#34;some text\&#34;)
    await element_handle.press(\&#34;Enter\&#34;)
    ```

    Parameters
    ----------
    text : str
        A text to type into a focused element.
    delay : Union[float, NoneType]
        Time to wait between key presses in milliseconds. Defaults to 0.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.type started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.type(
                text=text, delay=delay, timeout=timeout, noWaitAfter=no_wait_after
            )
        )
        log_api(&#34;&lt;= element_handle.type succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.type failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.uncheck"><code class="name flex">
<span>async def <span class="ident">uncheck</span></span>(<span>self, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.uncheck</p>
<p>This method checks the element by performing the following steps:
1. Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already
unchecked, this method returns immediately.
1. Wait for <a href="./actionability.md">actionability</a> checks on the element, unless <code>force</code> option is set.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to click in the center of the element.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
1. Ensure that the element is now unchecked. If not, this method rejects.</p>
<p>If the element is detached from the DOM at any moment during the action, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def uncheck(
    self, timeout: float = None, force: bool = None, no_wait_after: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.uncheck

    This method checks the element by performing the following steps:
    1. Ensure that element is a checkbox or a radio input. If not, this method rejects. If the element is already
       unchecked, this method returns immediately.
    1. Wait for [actionability](./actionability.md) checks on the element, unless `force` option is set.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to click in the center of the element.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    1. Ensure that the element is now unchecked. If not, this method rejects.

    If the element is detached from the DOM at any moment during the action, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Parameters
    ----------
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.uncheck started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.uncheck(
                timeout=timeout, force=force, noWaitAfter=no_wait_after
            )
        )
        log_api(&#34;&lt;= element_handle.uncheck succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.uncheck failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.wait_for_element_state"><code class="name flex">
<span>async def <span class="ident">wait_for_element_state</span></span>(<span>self, state: Literal['disabled', 'editable', 'enabled', 'hidden', 'stable', 'visible'], timeout: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.wait_for_element_state</p>
<p>Returns when the element satisfies the <code>state</code>.</p>
<p>Depending on the <code>state</code> parameter, this method waits for one of the <a href="./actionability.md">actionability</a> checks to pass.
This method throws when the element is detached while waiting, unless waiting for the <code>"hidden"</code> state.
- <code>"visible"</code> Wait until the element is <a href="./actionability.md#visible">visible</a>.
- <code>"hidden"</code> Wait until the element is <a href="./actionability.md#visible">not visible</a> or
<a href="./actionability.md#attached">not attached</a>. Note that waiting for hidden does not throw when the element detaches.
- <code>"stable"</code> Wait until the element is both <a href="./actionability.md#visible">visible</a> and
<a href="./actionability.md#stable">stable</a>.
- <code>"enabled"</code> Wait until the element is <a href="./actionability.md#enabled">enabled</a>.
- <code>"disabled"</code> Wait until the element is <a href="./actionability.md#enabled">not enabled</a>.
- <code>"editable"</code> Wait until the element is <a href="./actionability.md#editable">editable</a>.</p>
<p>If the element does not satisfy the condition for the <code>timeout</code> milliseconds, this method will throw.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>Union["disabled", "editable", "enabled", "hidden", "stable", "visible"]</code></dt>
<dd>A state to wait for, see below for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_element_state(
    self,
    state: Literal[
        &#34;disabled&#34;, &#34;editable&#34;, &#34;enabled&#34;, &#34;hidden&#34;, &#34;stable&#34;, &#34;visible&#34;
    ],
    timeout: float = None,
) -&gt; NoneType:
    &#34;&#34;&#34;ElementHandle.wait_for_element_state

    Returns when the element satisfies the `state`.

    Depending on the `state` parameter, this method waits for one of the [actionability](./actionability.md) checks to pass.
    This method throws when the element is detached while waiting, unless waiting for the `\&#34;hidden\&#34;` state.
    - `\&#34;visible\&#34;` Wait until the element is [visible](./actionability.md#visible).
    - `\&#34;hidden\&#34;` Wait until the element is [not visible](./actionability.md#visible) or
      [not attached](./actionability.md#attached). Note that waiting for hidden does not throw when the element detaches.
    - `\&#34;stable\&#34;` Wait until the element is both [visible](./actionability.md#visible) and
      [stable](./actionability.md#stable).
    - `\&#34;enabled\&#34;` Wait until the element is [enabled](./actionability.md#enabled).
    - `\&#34;disabled\&#34;` Wait until the element is [not enabled](./actionability.md#enabled).
    - `\&#34;editable\&#34;` Wait until the element is [editable](./actionability.md#editable).

    If the element does not satisfy the condition for the `timeout` milliseconds, this method will throw.

    Parameters
    ----------
    state : Union[&#34;disabled&#34;, &#34;editable&#34;, &#34;enabled&#34;, &#34;hidden&#34;, &#34;stable&#34;, &#34;visible&#34;]
        A state to wait for, see below for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.wait_for_element_state started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.wait_for_element_state(
                state=state, timeout=timeout
            )
        )
        log_api(&#34;&lt;= element_handle.wait_for_element_state succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.wait_for_element_state failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.ElementHandle.wait_for_selector"><code class="name flex">
<span>async def <span class="ident">wait_for_selector</span></span>(<span>self, selector: str, state: Literal['attached', 'detached', 'hidden', 'visible'] = None, timeout: float = None) ‑> Union[playwright.async_api._generated.ElementHandle, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>ElementHandle.wait_for_selector</p>
<p>Returns element specified by selector when it satisfies <code>state</code> option. Returns <code>null</code> if waiting for <code>hidden</code> or
<code>detached</code>.</p>
<p>Wait for the <code>selector</code> relative to the element handle to satisfy <code>state</code> option (either appear/disappear from dom, or
become visible/hidden). If at the moment of calling the method <code>selector</code> already satisfies the condition, the method
will return immediately. If the selector doesn't satisfy the condition for the <code>timeout</code> milliseconds, the function will
throw.</p>
<pre><code class="language-py">await page.set_content(&quot;&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&quot;)
div = await page.query_selector(&quot;div&quot;)
# waiting for the &quot;span&quot; selector relative to the div.
span = await div.wait_for_selector(&quot;span&quot;, state=&quot;attached&quot;)
</code></pre>
<blockquote>
<p>NOTE: This method does not work across navigations, use <code>page.wait_for_selector()</code> instead.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>Union["attached", "detached", "hidden", "visible", NoneType]</code></dt>
<dd>Defaults to <code>'visible'</code>. Can be either:
- <code>'attached'</code> - wait for element to be present in DOM.
- <code>'detached'</code> - wait for element to not be present in DOM.
- <code>'visible'</code> - wait for element to have non-empty bounding box and no <code>visibility:hidden</code>. Note that element without
any content or with <code>display:none</code> has an empty bounding box and is not considered visible.
- <code>'hidden'</code> - wait for element to be either detached from DOM, or have an empty bounding box or <code>visibility:hidden</code>.
This is opposite to the <code>'visible'</code> option.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_selector(
    self,
    selector: str,
    state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
    timeout: float = None,
) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;ElementHandle.wait_for_selector

    Returns element specified by selector when it satisfies `state` option. Returns `null` if waiting for `hidden` or
    `detached`.

    Wait for the `selector` relative to the element handle to satisfy `state` option (either appear/disappear from dom, or
    become visible/hidden). If at the moment of calling the method `selector` already satisfies the condition, the method
    will return immediately. If the selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will
    throw.

    ```py
    await page.set_content(\&#34;&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;\&#34;)
    div = await page.query_selector(\&#34;div\&#34;)
    # waiting for the \&#34;span\&#34; selector relative to the div.
    span = await div.wait_for_selector(\&#34;span\&#34;, state=\&#34;attached\&#34;)
    ```

    &gt; NOTE: This method does not work across navigations, use `page.wait_for_selector()` instead.

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    state : Union[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;, NoneType]
        Defaults to `&#39;visible&#39;`. Can be either:
        - `&#39;attached&#39;` - wait for element to be present in DOM.
        - `&#39;detached&#39;` - wait for element to not be present in DOM.
        - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without
          any content or with `display:none` has an empty bounding box and is not considered visible.
        - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`.
          This is opposite to the `&#39;visible&#39;` option.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    Union[ElementHandle, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; element_handle.wait_for_selector started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.wait_for_selector(
                selector=selector, state=state, timeout=timeout
            )
        )
        log_api(&#34;&lt;= element_handle.wait_for_selector succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= element_handle.wait_for_selector failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Error"><code class="flex name class">
<span>class <span class="ident">Error</span></span>
<span>(</span><span>message: str, stack: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Error(Exception):
    def __init__(self, message: str, stack: str = None) -&gt; None:
        self.message = message
        self.stack = stack
        super().__init__(message)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>playwright._impl._api_types.TimeoutError</li>
</ul>
</dd>
<dt id="playwright.async_api.FileChooser"><code class="flex name class">
<span>class <span class="ident">FileChooser</span></span>
<span>(</span><span>obj: playwright._impl._file_chooser.FileChooser)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileChooser(AsyncBase):
    def __init__(self, obj: FileChooserImpl):
        super().__init__(obj)

    @property
    def page(self) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;FileChooser.page

        Returns page this file chooser belongs to.

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.page)

    @property
    def element(self) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;FileChooser.element

        Returns input element associated with this file chooser.

        Returns
        -------
        ElementHandle
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.element)

    def is_multiple(self) -&gt; bool:
        &#34;&#34;&#34;FileChooser.is_multiple

        Returns whether this file chooser accepts multiple files.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; file_chooser.is_multiple started&#34;)
            result = mapping.from_maybe_impl(self._impl_obj.is_multiple())
            log_api(&#34;&lt;= file_chooser.is_multiple succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= file_chooser.is_multiple failed&#34;)
            raise e

    async def set_files(
        self,
        files: typing.Union[
            str,
            pathlib.Path,
            FilePayload,
            typing.List[typing.Union[str, pathlib.Path]],
            typing.List[FilePayload],
        ],
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;FileChooser.set_files

        Sets the value of the file input this chooser is associated with. If some of the `filePaths` are relative paths, then
        they are resolved relative to the the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        files : Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; file_chooser.set_files started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_files(
                    files=files, timeout=timeout, noWaitAfter=no_wait_after
                )
            )
            log_api(&#34;&lt;= file_chooser.set_files succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= file_chooser.set_files failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.FileChooser.element"><code class="name">var <span class="ident">element</span> : playwright.async_api._generated.ElementHandle</code></dt>
<dd>
<div class="desc"><p>FileChooser.element</p>
<p>Returns input element associated with this file chooser.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def element(self) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;FileChooser.element

    Returns input element associated with this file chooser.

    Returns
    -------
    ElementHandle
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.element)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.FileChooser.page"><code class="name">var <span class="ident">page</span> : playwright.async_api._generated.Page</code></dt>
<dd>
<div class="desc"><p>FileChooser.page</p>
<p>Returns page this file chooser belongs to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def page(self) -&gt; &#34;Page&#34;:
    &#34;&#34;&#34;FileChooser.page

    Returns page this file chooser belongs to.

    Returns
    -------
    Page
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.page)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.FileChooser.is_multiple"><code class="name flex">
<span>def <span class="ident">is_multiple</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>FileChooser.is_multiple</p>
<p>Returns whether this file chooser accepts multiple files.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_multiple(self) -&gt; bool:
    &#34;&#34;&#34;FileChooser.is_multiple

    Returns whether this file chooser accepts multiple files.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; file_chooser.is_multiple started&#34;)
        result = mapping.from_maybe_impl(self._impl_obj.is_multiple())
        log_api(&#34;&lt;= file_chooser.is_multiple succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= file_chooser.is_multiple failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.FileChooser.set_files"><code class="name flex">
<span>async def <span class="ident">set_files</span></span>(<span>self, files: Union[str, pathlib.Path, playwright._impl._api_structures.FilePayload, List[Union[str, pathlib.Path]], List[playwright._impl._api_structures.FilePayload]], timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>FileChooser.set_files</p>
<p>Sets the value of the file input this chooser is associated with. If some of the <code>filePaths</code> are relative paths, then
they are resolved relative to the the current working directory. For empty array, clears the selected files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>files</code></strong> :&ensp;<code>Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_files(
    self,
    files: typing.Union[
        str,
        pathlib.Path,
        FilePayload,
        typing.List[typing.Union[str, pathlib.Path]],
        typing.List[FilePayload],
    ],
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;FileChooser.set_files

    Sets the value of the file input this chooser is associated with. If some of the `filePaths` are relative paths, then
    they are resolved relative to the the current working directory. For empty array, clears the selected files.

    Parameters
    ----------
    files : Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; file_chooser.set_files started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_files(
                files=files, timeout=timeout, noWaitAfter=no_wait_after
            )
        )
        log_api(&#34;&lt;= file_chooser.set_files succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= file_chooser.set_files failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.FilePayload"><code class="flex name class">
<span>class <span class="ident">FilePayload</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilePayload(TypedDict):
    name: str
    mimeType: str
    buffer: bytes</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.FilePayload.buffer"><code class="name">var <span class="ident">buffer</span> : bytes</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.FilePayload.mimeType"><code class="name">var <span class="ident">mimeType</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.FilePayload.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.FloatRect"><code class="flex name class">
<span>class <span class="ident">FloatRect</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FloatRect(TypedDict):
    x: float
    y: float
    width: float
    height: float</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.FloatRect.height"><code class="name">var <span class="ident">height</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.FloatRect.width"><code class="name">var <span class="ident">width</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.FloatRect.x"><code class="name">var <span class="ident">x</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.FloatRect.y"><code class="name">var <span class="ident">y</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Frame"><code class="flex name class">
<span>class <span class="ident">Frame</span></span>
<span>(</span><span>obj: playwright._impl._frame.Frame)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Frame(AsyncBase):
    def __init__(self, obj: FrameImpl):
        super().__init__(obj)

    @property
    def page(self) -&gt; &#34;Page&#34;:
        &#34;&#34;&#34;Frame.page

        Returns the page containing this frame.

        Returns
        -------
        Page
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.page)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;Frame.name

        Returns frame&#39;s name attribute as specified in the tag.

        If the name is empty, returns the id attribute instead.

        &gt; NOTE: This value is calculated once when the frame is created, and will not update if the attribute is changed later.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.name)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Frame.url

        Returns frame&#39;s url.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def parent_frame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;Frame.parent_frame

        Parent frame, if any. Detached frames and main frames return `null`.

        Returns
        -------
        Union[Frame, NoneType]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.parent_frame)

    @property
    def child_frames(self) -&gt; typing.List[&#34;Frame&#34;]:
        &#34;&#34;&#34;Frame.child_frames

        Returns
        -------
        List[Frame]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.child_frames)

    async def goto(
        self,
        url: str,
        timeout: float = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        referer: str = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Frame.goto

        Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
        last redirect.

        `frame.goto` will throw an error if:
        - there&#39;s an SSL error (e.g. in case of self-signed certificates).
        - target URL is invalid.
        - the `timeout` is exceeded during navigation.
        - the remote server does not respond or is unreachable.
        - the main resource failed to load.

        `frame.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404
        \&#34;Not Found\&#34; and 500 \&#34;Internal Server Error\&#34;.  The status code for such responses can be retrieved by calling
        `response.status()`.

        &gt; NOTE: `frame.goto` either throws an error or returns a main resource response. The only exceptions are navigation to
        `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
        &gt; NOTE: Headless mode doesn&#39;t support navigation to a PDF document. See the
        [upstream issue](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).

        Parameters
        ----------
        url : str
            URL to navigate frame to. The url should include scheme, e.g. `https://`.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
        referer : Union[str, NoneType]
            Referer header value. If provided it will take preference over the referer header value set by
            `page.set_extra_http_headers()`.

        Returns
        -------
        Union[Response, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.goto started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.goto(
                    url=url, timeout=timeout, waitUntil=wait_until, referer=referer
                )
            )
            log_api(&#34;&lt;= frame.goto succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.goto failed&#34;)
            raise e

    def expect_navigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: float = None,
    ) -&gt; AsyncEventContextManager[&#34;Response&#34;]:
        &#34;&#34;&#34;Frame.expect_navigation

        Performs action and waits for the next navigation. In case of multiple redirects, the navigation will resolve with the
        response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the
        navigation will resolve with `null`.

        This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
        cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`.
        Consider this example:

        ```py
        async with frame.expect_navigation():
            await frame.click(\&#34;a.delayed-navigation\&#34;) # Clicking the link will indirectly cause a navigation
        # Context manager waited for the navigation to happen.
        ```

        &gt; NOTE: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is
        considered a navigation.

        Parameters
        ----------
        url : Union[Callable[[str], bool], Pattern, str, NoneType]
            A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.

        Returns
        -------
        EventContextManager[Response]
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_navigation(
                url=self._wrap_handler(url), wait_until=wait_until, timeout=timeout
            ).future
        )

    async def wait_for_load_state(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: float = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.wait_for_load_state

        Waits for the required load state to be reached.

        This returns when the frame reaches a required load state, `load` by default. The navigation must have been committed
        when this method is called. If current document has already reached the required state, resolves immediately.

        ```py
        await frame.click(\&#34;button\&#34;) # click triggers navigation.
        await frame.wait_for_load_state() # the promise resolves after \&#34;load\&#34; event.
        ```

        Parameters
        ----------
        state : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            Optional load state to wait for, defaults to `load`. If the state has been already reached while loading current
            document, the method resolves immediately. Can be one of:
            - `&#39;load&#39;` - wait for the `load` event to be fired.
            - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
            - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.wait_for_load_state started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.wait_for_load_state(state=state, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.wait_for_load_state succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.wait_for_load_state failed&#34;)
            raise e

    async def frame_element(self) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Frame.frame_element

        Returns the `frame` or `iframe` element handle which corresponds to this frame.

        This is an inverse of `element_handle.content_frame()`. Note that returned handle actually belongs to the parent
        frame.

        This method throws an error if the frame has been detached before `frameElement()` returns.

        ```py
        frame_element = await frame.frame_element()
        content_frame = await frame_element.content_frame()
        assert frame == content_frame
        ```

        Returns
        -------
        ElementHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.frame_element started&#34;)
            result = mapping.from_impl(await self._impl_obj.frame_element())
            log_api(&#34;&lt;= frame.frame_element succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.frame_element failed&#34;)
            raise e

    async def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Frame.evaluate

        Returns the return value of `pageFunction`

        If the function passed to the `frame.evaluate()` returns a [Promise], then `frame.evaluate()` would wait
        for the promise to resolve and return its value.

        If the function passed to the `frame.evaluate()` returns a non-[Serializable] value,
        then[ method: `Frame.evaluate`] returns `undefined`. DevTools Protocol also supports transferring some additional values
        that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.

        ```py
        result = await frame.evaluate(\&#34;([x, y]) =&gt; Promise.resolve(x * y)\&#34;, [7, 8])
        print(result) # prints \&#34;56\&#34;
        ```

        A string can also be passed in instead of a function.

        ```py
        print(await frame.evaluate(\&#34;1 + 2\&#34;)) # prints \&#34;3\&#34;
        x = 10
        print(await frame.evaluate(f\&#34;1 + {x}\&#34;)) # prints \&#34;11\&#34;
        ```

        `ElementHandle` instances can be passed as an argument to the `frame.evaluate()`:

        ```py
        body_handle = await frame.query_selector(\&#34;body\&#34;)
        html = await frame.evaluate(\&#34;([body, suffix]) =&gt; body.innerHTML + suffix\&#34;, [body_handle, \&#34;hello\&#34;])
        await body_handle.dispose()
        ```

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.evaluate started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= frame.evaluate succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.evaluate failed&#34;)
            raise e

    async def evaluate_handle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Frame.evaluate_handle

        Returns the return value of `pageFunction` as in-page object (JSHandle).

        The only difference between `frame.evaluate()` and `frame.evaluate_handle()` is
        that[ method: Fframe.evaluateHandle`] returns in-page object (JSHandle).

        If the function, passed to the `frame.evaluate_handle()`, returns a [Promise],
        then[ method: Fframe.evaluateHandle`] would wait for the promise to resolve and return its value.

        ```py
        # FIXME
        a_window_handle = await frame.evaluate_handle(\&#34;Promise.resolve(window)\&#34;)
        a_window_handle # handle for the window object.
        ```

        A string can also be passed in instead of a function.

        ```py
        a_handle = await page.evaluate_handle(\&#34;document\&#34;) # handle for the \&#34;document\&#34;
        ```

        `JSHandle` instances can be passed as an argument to the `frame.evaluate_handle()`:

        ```py
        a_handle = await page.evaluate_handle(\&#34;document.body\&#34;)
        result_handle = await page.evaluate_handle(\&#34;body =&gt; body.innerHTML\&#34;, a_handle)
        print(await result_handle.json_value())
        await result_handle.dispose()
        ```

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        JSHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.evaluate_handle started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.evaluate_handle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= frame.evaluate_handle succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.evaluate_handle failed&#34;)
            raise e

    async def query_selector(
        self, selector: str
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Frame.query_selector

        Returns the ElementHandle pointing to the frame element.

        The method finds an element matching the specified selector within the frame. See
        [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements match the selector,
        returns `null`.

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

        Returns
        -------
        Union[ElementHandle, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.query_selector started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.query_selector(selector=selector)
            )
            log_api(&#34;&lt;= frame.query_selector succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.query_selector failed&#34;)
            raise e

    async def query_selector_all(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
        &#34;&#34;&#34;Frame.query_selector_all

        Returns the ElementHandles pointing to the frame elements.

        The method finds all elements matching the specified selector within the frame. See
        [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements match the selector,
        returns empty array.

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

        Returns
        -------
        List[ElementHandle]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.query_selector_all started&#34;)
            result = mapping.from_impl_list(
                await self._impl_obj.query_selector_all(selector=selector)
            )
            log_api(&#34;&lt;= frame.query_selector_all succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.query_selector_all failed&#34;)
            raise e

    async def wait_for_selector(
        self,
        selector: str,
        timeout: float = None,
        state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Frame.wait_for_selector

        Returns when element specified by selector satisfies `state` option. Returns `null` if waiting for `hidden` or
        `detached`.

        Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at
        the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the
        selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.

        This method works across navigations:

        ```py
        import asyncio
        from playwright.async_api import async_playwright

        async def run(playwright):
            chromium = playwright.chromium
            browser = await chromium.launch()
            page = await browser.new_page()
            for current_url in [\&#34;https://google.com\&#34;, \&#34;https://bbc.com\&#34;]:
                await page.goto(current_url, wait_until=\&#34;domcontentloaded\&#34;)
                element = await page.main_frame.wait_for_selector(\&#34;img\&#34;)
                print(\&#34;Loaded image: \&#34; + str(await element.get_attribute(\&#34;src\&#34;)))
            await browser.close()

        async def main():
            async with async_playwright() as playwright:
                await run(playwright)
        asyncio.run(main())
        ```

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        state : Union[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;, NoneType]
            Defaults to `&#39;visible&#39;`. Can be either:
            - `&#39;attached&#39;` - wait for element to be present in DOM.
            - `&#39;detached&#39;` - wait for element to not be present in DOM.
            - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without
              any content or with `display:none` has an empty bounding box and is not considered visible.
            - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`.
              This is opposite to the `&#39;visible&#39;` option.

        Returns
        -------
        Union[ElementHandle, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.wait_for_selector started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.wait_for_selector(
                    selector=selector, timeout=timeout, state=state
                )
            )
            log_api(&#34;&lt;= frame.wait_for_selector succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.wait_for_selector failed&#34;)
            raise e

    async def is_checked(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Frame.is_checked

        Returns whether the element is checked. Throws if the element is not a checkbox or radio input.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.is_checked started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_checked(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.is_checked succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.is_checked failed&#34;)
            raise e

    async def is_disabled(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Frame.is_disabled

        Returns whether the element is disabled, the opposite of [enabled](./actionability.md#enabled).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.is_disabled started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_disabled(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.is_disabled succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.is_disabled failed&#34;)
            raise e

    async def is_editable(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Frame.is_editable

        Returns whether the element is [editable](./actionability.md#editable).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.is_editable started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_editable(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.is_editable succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.is_editable failed&#34;)
            raise e

    async def is_enabled(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Frame.is_enabled

        Returns whether the element is [enabled](./actionability.md#enabled).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.is_enabled started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_enabled(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.is_enabled succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.is_enabled failed&#34;)
            raise e

    async def is_hidden(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Frame.is_hidden

        Returns whether the element is hidden, the opposite of [visible](./actionability.md#visible).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.is_hidden started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_hidden(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.is_hidden succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.is_hidden failed&#34;)
            raise e

    async def is_visible(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Frame.is_visible

        Returns whether the element is [visible](./actionability.md#visible).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.is_visible started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_visible(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.is_visible succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.is_visible failed&#34;)
            raise e

    async def dispatch_event(
        self,
        selector: str,
        type: str,
        event_init: typing.Dict = None,
        timeout: float = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.dispatch_event

        The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click`
        is dispatched. This is equivalend to calling
        [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

        ```py
        await frame.dispatch_event(\&#34;button#submit\&#34;, \&#34;click\&#34;)
        ```

        Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties
        and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.

        Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:
        - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
        - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
        - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
        - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
        - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
        - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
        - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)

        You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

        ```py
        # note you can only create data_transfer in chromium and firefox
        data_transfer = await frame.evaluate_handle(\&#34;new DataTransfer()\&#34;)
        await frame.dispatch_event(\&#34;#source\&#34;, \&#34;dragstart\&#34;, { \&#34;dataTransfer\&#34;: data_transfer })
        ```

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        type : str
            DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
        event_init : Union[Dict, NoneType]
            Optional event-specific initialization properties.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.dispatch_event started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.dispatch_event(
                    selector=selector,
                    type=type,
                    eventInit=mapping.to_impl(event_init),
                    timeout=timeout,
                )
            )
            log_api(&#34;&lt;= frame.dispatch_event succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.dispatch_event failed&#34;)
            raise e

    async def eval_on_selector(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Frame.eval_on_selector

        Returns the return value of `pageFunction`

        The method finds an element matching the specified selector within the frame and passes it as a first argument to
        `pageFunction`. See [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements
        match the selector, the method throws an error.

        If `pageFunction` returns a [Promise], then `frame.$eval` would wait for the promise to resolve and return its value.

        Examples:

        ```py
        search_value = await frame.eval_on_selector(\&#34;#search\&#34;, \&#34;el =&gt; el.value\&#34;)
        preload_href = await frame.eval_on_selector(\&#34;link[rel=preload]\&#34;, \&#34;el =&gt; el.href\&#34;)
        html = await frame.eval_on_selector(\&#34;.main-container\&#34;, \&#34;(e, suffix) =&gt; e.outerHTML + suffix\&#34;, \&#34;hello\&#34;)
        ```

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.eval_on_selector started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.eval_on_selector(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= frame.eval_on_selector succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.eval_on_selector failed&#34;)
            raise e

    async def eval_on_selector_all(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Frame.eval_on_selector_all

        Returns the return value of `pageFunction`

        The method finds all elements matching the specified selector within the frame and passes an array of matched elements
        as a first argument to `pageFunction`. See [Working with selectors](./selectors.md#working-with-selectors) for more
        details.

        If `pageFunction` returns a [Promise], then `frame.$$eval` would wait for the promise to resolve and return its value.

        Examples:

        ```py
        divs_counts = await frame.eval_on_selector_all(\&#34;div\&#34;, \&#34;(divs, min) =&gt; divs.length &gt;= min\&#34;, 10)
        ```

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.eval_on_selector_all started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.eval_on_selector_all(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= frame.eval_on_selector_all succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.eval_on_selector_all failed&#34;)
            raise e

    async def content(self) -&gt; str:
        &#34;&#34;&#34;Frame.content

        Gets the full HTML contents of the frame, including the doctype.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.content started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.content())
            log_api(&#34;&lt;= frame.content succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.content failed&#34;)
            raise e

    async def set_content(
        self,
        html: str,
        timeout: float = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.set_content

        Parameters
        ----------
        html : str
            HTML markup to assign to the page.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.set_content started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_content(
                    html=html, timeout=timeout, waitUntil=wait_until
                )
            )
            log_api(&#34;&lt;= frame.set_content succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.set_content failed&#34;)
            raise e

    def is_detached(self) -&gt; bool:
        &#34;&#34;&#34;Frame.is_detached

        Returns `true` if the frame has been detached, or `false` otherwise.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.is_detached started&#34;)
            result = mapping.from_maybe_impl(self._impl_obj.is_detached())
            log_api(&#34;&lt;= frame.is_detached succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.is_detached failed&#34;)
            raise e

    async def add_script_tag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
        type: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Frame.add_script_tag

        Returns the added tag when the script&#39;s onload fires or when the script content was injected into frame.

        Adds a `&lt;script&gt;` tag into the page with the desired url or content.

        Parameters
        ----------
        url : Union[str, NoneType]
            URL of a script to be added.
        path : Union[pathlib.Path, str, NoneType]
            Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to the
            current working directory.
        content : Union[str, NoneType]
            Raw JavaScript content to be injected into frame.
        type : Union[str, NoneType]
            Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See
            [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) for more details.

        Returns
        -------
        ElementHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.add_script_tag started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.add_script_tag(
                    url=url, path=path, content=content, type=type
                )
            )
            log_api(&#34;&lt;= frame.add_script_tag succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.add_script_tag failed&#34;)
            raise e

    async def add_style_tag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Frame.add_style_tag

        Returns the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.

        Adds a `&lt;link rel=\&#34;stylesheet\&#34;&gt;` tag into the page with the desired url or a `&lt;style type=\&#34;text/css\&#34;&gt;` tag with the
        content.

        Parameters
        ----------
        url : Union[str, NoneType]
            URL of the `&lt;link&gt;` tag.
        path : Union[pathlib.Path, str, NoneType]
            Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to the
            current working directory.
        content : Union[str, NoneType]
            Raw CSS content to be injected into frame.

        Returns
        -------
        ElementHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.add_style_tag started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.add_style_tag(url=url, path=path, content=content)
            )
            log_api(&#34;&lt;= frame.add_style_tag succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.add_style_tag failed&#34;)
            raise e

    async def click(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        delay: float = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        click_count: int = None,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.click

        This method clicks an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to click in the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        delay : Union[float, NoneType]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        click_count : Union[int, NoneType]
            defaults to 1. See [UIEvent.detail].
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.click started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.click(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    clickCount=click_count,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.click succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.click failed&#34;)
            raise e

    async def dblclick(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        delay: float = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.dblclick

        This method double clicks an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to double click in the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the
           first click of the `dblclick()` triggers a navigation event, this method will reject.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        &gt; NOTE: `frame.dblclick()` dispatches two `click` events and a single `dblclick` event.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        delay : Union[float, NoneType]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.dblclick started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.dblclick(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.dblclick succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.dblclick failed&#34;)
            raise e

    async def tap(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.tap

        This method taps an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.touchscreen` to tap the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        &gt; NOTE: `frame.tap()` requires that the `hasTouch` option of the browser context be set to true.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.tap started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.tap(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.tap succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.tap failed&#34;)
            raise e

    async def fill(
        self,
        selector: str,
        value: str,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.fill

        This method waits for an element matching `selector`, waits for [actionability](./actionability.md) checks, focuses the
        element, fills it and triggers an `input` event after filling. If the element matching `selector` is not an `&lt;input&gt;`,
        `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error. Note that you can pass an empty string to
        clear the input field.

        To send fine-grained keyboard events, use `frame.type()`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        value : str
            Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.fill started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.fill(
                    selector=selector,
                    value=value,
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.fill succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.fill failed&#34;)
            raise e

    async def focus(self, selector: str, timeout: float = None) -&gt; NoneType:
        &#34;&#34;&#34;Frame.focus

        This method fetches an element with `selector` and focuses it. If there&#39;s no element matching `selector`, the method
        waits until a matching element appears in the DOM.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.focus started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.focus(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.focus succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.focus failed&#34;)
            raise e

    async def text_content(
        self, selector: str, timeout: float = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Frame.text_content

        Returns `element.textContent`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.text_content started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.text_content(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.text_content succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.text_content failed&#34;)
            raise e

    async def inner_text(self, selector: str, timeout: float = None) -&gt; str:
        &#34;&#34;&#34;Frame.inner_text

        Returns `element.innerText`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.inner_text started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.inner_text(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.inner_text succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.inner_text failed&#34;)
            raise e

    async def inner_html(self, selector: str, timeout: float = None) -&gt; str:
        &#34;&#34;&#34;Frame.inner_html

        Returns `element.innerHTML`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.inner_html started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.inner_html(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= frame.inner_html succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.inner_html failed&#34;)
            raise e

    async def get_attribute(
        self, selector: str, name: str, timeout: float = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Frame.get_attribute

        Returns element attribute value.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        name : str
            Attribute name to get the value for.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.get_attribute started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.get_attribute(
                    selector=selector, name=name, timeout=timeout
                )
            )
            log_api(&#34;&lt;= frame.get_attribute succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.get_attribute failed&#34;)
            raise e

    async def hover(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        timeout: float = None,
        force: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.hover

        This method hovers over an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to hover over the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.hover started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.hover(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                )
            )
            log_api(&#34;&lt;= frame.hover succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.hover failed&#34;)
            raise e

    async def select_option(
        self,
        selector: str,
        value: typing.Union[str, typing.List[str]] = None,
        index: typing.Union[int, typing.List[int]] = None,
        label: typing.Union[str, typing.List[str]] = None,
        element: typing.Union[&#34;ElementHandle&#34;, typing.List[&#34;ElementHandle&#34;]] = None,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; typing.List[str]:
        &#34;&#34;&#34;Frame.select_option

        Returns the array of option values that have been successfully selected.

        Triggers a `change` and `input` event once all the provided options have been selected. If there&#39;s no `&lt;select&gt;` element
        matching `selector`, the method throws an error.

        ```py
        # single selection matching the value
        await frame.select_option(\&#34;select#colors\&#34;, \&#34;blue\&#34;)
        # single selection matching the label
        await frame.select_option(\&#34;select#colors\&#34;, label=\&#34;blue\&#34;)
        # multiple selection
        await frame.select_option(\&#34;select#colors\&#34;, value=[\&#34;red\&#34;, \&#34;green\&#34;, \&#34;blue\&#34;])
        ```

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        value : Union[List[str], str, NoneType]
            Options to select by value. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
            only the first option matching one of the passed options is selected. Optional.
        index : Union[List[int], int, NoneType]
            Options to select by index. Optional.
        label : Union[List[str], str, NoneType]
            Options to select by label. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
            only the first option matching one of the passed options is selected. Optional.
        element : Union[ElementHandle, List[ElementHandle], NoneType]
            Option elements to select. Optional.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.

        Returns
        -------
        List[str]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.select_option started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.select_option(
                    selector=selector,
                    value=value,
                    index=index,
                    label=label,
                    element=mapping.to_impl(element),
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.select_option succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.select_option failed&#34;)
            raise e

    async def set_input_files(
        self,
        selector: str,
        files: typing.Union[
            str,
            pathlib.Path,
            FilePayload,
            typing.List[typing.Union[str, pathlib.Path]],
            typing.List[FilePayload],
        ],
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.set_input_files

        This method expects `selector` to point to an
        [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).

        Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
        are resolved relative to the the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        files : Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.set_input_files started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_input_files(
                    selector=selector,
                    files=files,
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.set_input_files succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.set_input_files failed&#34;)
            raise e

    async def type(
        self,
        selector: str,
        text: str,
        delay: float = None,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.type

        Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `frame.type` can be used to
        send fine-grained keyboard events. To fill values in form fields, use `frame.fill()`.

        To press a special key, like `Control` or `ArrowDown`, use `keyboard.press()`.

        ```py
        await frame.type(\&#34;#mytextarea\&#34;, \&#34;hello\&#34;) # types instantly
        await frame.type(\&#34;#mytextarea\&#34;, \&#34;world\&#34;, delay=100) # types slower, like a user
        ```

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        text : str
            A text to type into a focused element.
        delay : Union[float, NoneType]
            Time to wait between key presses in milliseconds. Defaults to 0.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.type started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.type(
                    selector=selector,
                    text=text,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.type succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.type failed&#34;)
            raise e

    async def press(
        self,
        selector: str,
        key: str,
        delay: float = None,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.press

        `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
        value or a single character to generate the text for. A superset of the `key` values can be found
        [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
        `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

        Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
        texts.

        Shortcuts such as `key: \&#34;Control+o\&#34;` or `key: \&#34;Control+Shift+T\&#34;` are supported as well. When speficied with the
        modifier, modifier is pressed and being held while the subsequent key is being pressed.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Union[float, NoneType]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.press started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.press(
                    selector=selector,
                    key=key,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.press succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.press failed&#34;)
            raise e

    async def check(
        self,
        selector: str,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.check

        This method checks an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
           checked, this method returns immediately.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to click in the center of the element.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        1. Ensure that the element is now checked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.check started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.check(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.check succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.check failed&#34;)
            raise e

    async def uncheck(
        self,
        selector: str,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Frame.uncheck

        This method checks an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
           unchecked, this method returns immediately.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to click in the center of the element.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        1. Ensure that the element is now unchecked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.uncheck started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.uncheck(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= frame.uncheck succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.uncheck failed&#34;)
            raise e

    async def wait_for_timeout(self, timeout: float) -&gt; NoneType:
        &#34;&#34;&#34;Frame.wait_for_timeout

        Waits for the given `timeout` in milliseconds.

        Note that `frame.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to
        be flaky. Use signals such as network events, selectors becoming visible and others instead.

        Parameters
        ----------
        timeout : float
            A timeout to wait for
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.wait_for_timeout started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.wait_for_timeout(timeout=timeout)
            )
            log_api(&#34;&lt;= frame.wait_for_timeout succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.wait_for_timeout failed&#34;)
            raise e

    async def wait_for_function(
        self,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
        timeout: float = None,
        polling: typing.Union[float, Literal[&#34;raf&#34;]] = None,
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Frame.wait_for_function

        Returns when the `pageFunction` returns a truthy value, returns that value.

        The `waitForFunction` can be used to observe viewport size change:

        ```py
        import asyncio
        from playwright.async_api import async_playwright

        async def run(playwright):
            webkit = playwright.webkit
            browser = await webkit.launch()
            page = await browser.new_page()
            watch_dog = page.main_frame.wait_for_function(\&#34;() =&gt; window.innerWidth &lt; 100\&#34;)
            await page.set_viewport_size({\&#34;width\&#34;: 50, \&#34;height\&#34;: 50})
            await watch_dog
            await browser.close()

        async def main():
            async with async_playwright() as playwright:
                await run(playwright)
        asyncio.run(main())
        ```

        To pass an argument to the predicate of `frame.waitForFunction` function:

        ```py
        selector = \&#34;.foo\&#34;
        await frame.wait_for_function(\&#34;selector =&gt; !!document.querySelector(selector)\&#34;, selector)
        ```

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.
        timeout : Union[float, NoneType]
            maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.
        polling : Union[&#34;raf&#34;, float, NoneType]
            If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is
            a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

        Returns
        -------
        JSHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.wait_for_function started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.wait_for_function(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                    timeout=timeout,
                    polling=polling,
                )
            )
            log_api(&#34;&lt;= frame.wait_for_function succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.wait_for_function failed&#34;)
            raise e

    async def title(self) -&gt; str:
        &#34;&#34;&#34;Frame.title

        Returns the page title.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.title started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.title())
            log_api(&#34;&lt;= frame.title succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.title failed&#34;)
            raise e

    async def wait_for_navigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: float = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Frame.wait_for_navigation

        Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
        last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will
        resolve with `null`.

        This method waits for the frame to navigate to a new URL. It is useful for when you run code which will indirectly cause
        the frame to navigate. Consider this example:

        ```py
        async with frame.expect_navigation():
            await frame.click(\&#34;a.delayed-navigation\&#34;) # clicking the link will indirectly cause a navigation
        # Resolves after navigation has finished
        ```

        &gt; NOTE: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is
        considered a navigation.

        Parameters
        ----------
        url : Union[Callable[[str], bool], Pattern, str, NoneType]
            URL string, URL regex pattern or predicate receiving [URL] to match while waiting for the navigation.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.

        Returns
        -------
        Union[Response, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; frame.wait_for_navigation started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.wait_for_navigation(
                    url=self._wrap_handler(url), waitUntil=wait_until, timeout=timeout
                )
            )
            log_api(&#34;&lt;= frame.wait_for_navigation succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= frame.wait_for_navigation failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Frame.child_frames"><code class="name">var <span class="ident">child_frames</span> : List[playwright.async_api._generated.Frame]</code></dt>
<dd>
<div class="desc"><p>Frame.child_frames</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def child_frames(self) -&gt; typing.List[&#34;Frame&#34;]:
    &#34;&#34;&#34;Frame.child_frames

    Returns
    -------
    List[Frame]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.child_frames)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Frame.name</p>
<p>Returns frame's name attribute as specified in the tag.</p>
<p>If the name is empty, returns the id attribute instead.</p>
<blockquote>
<p>NOTE: This value is calculated once when the frame is created, and will not update if the attribute is changed later.</p>
</blockquote>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;Frame.name

    Returns frame&#39;s name attribute as specified in the tag.

    If the name is empty, returns the id attribute instead.

    &gt; NOTE: This value is calculated once when the frame is created, and will not update if the attribute is changed later.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.name)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.page"><code class="name">var <span class="ident">page</span> : playwright.async_api._generated.Page</code></dt>
<dd>
<div class="desc"><p>Frame.page</p>
<p>Returns the page containing this frame.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def page(self) -&gt; &#34;Page&#34;:
    &#34;&#34;&#34;Frame.page

    Returns the page containing this frame.

    Returns
    -------
    Page
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.page)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.parent_frame"><code class="name">var <span class="ident">parent_frame</span> : Union[playwright.async_api._generated.Frame, NoneType]</code></dt>
<dd>
<div class="desc"><p>Frame.parent_frame</p>
<p>Parent frame, if any. Detached frames and main frames return <code>null</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent_frame(self) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
    &#34;&#34;&#34;Frame.parent_frame

    Parent frame, if any. Detached frames and main frames return `null`.

    Returns
    -------
    Union[Frame, NoneType]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.parent_frame)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Frame.url</p>
<p>Returns frame's url.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Frame.url

    Returns frame&#39;s url.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Frame.add_script_tag"><code class="name flex">
<span>async def <span class="ident">add_script_tag</span></span>(<span>self, url: str = None, path: Union[str, pathlib.Path] = None, content: str = None, type: str = None) ‑> playwright.async_api._generated.ElementHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.add_script_tag</p>
<p>Returns the added tag when the script's onload fires or when the script content was injected into frame.</p>
<p>Adds a <code>&lt;script&gt;</code> tag into the page with the desired url or content.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>URL of a script to be added.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the JavaScript file to be injected into frame. If <code>path</code> is a relative path, then it is resolved relative to the
current working directory.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Raw JavaScript content to be injected into frame.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Script type. Use 'module' in order to load a Javascript ES6 module. See
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script">script</a> for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_script_tag(
    self,
    url: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    content: str = None,
    type: str = None,
) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Frame.add_script_tag

    Returns the added tag when the script&#39;s onload fires or when the script content was injected into frame.

    Adds a `&lt;script&gt;` tag into the page with the desired url or content.

    Parameters
    ----------
    url : Union[str, NoneType]
        URL of a script to be added.
    path : Union[pathlib.Path, str, NoneType]
        Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to the
        current working directory.
    content : Union[str, NoneType]
        Raw JavaScript content to be injected into frame.
    type : Union[str, NoneType]
        Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See
        [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) for more details.

    Returns
    -------
    ElementHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.add_script_tag started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.add_script_tag(
                url=url, path=path, content=content, type=type
            )
        )
        log_api(&#34;&lt;= frame.add_script_tag succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.add_script_tag failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.add_style_tag"><code class="name flex">
<span>async def <span class="ident">add_style_tag</span></span>(<span>self, url: str = None, path: Union[str, pathlib.Path] = None, content: str = None) ‑> playwright.async_api._generated.ElementHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.add_style_tag</p>
<p>Returns the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.</p>
<p>Adds a <code>&lt;link rel="stylesheet"&gt;</code> tag into the page with the desired url or a <code>&lt;style type="text/css"&gt;</code> tag with the
content.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>URL of the <code>&lt;link&gt;</code> tag.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the CSS file to be injected into frame. If <code>path</code> is a relative path, then it is resolved relative to the
current working directory.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Raw CSS content to be injected into frame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_style_tag(
    self,
    url: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    content: str = None,
) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Frame.add_style_tag

    Returns the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.

    Adds a `&lt;link rel=\&#34;stylesheet\&#34;&gt;` tag into the page with the desired url or a `&lt;style type=\&#34;text/css\&#34;&gt;` tag with the
    content.

    Parameters
    ----------
    url : Union[str, NoneType]
        URL of the `&lt;link&gt;` tag.
    path : Union[pathlib.Path, str, NoneType]
        Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to the
        current working directory.
    content : Union[str, NoneType]
        Raw CSS content to be injected into frame.

    Returns
    -------
    ElementHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.add_style_tag started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.add_style_tag(url=url, path=path, content=content)
        )
        log_api(&#34;&lt;= frame.add_style_tag succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.add_style_tag failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.check"><code class="name flex">
<span>async def <span class="ident">check</span></span>(<span>self, selector: str, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.check</p>
<p>This method checks an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
checked, this method returns immediately.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to click in the center of the element.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
1. Ensure that the element is now checked. If not, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check(
    self,
    selector: str,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.check

    This method checks an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
       checked, this method returns immediately.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to click in the center of the element.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    1. Ensure that the element is now checked. If not, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.check started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.check(
                selector=selector,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.check succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.check failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.click"><code class="name flex">
<span>async def <span class="ident">click</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, delay: float = None, button: Literal['left', 'middle', 'right'] = None, click_count: int = None, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.click</p>
<p>This method clicks an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to click in the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>click_count</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>defaults to 1. See [UIEvent.detail].</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def click(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    delay: float = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    click_count: int = None,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.click

    This method clicks an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to click in the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    delay : Union[float, NoneType]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    click_count : Union[int, NoneType]
        defaults to 1. See [UIEvent.detail].
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.click started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.click(
                selector=selector,
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                clickCount=click_count,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.click succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.click failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.content"><code class="name flex">
<span>async def <span class="ident">content</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.content</p>
<p>Gets the full HTML contents of the frame, including the doctype.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def content(self) -&gt; str:
    &#34;&#34;&#34;Frame.content

    Gets the full HTML contents of the frame, including the doctype.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.content started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.content())
        log_api(&#34;&lt;= frame.content succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.content failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.dblclick"><code class="name flex">
<span>async def <span class="ident">dblclick</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, delay: float = None, button: Literal['left', 'middle', 'right'] = None, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.dblclick</p>
<p>This method double clicks an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to double click in the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set. Note that if the
first click of the <code>dblclick()</code> triggers a navigation event, this method will reject.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<blockquote>
<p>NOTE: <code>frame.dblclick()</code> dispatches two <code>click</code> events and a single <code>dblclick</code> event.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dblclick(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    delay: float = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.dblclick

    This method double clicks an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to double click in the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the
       first click of the `dblclick()` triggers a navigation event, this method will reject.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    &gt; NOTE: `frame.dblclick()` dispatches two `click` events and a single `dblclick` event.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    delay : Union[float, NoneType]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.dblclick started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.dblclick(
                selector=selector,
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.dblclick succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.dblclick failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.dispatch_event"><code class="name flex">
<span>async def <span class="ident">dispatch_event</span></span>(<span>self, selector: str, type: str, event_init: Dict = None, timeout: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.dispatch_event</p>
<p>The snippet below dispatches the <code>click</code> event on the element. Regardless of the visibility state of the elment, <code>click</code>
is dispatched. This is equivalend to calling
<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click">element.click()</a>.</p>
<pre><code class="language-py">await frame.dispatch_event(&quot;button#submit&quot;, &quot;click&quot;)
</code></pre>
<p>Under the hood, it creates an instance of an event based on the given <code>type</code>, initializes it with <code>eventInit</code> properties
and dispatches it on the element. Events are <code>composed</code>, <code>cancelable</code> and bubble by default.</p>
<p>Since <code>eventInit</code> is event-specific, please refer to the events documentation for the lists of initial properties:
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent">DragEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent">FocusEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent">KeyboardEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent">MouseEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent">PointerEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent">TouchEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event">Event</a></p>
<p>You can also specify <code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code> as the property value if you want live objects to be passed into the event:</p>
<pre><code class="language-py"># note you can only create data_transfer in chromium and firefox
data_transfer = await frame.evaluate_handle(&quot;new DataTransfer()&quot;)
await frame.dispatch_event(&quot;#source&quot;, &quot;dragstart&quot;, { &quot;dataTransfer&quot;: data_transfer })
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>DOM event type: <code>"click"</code>, <code>"dragstart"</code>, etc.</dd>
<dt><strong><code>event_init</code></strong> :&ensp;<code>Union[Dict, NoneType]</code></dt>
<dd>Optional event-specific initialization properties.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dispatch_event(
    self,
    selector: str,
    type: str,
    event_init: typing.Dict = None,
    timeout: float = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.dispatch_event

    The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click`
    is dispatched. This is equivalend to calling
    [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

    ```py
    await frame.dispatch_event(\&#34;button#submit\&#34;, \&#34;click\&#34;)
    ```

    Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties
    and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.

    Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:
    - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
    - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
    - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
    - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
    - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
    - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
    - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)

    You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

    ```py
    # note you can only create data_transfer in chromium and firefox
    data_transfer = await frame.evaluate_handle(\&#34;new DataTransfer()\&#34;)
    await frame.dispatch_event(\&#34;#source\&#34;, \&#34;dragstart\&#34;, { \&#34;dataTransfer\&#34;: data_transfer })
    ```

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    type : str
        DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
    event_init : Union[Dict, NoneType]
        Optional event-specific initialization properties.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.dispatch_event started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.dispatch_event(
                selector=selector,
                type=type,
                eventInit=mapping.to_impl(event_init),
                timeout=timeout,
            )
        )
        log_api(&#34;&lt;= frame.dispatch_event succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.dispatch_event failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.eval_on_selector"><code class="name flex">
<span>async def <span class="ident">eval_on_selector</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.eval_on_selector</p>
<p>Returns the return value of <code>pageFunction</code></p>
<p>The method finds an element matching the specified selector within the frame and passes it as a first argument to
<code>pageFunction</code>. See <a href="./selectors.md#working-with-selectors">Working with selectors</a> for more details. If no elements
match the selector, the method throws an error.</p>
<p>If <code>pageFunction</code> returns a [Promise], then <code>frame.$eval</code> would wait for the promise to resolve and return its value.</p>
<p>Examples:</p>
<pre><code class="language-py">search_value = await frame.eval_on_selector(&quot;#search&quot;, &quot;el =&gt; el.value&quot;)
preload_href = await frame.eval_on_selector(&quot;link[rel=preload]&quot;, &quot;el =&gt; el.href&quot;)
html = await frame.eval_on_selector(&quot;.main-container&quot;, &quot;(e, suffix) =&gt; e.outerHTML + suffix&quot;, &quot;hello&quot;)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def eval_on_selector(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;Frame.eval_on_selector

    Returns the return value of `pageFunction`

    The method finds an element matching the specified selector within the frame and passes it as a first argument to
    `pageFunction`. See [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements
    match the selector, the method throws an error.

    If `pageFunction` returns a [Promise], then `frame.$eval` would wait for the promise to resolve and return its value.

    Examples:

    ```py
    search_value = await frame.eval_on_selector(\&#34;#search\&#34;, \&#34;el =&gt; el.value\&#34;)
    preload_href = await frame.eval_on_selector(\&#34;link[rel=preload]\&#34;, \&#34;el =&gt; el.href\&#34;)
    html = await frame.eval_on_selector(\&#34;.main-container\&#34;, \&#34;(e, suffix) =&gt; e.outerHTML + suffix\&#34;, \&#34;hello\&#34;)
    ```

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.eval_on_selector started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.eval_on_selector(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= frame.eval_on_selector succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.eval_on_selector failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.eval_on_selector_all"><code class="name flex">
<span>async def <span class="ident">eval_on_selector_all</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.eval_on_selector_all</p>
<p>Returns the return value of <code>pageFunction</code></p>
<p>The method finds all elements matching the specified selector within the frame and passes an array of matched elements
as a first argument to <code>pageFunction</code>. See <a href="./selectors.md#working-with-selectors">Working with selectors</a> for more
details.</p>
<p>If <code>pageFunction</code> returns a [Promise], then <code>frame.$$eval</code> would wait for the promise to resolve and return its value.</p>
<p>Examples:</p>
<pre><code class="language-py">divs_counts = await frame.eval_on_selector_all(&quot;div&quot;, &quot;(divs, min) =&gt; divs.length &gt;= min&quot;, 10)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def eval_on_selector_all(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;Frame.eval_on_selector_all

    Returns the return value of `pageFunction`

    The method finds all elements matching the specified selector within the frame and passes an array of matched elements
    as a first argument to `pageFunction`. See [Working with selectors](./selectors.md#working-with-selectors) for more
    details.

    If `pageFunction` returns a [Promise], then `frame.$$eval` would wait for the promise to resolve and return its value.

    Examples:

    ```py
    divs_counts = await frame.eval_on_selector_all(\&#34;div\&#34;, \&#34;(divs, min) =&gt; divs.length &gt;= min\&#34;, 10)
    ```

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.eval_on_selector_all started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.eval_on_selector_all(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= frame.eval_on_selector_all succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.eval_on_selector_all failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.evaluate"><code class="name flex">
<span>async def <span class="ident">evaluate</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.evaluate</p>
<p>Returns the return value of <code>pageFunction</code></p>
<p>If the function passed to the <code>frame.evaluate()</code> returns a [Promise], then <code>frame.evaluate()</code> would wait
for the promise to resolve and return its value.</p>
<p>If the function passed to the <code>frame.evaluate()</code> returns a non-[Serializable] value,
then[ method: <code>Frame.evaluate</code>] returns <code>undefined</code>. DevTools Protocol also supports transferring some additional values
that are not serializable by <code>JSON</code>: <code>-0</code>, <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>, and bigint literals.</p>
<pre><code class="language-py">result = await frame.evaluate(&quot;([x, y]) =&gt; Promise.resolve(x * y)&quot;, [7, 8])
print(result) # prints &quot;56&quot;
</code></pre>
<p>A string can also be passed in instead of a function.</p>
<pre><code class="language-py">print(await frame.evaluate(&quot;1 + 2&quot;)) # prints &quot;3&quot;
x = 10
print(await frame.evaluate(f&quot;1 + {x}&quot;)) # prints &quot;11&quot;
</code></pre>
<p><code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code> instances can be passed as an argument to the <code>frame.evaluate()</code>:</p>
<pre><code class="language-py">body_handle = await frame.query_selector(&quot;body&quot;)
html = await frame.evaluate(&quot;([body, suffix]) =&gt; body.innerHTML + suffix&quot;, [body_handle, &quot;hello&quot;])
await body_handle.dispose()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def evaluate(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; typing.Any:
    &#34;&#34;&#34;Frame.evaluate

    Returns the return value of `pageFunction`

    If the function passed to the `frame.evaluate()` returns a [Promise], then `frame.evaluate()` would wait
    for the promise to resolve and return its value.

    If the function passed to the `frame.evaluate()` returns a non-[Serializable] value,
    then[ method: `Frame.evaluate`] returns `undefined`. DevTools Protocol also supports transferring some additional values
    that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.

    ```py
    result = await frame.evaluate(\&#34;([x, y]) =&gt; Promise.resolve(x * y)\&#34;, [7, 8])
    print(result) # prints \&#34;56\&#34;
    ```

    A string can also be passed in instead of a function.

    ```py
    print(await frame.evaluate(\&#34;1 + 2\&#34;)) # prints \&#34;3\&#34;
    x = 10
    print(await frame.evaluate(f\&#34;1 + {x}\&#34;)) # prints \&#34;11\&#34;
    ```

    `ElementHandle` instances can be passed as an argument to the `frame.evaluate()`:

    ```py
    body_handle = await frame.query_selector(\&#34;body\&#34;)
    html = await frame.evaluate(\&#34;([body, suffix]) =&gt; body.innerHTML + suffix\&#34;, [body_handle, \&#34;hello\&#34;])
    await body_handle.dispose()
    ```

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.evaluate started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.evaluate(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= frame.evaluate succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.evaluate failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.evaluate_handle"><code class="name flex">
<span>async def <span class="ident">evaluate_handle</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> playwright.async_api._generated.JSHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.evaluate_handle</p>
<p>Returns the return value of <code>pageFunction</code> as in-page object (JSHandle).</p>
<p>The only difference between <code>frame.evaluate()</code> and <code>frame.evaluate_handle()</code> is
that[ method: Fframe.evaluateHandle`] returns in-page object (JSHandle).</p>
<p>If the function, passed to the <code>frame.evaluate_handle()</code>, returns a [Promise],
then[ method: Fframe.evaluateHandle`] would wait for the promise to resolve and return its value.</p>
<pre><code class="language-py"># FIXME
a_window_handle = await frame.evaluate_handle(&quot;Promise.resolve(window)&quot;)
a_window_handle # handle for the window object.
</code></pre>
<p>A string can also be passed in instead of a function.</p>
<pre><code class="language-py">a_handle = await page.evaluate_handle(&quot;document&quot;) # handle for the &quot;document&quot;
</code></pre>
<p><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code> instances can be passed as an argument to the <code>frame.evaluate_handle()</code>:</p>
<pre><code class="language-py">a_handle = await page.evaluate_handle(&quot;document.body&quot;)
result_handle = await page.evaluate_handle(&quot;body =&gt; body.innerHTML&quot;, a_handle)
print(await result_handle.json_value())
await result_handle.dispose()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def evaluate_handle(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Frame.evaluate_handle

    Returns the return value of `pageFunction` as in-page object (JSHandle).

    The only difference between `frame.evaluate()` and `frame.evaluate_handle()` is
    that[ method: Fframe.evaluateHandle`] returns in-page object (JSHandle).

    If the function, passed to the `frame.evaluate_handle()`, returns a [Promise],
    then[ method: Fframe.evaluateHandle`] would wait for the promise to resolve and return its value.

    ```py
    # FIXME
    a_window_handle = await frame.evaluate_handle(\&#34;Promise.resolve(window)\&#34;)
    a_window_handle # handle for the window object.
    ```

    A string can also be passed in instead of a function.

    ```py
    a_handle = await page.evaluate_handle(\&#34;document\&#34;) # handle for the \&#34;document\&#34;
    ```

    `JSHandle` instances can be passed as an argument to the `frame.evaluate_handle()`:

    ```py
    a_handle = await page.evaluate_handle(\&#34;document.body\&#34;)
    result_handle = await page.evaluate_handle(\&#34;body =&gt; body.innerHTML\&#34;, a_handle)
    print(await result_handle.json_value())
    await result_handle.dispose()
    ```

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    JSHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.evaluate_handle started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.evaluate_handle(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= frame.evaluate_handle succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.evaluate_handle failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.expect_navigation"><code class="name flex">
<span>def <span class="ident">expect_navigation</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager[playwright.async_api._generated.Response]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.expect_navigation</p>
<p>Performs action and waits for the next navigation. In case of multiple redirects, the navigation will resolve with the
response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the
navigation will resolve with <code>null</code>.</p>
<p>This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
cause the page to navigate. e.g. The click target has an <code>onclick</code> handler that triggers navigation from a <code>setTimeout</code>.
Consider this example:</p>
<pre><code class="language-py">async with frame.expect_navigation():
    await frame.click(&quot;a.delayed-navigation&quot;) # Clicking the link will indirectly cause a navigation
# Context manager waited for the navigation to happen.
</code></pre>
<blockquote>
<p>NOTE: Usage of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">History API</a> to change the URL is
considered a navigation.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[Callable[[str], bool], Pattern, str, NoneType]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_navigation(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: float = None,
) -&gt; AsyncEventContextManager[&#34;Response&#34;]:
    &#34;&#34;&#34;Frame.expect_navigation

    Performs action and waits for the next navigation. In case of multiple redirects, the navigation will resolve with the
    response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the
    navigation will resolve with `null`.

    This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
    cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`.
    Consider this example:

    ```py
    async with frame.expect_navigation():
        await frame.click(\&#34;a.delayed-navigation\&#34;) # Clicking the link will indirectly cause a navigation
    # Context manager waited for the navigation to happen.
    ```

    &gt; NOTE: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is
    considered a navigation.

    Parameters
    ----------
    url : Union[Callable[[str], bool], Pattern, str, NoneType]
        A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.

    Returns
    -------
    EventContextManager[Response]
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_navigation(
            url=self._wrap_handler(url), wait_until=wait_until, timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.fill"><code class="name flex">
<span>async def <span class="ident">fill</span></span>(<span>self, selector: str, value: str, timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.fill</p>
<p>This method waits for an element matching <code>selector</code>, waits for <a href="./actionability.md">actionability</a> checks, focuses the
element, fills it and triggers an <code>input</code> event after filling. If the element matching <code>selector</code> is not an <code>&lt;input&gt;</code>,
<code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element, this method throws an error. Note that you can pass an empty string to
clear the input field.</p>
<p>To send fine-grained keyboard events, use <code>frame.type()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to fill for the <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fill(
    self,
    selector: str,
    value: str,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.fill

    This method waits for an element matching `selector`, waits for [actionability](./actionability.md) checks, focuses the
    element, fills it and triggers an `input` event after filling. If the element matching `selector` is not an `&lt;input&gt;`,
    `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error. Note that you can pass an empty string to
    clear the input field.

    To send fine-grained keyboard events, use `frame.type()`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    value : str
        Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.fill started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.fill(
                selector=selector,
                value=value,
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.fill succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.fill failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.focus"><code class="name flex">
<span>async def <span class="ident">focus</span></span>(<span>self, selector: str, timeout: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.focus</p>
<p>This method fetches an element with <code>selector</code> and focuses it. If there's no element matching <code>selector</code>, the method
waits until a matching element appears in the DOM.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def focus(self, selector: str, timeout: float = None) -&gt; NoneType:
    &#34;&#34;&#34;Frame.focus

    This method fetches an element with `selector` and focuses it. If there&#39;s no element matching `selector`, the method
    waits until a matching element appears in the DOM.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.focus started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.focus(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.focus succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.focus failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.frame_element"><code class="name flex">
<span>async def <span class="ident">frame_element</span></span>(<span>self) ‑> playwright.async_api._generated.ElementHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.frame_element</p>
<p>Returns the <code>frame</code> or <code>iframe</code> element handle which corresponds to this frame.</p>
<p>This is an inverse of <code>element_handle.content_frame()</code>. Note that returned handle actually belongs to the parent
frame.</p>
<p>This method throws an error if the frame has been detached before <code>frameElement()</code> returns.</p>
<pre><code class="language-py">frame_element = await frame.frame_element()
content_frame = await frame_element.content_frame()
assert frame == content_frame
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def frame_element(self) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Frame.frame_element

    Returns the `frame` or `iframe` element handle which corresponds to this frame.

    This is an inverse of `element_handle.content_frame()`. Note that returned handle actually belongs to the parent
    frame.

    This method throws an error if the frame has been detached before `frameElement()` returns.

    ```py
    frame_element = await frame.frame_element()
    content_frame = await frame_element.content_frame()
    assert frame == content_frame
    ```

    Returns
    -------
    ElementHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.frame_element started&#34;)
        result = mapping.from_impl(await self._impl_obj.frame_element())
        log_api(&#34;&lt;= frame.frame_element succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.frame_element failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.get_attribute"><code class="name flex">
<span>async def <span class="ident">get_attribute</span></span>(<span>self, selector: str, name: str, timeout: float = None) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.get_attribute</p>
<p>Returns element attribute value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Attribute name to get the value for.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_attribute(
    self, selector: str, name: str, timeout: float = None
) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Frame.get_attribute

    Returns element attribute value.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    name : str
        Attribute name to get the value for.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.get_attribute started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.get_attribute(
                selector=selector, name=name, timeout=timeout
            )
        )
        log_api(&#34;&lt;= frame.get_attribute succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.get_attribute failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.goto"><code class="name flex">
<span>async def <span class="ident">goto</span></span>(<span>self, url: str, timeout: float = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None, referer: str = None) ‑> Union[playwright.async_api._generated.Response, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.goto</p>
<p>Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
last redirect.</p>
<p><code>frame.goto</code> will throw an error if:
- there's an SSL error (e.g. in case of self-signed certificates).
- target URL is invalid.
- the <code>timeout</code> is exceeded during navigation.
- the remote server does not respond or is unreachable.
- the main resource failed to load.</p>
<p><code>frame.goto</code> will not throw an error when any valid HTTP status code is returned by the remote server, including 404
"Not Found" and 500 "Internal Server Error".
The status code for such responses can be retrieved by calling
<code>response.status()</code>.</p>
<blockquote>
<p>NOTE: <code>frame.goto</code> either throws an error or returns a main resource response. The only exceptions are navigation to
<code>about:blank</code> or navigation to the same URL with a different hash, which would succeed and return <code>null</code>.
NOTE: Headless mode doesn't support navigation to a PDF document. See the
<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=761295">upstream issue</a>.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL to navigate frame to. The url should include scheme, e.g. <code>https://</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>referer</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Referer header value. If provided it will take preference over the referer header value set by
<code>page.set_extra_http_headers()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def goto(
    self,
    url: str,
    timeout: float = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    referer: str = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Frame.goto

    Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
    last redirect.

    `frame.goto` will throw an error if:
    - there&#39;s an SSL error (e.g. in case of self-signed certificates).
    - target URL is invalid.
    - the `timeout` is exceeded during navigation.
    - the remote server does not respond or is unreachable.
    - the main resource failed to load.

    `frame.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404
    \&#34;Not Found\&#34; and 500 \&#34;Internal Server Error\&#34;.  The status code for such responses can be retrieved by calling
    `response.status()`.

    &gt; NOTE: `frame.goto` either throws an error or returns a main resource response. The only exceptions are navigation to
    `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
    &gt; NOTE: Headless mode doesn&#39;t support navigation to a PDF document. See the
    [upstream issue](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).

    Parameters
    ----------
    url : str
        URL to navigate frame to. The url should include scheme, e.g. `https://`.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
    referer : Union[str, NoneType]
        Referer header value. If provided it will take preference over the referer header value set by
        `page.set_extra_http_headers()`.

    Returns
    -------
    Union[Response, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.goto started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.goto(
                url=url, timeout=timeout, waitUntil=wait_until, referer=referer
            )
        )
        log_api(&#34;&lt;= frame.goto succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.goto failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.hover"><code class="name flex">
<span>async def <span class="ident">hover</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, timeout: float = None, force: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.hover</p>
<p>This method hovers over an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to hover over the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def hover(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    timeout: float = None,
    force: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.hover

    This method hovers over an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to hover over the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.hover started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.hover(
                selector=selector,
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
            )
        )
        log_api(&#34;&lt;= frame.hover succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.hover failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.inner_html"><code class="name flex">
<span>async def <span class="ident">inner_html</span></span>(<span>self, selector: str, timeout: float = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.inner_html</p>
<p>Returns <code>element.innerHTML</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def inner_html(self, selector: str, timeout: float = None) -&gt; str:
    &#34;&#34;&#34;Frame.inner_html

    Returns `element.innerHTML`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.inner_html started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.inner_html(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.inner_html succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.inner_html failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.inner_text"><code class="name flex">
<span>async def <span class="ident">inner_text</span></span>(<span>self, selector: str, timeout: float = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.inner_text</p>
<p>Returns <code>element.innerText</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def inner_text(self, selector: str, timeout: float = None) -&gt; str:
    &#34;&#34;&#34;Frame.inner_text

    Returns `element.innerText`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.inner_text started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.inner_text(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.inner_text succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.inner_text failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.is_checked"><code class="name flex">
<span>async def <span class="ident">is_checked</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.is_checked</p>
<p>Returns whether the element is checked. Throws if the element is not a checkbox or radio input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_checked(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Frame.is_checked

    Returns whether the element is checked. Throws if the element is not a checkbox or radio input.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.is_checked started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_checked(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.is_checked succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.is_checked failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.is_detached"><code class="name flex">
<span>def <span class="ident">is_detached</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.is_detached</p>
<p>Returns <code>true</code> if the frame has been detached, or <code>false</code> otherwise.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_detached(self) -&gt; bool:
    &#34;&#34;&#34;Frame.is_detached

    Returns `true` if the frame has been detached, or `false` otherwise.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.is_detached started&#34;)
        result = mapping.from_maybe_impl(self._impl_obj.is_detached())
        log_api(&#34;&lt;= frame.is_detached succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.is_detached failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.is_disabled"><code class="name flex">
<span>async def <span class="ident">is_disabled</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.is_disabled</p>
<p>Returns whether the element is disabled, the opposite of <a href="./actionability.md#enabled">enabled</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_disabled(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Frame.is_disabled

    Returns whether the element is disabled, the opposite of [enabled](./actionability.md#enabled).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.is_disabled started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_disabled(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.is_disabled succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.is_disabled failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.is_editable"><code class="name flex">
<span>async def <span class="ident">is_editable</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.is_editable</p>
<p>Returns whether the element is <a href="./actionability.md#editable">editable</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_editable(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Frame.is_editable

    Returns whether the element is [editable](./actionability.md#editable).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.is_editable started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_editable(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.is_editable succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.is_editable failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.is_enabled"><code class="name flex">
<span>async def <span class="ident">is_enabled</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.is_enabled</p>
<p>Returns whether the element is <a href="./actionability.md#enabled">enabled</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_enabled(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Frame.is_enabled

    Returns whether the element is [enabled](./actionability.md#enabled).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.is_enabled started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_enabled(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.is_enabled succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.is_enabled failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.is_hidden"><code class="name flex">
<span>async def <span class="ident">is_hidden</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.is_hidden</p>
<p>Returns whether the element is hidden, the opposite of <a href="./actionability.md#visible">visible</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_hidden(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Frame.is_hidden

    Returns whether the element is hidden, the opposite of [visible](./actionability.md#visible).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.is_hidden started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_hidden(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.is_hidden succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.is_hidden failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.is_visible"><code class="name flex">
<span>async def <span class="ident">is_visible</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.is_visible</p>
<p>Returns whether the element is <a href="./actionability.md#visible">visible</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_visible(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Frame.is_visible

    Returns whether the element is [visible](./actionability.md#visible).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.is_visible started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_visible(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.is_visible succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.is_visible failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.press"><code class="name flex">
<span>async def <span class="ident">press</span></span>(<span>self, selector: str, key: str, delay: float = None, timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.press</p>
<p><code>key</code> can specify the intended <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key">keyboardEvent.key</a>
value or a single character to generate the text for. A superset of the <code>key</code> values can be found
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">here</a>. Examples of the keys are:</p>
<p><code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>,
<code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.</p>
<p>Following modification shortcuts are also supported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.</p>
<p>Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.</p>
<p>If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective
texts.</p>
<p>Shortcuts such as <code>key: "Control+o"</code> or <code>key: "Control+Shift+T"</code> are supported as well. When speficied with the
modifier, modifier is pressed and being held while the subsequent key is being pressed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>keydown</code> and <code>keyup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def press(
    self,
    selector: str,
    key: str,
    delay: float = None,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.press

    `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
    value or a single character to generate the text for. A superset of the `key` values can be found
    [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
    `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

    Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
    texts.

    Shortcuts such as `key: \&#34;Control+o\&#34;` or `key: \&#34;Control+Shift+T\&#34;` are supported as well. When speficied with the
    modifier, modifier is pressed and being held while the subsequent key is being pressed.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    delay : Union[float, NoneType]
        Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.press started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.press(
                selector=selector,
                key=key,
                delay=delay,
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.press succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.press failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.query_selector"><code class="name flex">
<span>async def <span class="ident">query_selector</span></span>(<span>self, selector: str) ‑> Union[playwright.async_api._generated.ElementHandle, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.query_selector</p>
<p>Returns the ElementHandle pointing to the frame element.</p>
<p>The method finds an element matching the specified selector within the frame. See
<a href="./selectors.md#working-with-selectors">Working with selectors</a> for more details. If no elements match the selector,
returns <code>null</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_selector(
    self, selector: str
) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;Frame.query_selector

    Returns the ElementHandle pointing to the frame element.

    The method finds an element matching the specified selector within the frame. See
    [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements match the selector,
    returns `null`.

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

    Returns
    -------
    Union[ElementHandle, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.query_selector started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.query_selector(selector=selector)
        )
        log_api(&#34;&lt;= frame.query_selector succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.query_selector failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.query_selector_all"><code class="name flex">
<span>async def <span class="ident">query_selector_all</span></span>(<span>self, selector: str) ‑> List[playwright.async_api._generated.ElementHandle]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.query_selector_all</p>
<p>Returns the ElementHandles pointing to the frame elements.</p>
<p>The method finds all elements matching the specified selector within the frame. See
<a href="./selectors.md#working-with-selectors">Working with selectors</a> for more details. If no elements match the selector,
returns empty array.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_selector_all(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
    &#34;&#34;&#34;Frame.query_selector_all

    Returns the ElementHandles pointing to the frame elements.

    The method finds all elements matching the specified selector within the frame. See
    [Working with selectors](./selectors.md#working-with-selectors) for more details. If no elements match the selector,
    returns empty array.

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

    Returns
    -------
    List[ElementHandle]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.query_selector_all started&#34;)
        result = mapping.from_impl_list(
            await self._impl_obj.query_selector_all(selector=selector)
        )
        log_api(&#34;&lt;= frame.query_selector_all succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.query_selector_all failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.select_option"><code class="name flex">
<span>async def <span class="ident">select_option</span></span>(<span>self, selector: str, value: Union[str, List[str]] = None, index: Union[int, List[int]] = None, label: Union[str, List[str]] = None, element: Union[ForwardRef('<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>'), List[ForwardRef('<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>')]] = None, timeout: float = None, no_wait_after: bool = None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.select_option</p>
<p>Returns the array of option values that have been successfully selected.</p>
<p>Triggers a <code>change</code> and <code>input</code> event once all the provided options have been selected. If there's no <code>&lt;select&gt;</code> element
matching <code>selector</code>, the method throws an error.</p>
<pre><code class="language-py"># single selection matching the value
await frame.select_option(&quot;select#colors&quot;, &quot;blue&quot;)
# single selection matching the label
await frame.select_option(&quot;select#colors&quot;, label=&quot;blue&quot;)
# multiple selection
await frame.select_option(&quot;select#colors&quot;, value=[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;])
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>Union[List[str], str, NoneType]</code></dt>
<dd>Options to select by value. If the <code>&lt;select&gt;</code> has the <code>multiple</code> attribute, all given options are selected, otherwise
only the first option matching one of the passed options is selected. Optional.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>Union[List[int], int, NoneType]</code></dt>
<dd>Options to select by index. Optional.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>Union[List[str], str, NoneType]</code></dt>
<dd>Options to select by label. If the <code>&lt;select&gt;</code> has the <code>multiple</code> attribute, all given options are selected, otherwise
only the first option matching one of the passed options is selected. Optional.</dd>
<dt><strong><code>element</code></strong> :&ensp;<code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, List[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>], NoneType]</code></dt>
<dd>Option elements to select. Optional.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def select_option(
    self,
    selector: str,
    value: typing.Union[str, typing.List[str]] = None,
    index: typing.Union[int, typing.List[int]] = None,
    label: typing.Union[str, typing.List[str]] = None,
    element: typing.Union[&#34;ElementHandle&#34;, typing.List[&#34;ElementHandle&#34;]] = None,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; typing.List[str]:
    &#34;&#34;&#34;Frame.select_option

    Returns the array of option values that have been successfully selected.

    Triggers a `change` and `input` event once all the provided options have been selected. If there&#39;s no `&lt;select&gt;` element
    matching `selector`, the method throws an error.

    ```py
    # single selection matching the value
    await frame.select_option(\&#34;select#colors\&#34;, \&#34;blue\&#34;)
    # single selection matching the label
    await frame.select_option(\&#34;select#colors\&#34;, label=\&#34;blue\&#34;)
    # multiple selection
    await frame.select_option(\&#34;select#colors\&#34;, value=[\&#34;red\&#34;, \&#34;green\&#34;, \&#34;blue\&#34;])
    ```

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    value : Union[List[str], str, NoneType]
        Options to select by value. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
        only the first option matching one of the passed options is selected. Optional.
    index : Union[List[int], int, NoneType]
        Options to select by index. Optional.
    label : Union[List[str], str, NoneType]
        Options to select by label. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
        only the first option matching one of the passed options is selected. Optional.
    element : Union[ElementHandle, List[ElementHandle], NoneType]
        Option elements to select. Optional.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.

    Returns
    -------
    List[str]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.select_option started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.select_option(
                selector=selector,
                value=value,
                index=index,
                label=label,
                element=mapping.to_impl(element),
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.select_option succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.select_option failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.set_content"><code class="name flex">
<span>async def <span class="ident">set_content</span></span>(<span>self, html: str, timeout: float = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.set_content</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>html</code></strong> :&ensp;<code>str</code></dt>
<dd>HTML markup to assign to the page.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_content(
    self,
    html: str,
    timeout: float = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.set_content

    Parameters
    ----------
    html : str
        HTML markup to assign to the page.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.set_content started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_content(
                html=html, timeout=timeout, waitUntil=wait_until
            )
        )
        log_api(&#34;&lt;= frame.set_content succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.set_content failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.set_input_files"><code class="name flex">
<span>async def <span class="ident">set_input_files</span></span>(<span>self, selector: str, files: Union[str, pathlib.Path, playwright._impl._api_structures.FilePayload, List[Union[str, pathlib.Path]], List[playwright._impl._api_structures.FilePayload]], timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.set_input_files</p>
<p>This method expects <code>selector</code> to point to an
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">input element</a>.</p>
<p>Sets the value of the file input to these file paths or files. If some of the <code>filePaths</code> are relative paths, then they
are resolved relative to the the current working directory. For empty array, clears the selected files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_input_files(
    self,
    selector: str,
    files: typing.Union[
        str,
        pathlib.Path,
        FilePayload,
        typing.List[typing.Union[str, pathlib.Path]],
        typing.List[FilePayload],
    ],
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.set_input_files

    This method expects `selector` to point to an
    [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).

    Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
    are resolved relative to the the current working directory. For empty array, clears the selected files.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    files : Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.set_input_files started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_input_files(
                selector=selector,
                files=files,
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.set_input_files succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.set_input_files failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.tap"><code class="name flex">
<span>async def <span class="ident">tap</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.tap</p>
<p>This method taps an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.touchscreen</code> to tap the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<blockquote>
<p>NOTE: <code>frame.tap()</code> requires that the <code>hasTouch</code> option of the browser context be set to true.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def tap(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.tap

    This method taps an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.touchscreen` to tap the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    &gt; NOTE: `frame.tap()` requires that the `hasTouch` option of the browser context be set to true.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.tap started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.tap(
                selector=selector,
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.tap succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.tap failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.text_content"><code class="name flex">
<span>async def <span class="ident">text_content</span></span>(<span>self, selector: str, timeout: float = None) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.text_content</p>
<p>Returns <code>element.textContent</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def text_content(
    self, selector: str, timeout: float = None
) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Frame.text_content

    Returns `element.textContent`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.text_content started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.text_content(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.text_content succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.text_content failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.title"><code class="name flex">
<span>async def <span class="ident">title</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.title</p>
<p>Returns the page title.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def title(self) -&gt; str:
    &#34;&#34;&#34;Frame.title

    Returns the page title.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.title started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.title())
        log_api(&#34;&lt;= frame.title succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.title failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.type"><code class="name flex">
<span>async def <span class="ident">type</span></span>(<span>self, selector: str, text: str, delay: float = None, timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.type</p>
<p>Sends a <code>keydown</code>, <code>keypress</code>/<code>input</code>, and <code>keyup</code> event for each character in the text. <code>frame.type</code> can be used to
send fine-grained keyboard events. To fill values in form fields, use <code>frame.fill()</code>.</p>
<p>To press a special key, like <code>Control</code> or <code>ArrowDown</code>, use <code>keyboard.press()</code>.</p>
<pre><code class="language-py">await frame.type(&quot;#mytextarea&quot;, &quot;hello&quot;) # types instantly
await frame.type(&quot;#mytextarea&quot;, &quot;world&quot;, delay=100) # types slower, like a user
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>A text to type into a focused element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between key presses in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def type(
    self,
    selector: str,
    text: str,
    delay: float = None,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.type

    Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `frame.type` can be used to
    send fine-grained keyboard events. To fill values in form fields, use `frame.fill()`.

    To press a special key, like `Control` or `ArrowDown`, use `keyboard.press()`.

    ```py
    await frame.type(\&#34;#mytextarea\&#34;, \&#34;hello\&#34;) # types instantly
    await frame.type(\&#34;#mytextarea\&#34;, \&#34;world\&#34;, delay=100) # types slower, like a user
    ```

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    text : str
        A text to type into a focused element.
    delay : Union[float, NoneType]
        Time to wait between key presses in milliseconds. Defaults to 0.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.type started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.type(
                selector=selector,
                text=text,
                delay=delay,
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.type succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.type failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.uncheck"><code class="name flex">
<span>async def <span class="ident">uncheck</span></span>(<span>self, selector: str, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.uncheck</p>
<p>This method checks an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
unchecked, this method returns immediately.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to click in the center of the element.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
1. Ensure that the element is now unchecked. If not, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def uncheck(
    self,
    selector: str,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.uncheck

    This method checks an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
       unchecked, this method returns immediately.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to click in the center of the element.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    1. Ensure that the element is now unchecked. If not, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.uncheck started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.uncheck(
                selector=selector,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= frame.uncheck succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.uncheck failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.wait_for_function"><code class="name flex">
<span>async def <span class="ident">wait_for_function</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None, timeout: float = None, polling: Union[float, Literal['raf']] = None) ‑> playwright.async_api._generated.JSHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.wait_for_function</p>
<p>Returns when the <code>pageFunction</code> returns a truthy value, returns that value.</p>
<p>The <code>waitForFunction</code> can be used to observe viewport size change:</p>
<pre><code class="language-py">import asyncio
from playwright.async_api import async_playwright

async def run(playwright):
    webkit = playwright.webkit
    browser = await webkit.launch()
    page = await browser.new_page()
    watch_dog = page.main_frame.wait_for_function(&quot;() =&gt; window.innerWidth &lt; 100&quot;)
    await page.set_viewport_size({&quot;width&quot;: 50, &quot;height&quot;: 50})
    await watch_dog
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
</code></pre>
<p>To pass an argument to the predicate of <code>frame.waitForFunction</code> function:</p>
<pre><code class="language-py">selector = &quot;.foo&quot;
await frame.wait_for_function(&quot;selector =&gt; !!document.querySelector(selector)&quot;, selector)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
<dt><strong><code>polling</code></strong> :&ensp;<code>Union["raf", float, NoneType]</code></dt>
<dd>If <code>polling</code> is <code>'raf'</code>, then <code>pageFunction</code> is constantly executed in <code>requestAnimationFrame</code> callback. If <code>polling</code> is
a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to <code>raf</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_function(
    self,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
    timeout: float = None,
    polling: typing.Union[float, Literal[&#34;raf&#34;]] = None,
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Frame.wait_for_function

    Returns when the `pageFunction` returns a truthy value, returns that value.

    The `waitForFunction` can be used to observe viewport size change:

    ```py
    import asyncio
    from playwright.async_api import async_playwright

    async def run(playwright):
        webkit = playwright.webkit
        browser = await webkit.launch()
        page = await browser.new_page()
        watch_dog = page.main_frame.wait_for_function(\&#34;() =&gt; window.innerWidth &lt; 100\&#34;)
        await page.set_viewport_size({\&#34;width\&#34;: 50, \&#34;height\&#34;: 50})
        await watch_dog
        await browser.close()

    async def main():
        async with async_playwright() as playwright:
            await run(playwright)
    asyncio.run(main())
    ```

    To pass an argument to the predicate of `frame.waitForFunction` function:

    ```py
    selector = \&#34;.foo\&#34;
    await frame.wait_for_function(\&#34;selector =&gt; !!document.querySelector(selector)\&#34;, selector)
    ```

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.
    timeout : Union[float, NoneType]
        maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.
    polling : Union[&#34;raf&#34;, float, NoneType]
        If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is
        a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

    Returns
    -------
    JSHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.wait_for_function started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.wait_for_function(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
                timeout=timeout,
                polling=polling,
            )
        )
        log_api(&#34;&lt;= frame.wait_for_function succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.wait_for_function failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.wait_for_load_state"><code class="name flex">
<span>async def <span class="ident">wait_for_load_state</span></span>(<span>self, state: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.wait_for_load_state</p>
<p>Waits for the required load state to be reached.</p>
<p>This returns when the frame reaches a required load state, <code>load</code> by default. The navigation must have been committed
when this method is called. If current document has already reached the required state, resolves immediately.</p>
<pre><code class="language-py">await frame.click(&quot;button&quot;) # click triggers navigation.
await frame.wait_for_load_state() # the promise resolves after &quot;load&quot; event.
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>Optional load state to wait for, defaults to <code>load</code>. If the state has been already reached while loading current
document, the method resolves immediately. Can be one of:
- <code>'load'</code> - wait for the <code>load</code> event to be fired.
- <code>'domcontentloaded'</code> - wait for the <code>DOMContentLoaded</code> event to be fired.
- <code>'networkidle'</code> - wait until there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_load_state(
    self,
    state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: float = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Frame.wait_for_load_state

    Waits for the required load state to be reached.

    This returns when the frame reaches a required load state, `load` by default. The navigation must have been committed
    when this method is called. If current document has already reached the required state, resolves immediately.

    ```py
    await frame.click(\&#34;button\&#34;) # click triggers navigation.
    await frame.wait_for_load_state() # the promise resolves after \&#34;load\&#34; event.
    ```

    Parameters
    ----------
    state : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        Optional load state to wait for, defaults to `load`. If the state has been already reached while loading current
        document, the method resolves immediately. Can be one of:
        - `&#39;load&#39;` - wait for the `load` event to be fired.
        - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
        - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.wait_for_load_state started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.wait_for_load_state(state=state, timeout=timeout)
        )
        log_api(&#34;&lt;= frame.wait_for_load_state succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.wait_for_load_state failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.wait_for_navigation"><code class="name flex">
<span>async def <span class="ident">wait_for_navigation</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: float = None) ‑> Union[playwright.async_api._generated.Response, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.wait_for_navigation</p>
<p>Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will
resolve with <code>null</code>.</p>
<p>This method waits for the frame to navigate to a new URL. It is useful for when you run code which will indirectly cause
the frame to navigate. Consider this example:</p>
<pre><code class="language-py">async with frame.expect_navigation():
    await frame.click(&quot;a.delayed-navigation&quot;) # clicking the link will indirectly cause a navigation
# Resolves after navigation has finished
</code></pre>
<blockquote>
<p>NOTE: Usage of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">History API</a> to change the URL is
considered a navigation.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[Callable[[str], bool], Pattern, str, NoneType]</code></dt>
<dd>URL string, URL regex pattern or predicate receiving [URL] to match while waiting for the navigation.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_navigation(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: float = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Frame.wait_for_navigation

    Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
    last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will
    resolve with `null`.

    This method waits for the frame to navigate to a new URL. It is useful for when you run code which will indirectly cause
    the frame to navigate. Consider this example:

    ```py
    async with frame.expect_navigation():
        await frame.click(\&#34;a.delayed-navigation\&#34;) # clicking the link will indirectly cause a navigation
    # Resolves after navigation has finished
    ```

    &gt; NOTE: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is
    considered a navigation.

    Parameters
    ----------
    url : Union[Callable[[str], bool], Pattern, str, NoneType]
        URL string, URL regex pattern or predicate receiving [URL] to match while waiting for the navigation.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.

    Returns
    -------
    Union[Response, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.wait_for_navigation started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.wait_for_navigation(
                url=self._wrap_handler(url), waitUntil=wait_until, timeout=timeout
            )
        )
        log_api(&#34;&lt;= frame.wait_for_navigation succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.wait_for_navigation failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.wait_for_selector"><code class="name flex">
<span>async def <span class="ident">wait_for_selector</span></span>(<span>self, selector: str, timeout: float = None, state: Literal['attached', 'detached', 'hidden', 'visible'] = None) ‑> Union[playwright.async_api._generated.ElementHandle, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.wait_for_selector</p>
<p>Returns when element specified by selector satisfies <code>state</code> option. Returns <code>null</code> if waiting for <code>hidden</code> or
<code>detached</code>.</p>
<p>Wait for the <code>selector</code> to satisfy <code>state</code> option (either appear/disappear from dom, or become visible/hidden). If at
the moment of calling the method <code>selector</code> already satisfies the condition, the method will return immediately. If the
selector doesn't satisfy the condition for the <code>timeout</code> milliseconds, the function will throw.</p>
<p>This method works across navigations:</p>
<pre><code class="language-py">import asyncio
from playwright.async_api import async_playwright

async def run(playwright):
    chromium = playwright.chromium
    browser = await chromium.launch()
    page = await browser.new_page()
    for current_url in [&quot;https://google.com&quot;, &quot;https://bbc.com&quot;]:
        await page.goto(current_url, wait_until=&quot;domcontentloaded&quot;)
        element = await page.main_frame.wait_for_selector(&quot;img&quot;)
        print(&quot;Loaded image: &quot; + str(await element.get_attribute(&quot;src&quot;)))
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>Union["attached", "detached", "hidden", "visible", NoneType]</code></dt>
<dd>Defaults to <code>'visible'</code>. Can be either:
- <code>'attached'</code> - wait for element to be present in DOM.
- <code>'detached'</code> - wait for element to not be present in DOM.
- <code>'visible'</code> - wait for element to have non-empty bounding box and no <code>visibility:hidden</code>. Note that element without
any content or with <code>display:none</code> has an empty bounding box and is not considered visible.
- <code>'hidden'</code> - wait for element to be either detached from DOM, or have an empty bounding box or <code>visibility:hidden</code>.
This is opposite to the <code>'visible'</code> option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_selector(
    self,
    selector: str,
    timeout: float = None,
    state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;Frame.wait_for_selector

    Returns when element specified by selector satisfies `state` option. Returns `null` if waiting for `hidden` or
    `detached`.

    Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at
    the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the
    selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.

    This method works across navigations:

    ```py
    import asyncio
    from playwright.async_api import async_playwright

    async def run(playwright):
        chromium = playwright.chromium
        browser = await chromium.launch()
        page = await browser.new_page()
        for current_url in [\&#34;https://google.com\&#34;, \&#34;https://bbc.com\&#34;]:
            await page.goto(current_url, wait_until=\&#34;domcontentloaded\&#34;)
            element = await page.main_frame.wait_for_selector(\&#34;img\&#34;)
            print(\&#34;Loaded image: \&#34; + str(await element.get_attribute(\&#34;src\&#34;)))
        await browser.close()

    async def main():
        async with async_playwright() as playwright:
            await run(playwright)
    asyncio.run(main())
    ```

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    state : Union[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;, NoneType]
        Defaults to `&#39;visible&#39;`. Can be either:
        - `&#39;attached&#39;` - wait for element to be present in DOM.
        - `&#39;detached&#39;` - wait for element to not be present in DOM.
        - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without
          any content or with `display:none` has an empty bounding box and is not considered visible.
        - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`.
          This is opposite to the `&#39;visible&#39;` option.

    Returns
    -------
    Union[ElementHandle, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.wait_for_selector started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.wait_for_selector(
                selector=selector, timeout=timeout, state=state
            )
        )
        log_api(&#34;&lt;= frame.wait_for_selector succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.wait_for_selector failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Frame.wait_for_timeout"><code class="name flex">
<span>async def <span class="ident">wait_for_timeout</span></span>(<span>self, timeout: float) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Frame.wait_for_timeout</p>
<p>Waits for the given <code>timeout</code> in milliseconds.</p>
<p>Note that <code>frame.waitForTimeout()</code> should only be used for debugging. Tests using the timer in production are going to
be flaky. Use signals such as network events, selectors becoming visible and others instead.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>A timeout to wait for</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_timeout(self, timeout: float) -&gt; NoneType:
    &#34;&#34;&#34;Frame.wait_for_timeout

    Waits for the given `timeout` in milliseconds.

    Note that `frame.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to
    be flaky. Use signals such as network events, selectors becoming visible and others instead.

    Parameters
    ----------
    timeout : float
        A timeout to wait for
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; frame.wait_for_timeout started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.wait_for_timeout(timeout=timeout)
        )
        log_api(&#34;&lt;= frame.wait_for_timeout succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= frame.wait_for_timeout failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Geolocation"><code class="flex name class">
<span>class <span class="ident">Geolocation</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Geolocation(TypedDict, total=False):
    latitude: float
    longitude: float
    accuracy: Optional[float]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.Geolocation.accuracy"><code class="name">var <span class="ident">accuracy</span> : Union[float, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Geolocation.latitude"><code class="name">var <span class="ident">latitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Geolocation.longitude"><code class="name">var <span class="ident">longitude</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.HttpCredentials"><code class="flex name class">
<span>class <span class="ident">HttpCredentials</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HttpCredentials(TypedDict):
    username: str
    password: str</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.HttpCredentials.password"><code class="name">var <span class="ident">password</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.HttpCredentials.username"><code class="name">var <span class="ident">username</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.JSHandle"><code class="flex name class">
<span>class <span class="ident">JSHandle</span></span>
<span>(</span><span>obj: playwright._impl._js_handle.JSHandle)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSHandle(AsyncBase):
    def __init__(self, obj: JSHandleImpl):
        super().__init__(obj)

    async def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;JSHandle.evaluate

        Returns the return value of `pageFunction`

        This method passes this handle as the first argument to `pageFunction`.

        If `pageFunction` returns a [Promise], then `handle.evaluate` would wait for the promise to resolve and return its
        value.

        Examples:

        ```py
        tweet_handle = await page.query_selector(\&#34;.tweet .retweets\&#34;)
        assert await tweet_handle.evaluate(\&#34;node =&gt; node.innerText\&#34;) == \&#34;10 retweets\&#34;
        ```

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; js_handle.evaluate started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= js_handle.evaluate succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= js_handle.evaluate failed&#34;)
            raise e

    async def evaluate_handle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;JSHandle.evaluate_handle

        Returns the return value of `pageFunction` as in-page object (JSHandle).

        This method passes this handle as the first argument to `pageFunction`.

        The only difference between `jsHandle.evaluate` and `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle` returns
        in-page object (JSHandle).

        If the function passed to the `jsHandle.evaluateHandle` returns a [Promise], then `jsHandle.evaluateHandle` would wait
        for the promise to resolve and return its value.

        See `page.evaluate_handle()` for more details.

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        JSHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; js_handle.evaluate_handle started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.evaluate_handle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= js_handle.evaluate_handle succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= js_handle.evaluate_handle failed&#34;)
            raise e

    async def get_property(self, property_name: str) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;JSHandle.get_property

        Fetches a single property from the referenced object.

        Parameters
        ----------
        property_name : str
            property to get

        Returns
        -------
        JSHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; js_handle.get_property started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.get_property(propertyName=property_name)
            )
            log_api(&#34;&lt;= js_handle.get_property succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= js_handle.get_property failed&#34;)
            raise e

    async def get_properties(self) -&gt; typing.Dict[str, &#34;JSHandle&#34;]:
        &#34;&#34;&#34;JSHandle.get_properties

        The method returns a map with **own property names** as keys and JSHandle instances for the property values.

        ```py
        handle = await page.evaluate_handle(\&#34;{window, document}\&#34;)
        properties = await handle.get_properties()
        window_handle = properties.get(\&#34;window\&#34;)
        document_handle = properties.get(\&#34;document\&#34;)
        await handle.dispose()
        ```

        Returns
        -------
        Dict[str, JSHandle]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; js_handle.get_properties started&#34;)
            result = mapping.from_impl_dict(await self._impl_obj.get_properties())
            log_api(&#34;&lt;= js_handle.get_properties succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= js_handle.get_properties failed&#34;)
            raise e

    def as_element(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;JSHandle.as_element

        Returns either `null` or the object handle itself, if the object handle is an instance of `ElementHandle`.

        Returns
        -------
        Union[ElementHandle, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; js_handle.as_element started&#34;)
            result = mapping.from_impl_nullable(self._impl_obj.as_element())
            log_api(&#34;&lt;= js_handle.as_element succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= js_handle.as_element failed&#34;)
            raise e

    async def dispose(self) -&gt; NoneType:
        &#34;&#34;&#34;JSHandle.dispose

        The `jsHandle.dispose` method stops referencing the element handle.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; js_handle.dispose started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.dispose())
            log_api(&#34;&lt;= js_handle.dispose succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= js_handle.dispose failed&#34;)
            raise e

    async def json_value(self) -&gt; typing.Any:
        &#34;&#34;&#34;JSHandle.json_value

        Returns a JSON representation of the object. If the object has a `toJSON` function, it **will not be called**.

        &gt; NOTE: The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an
        error if the object has circular references.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; js_handle.json_value started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.json_value())
            log_api(&#34;&lt;= js_handle.json_value succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= js_handle.json_value failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>playwright.async_api._generated.ElementHandle</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.JSHandle.as_element"><code class="name flex">
<span>def <span class="ident">as_element</span></span>(<span>self) ‑> Union[playwright.async_api._generated.ElementHandle, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.as_element</p>
<p>Returns either <code>null</code> or the object handle itself, if the object handle is an instance of <code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_element(self) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;JSHandle.as_element

    Returns either `null` or the object handle itself, if the object handle is an instance of `ElementHandle`.

    Returns
    -------
    Union[ElementHandle, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; js_handle.as_element started&#34;)
        result = mapping.from_impl_nullable(self._impl_obj.as_element())
        log_api(&#34;&lt;= js_handle.as_element succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= js_handle.as_element failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.JSHandle.dispose"><code class="name flex">
<span>async def <span class="ident">dispose</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.dispose</p>
<p>The <code>jsHandle.dispose</code> method stops referencing the element handle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dispose(self) -&gt; NoneType:
    &#34;&#34;&#34;JSHandle.dispose

    The `jsHandle.dispose` method stops referencing the element handle.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; js_handle.dispose started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.dispose())
        log_api(&#34;&lt;= js_handle.dispose succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= js_handle.dispose failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.JSHandle.evaluate"><code class="name flex">
<span>async def <span class="ident">evaluate</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.evaluate</p>
<p>Returns the return value of <code>pageFunction</code></p>
<p>This method passes this handle as the first argument to <code>pageFunction</code>.</p>
<p>If <code>pageFunction</code> returns a [Promise], then <code>handle.evaluate</code> would wait for the promise to resolve and return its
value.</p>
<p>Examples:</p>
<pre><code class="language-py">tweet_handle = await page.query_selector(&quot;.tweet .retweets&quot;)
assert await tweet_handle.evaluate(&quot;node =&gt; node.innerText&quot;) == &quot;10 retweets&quot;
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def evaluate(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; typing.Any:
    &#34;&#34;&#34;JSHandle.evaluate

    Returns the return value of `pageFunction`

    This method passes this handle as the first argument to `pageFunction`.

    If `pageFunction` returns a [Promise], then `handle.evaluate` would wait for the promise to resolve and return its
    value.

    Examples:

    ```py
    tweet_handle = await page.query_selector(\&#34;.tweet .retweets\&#34;)
    assert await tweet_handle.evaluate(\&#34;node =&gt; node.innerText\&#34;) == \&#34;10 retweets\&#34;
    ```

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; js_handle.evaluate started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.evaluate(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= js_handle.evaluate succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= js_handle.evaluate failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.JSHandle.evaluate_handle"><code class="name flex">
<span>async def <span class="ident">evaluate_handle</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> playwright.async_api._generated.JSHandle</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.evaluate_handle</p>
<p>Returns the return value of <code>pageFunction</code> as in-page object (JSHandle).</p>
<p>This method passes this handle as the first argument to <code>pageFunction</code>.</p>
<p>The only difference between <code>jsHandle.evaluate</code> and <code>jsHandle.evaluateHandle</code> is that <code>jsHandle.evaluateHandle</code> returns
in-page object (JSHandle).</p>
<p>If the function passed to the <code>jsHandle.evaluateHandle</code> returns a [Promise], then <code>jsHandle.evaluateHandle</code> would wait
for the promise to resolve and return its value.</p>
<p>See <code>page.evaluate_handle()</code> for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def evaluate_handle(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;JSHandle.evaluate_handle

    Returns the return value of `pageFunction` as in-page object (JSHandle).

    This method passes this handle as the first argument to `pageFunction`.

    The only difference between `jsHandle.evaluate` and `jsHandle.evaluateHandle` is that `jsHandle.evaluateHandle` returns
    in-page object (JSHandle).

    If the function passed to the `jsHandle.evaluateHandle` returns a [Promise], then `jsHandle.evaluateHandle` would wait
    for the promise to resolve and return its value.

    See `page.evaluate_handle()` for more details.

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    JSHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; js_handle.evaluate_handle started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.evaluate_handle(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= js_handle.evaluate_handle succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= js_handle.evaluate_handle failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.JSHandle.get_properties"><code class="name flex">
<span>async def <span class="ident">get_properties</span></span>(<span>self) ‑> Dict[str, playwright.async_api._generated.JSHandle]</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.get_properties</p>
<p>The method returns a map with <strong>own property names</strong> as keys and JSHandle instances for the property values.</p>
<pre><code class="language-py">handle = await page.evaluate_handle(&quot;{window, document}&quot;)
properties = await handle.get_properties()
window_handle = properties.get(&quot;window&quot;)
document_handle = properties.get(&quot;document&quot;)
await handle.dispose()
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, <a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_properties(self) -&gt; typing.Dict[str, &#34;JSHandle&#34;]:
    &#34;&#34;&#34;JSHandle.get_properties

    The method returns a map with **own property names** as keys and JSHandle instances for the property values.

    ```py
    handle = await page.evaluate_handle(\&#34;{window, document}\&#34;)
    properties = await handle.get_properties()
    window_handle = properties.get(\&#34;window\&#34;)
    document_handle = properties.get(\&#34;document\&#34;)
    await handle.dispose()
    ```

    Returns
    -------
    Dict[str, JSHandle]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; js_handle.get_properties started&#34;)
        result = mapping.from_impl_dict(await self._impl_obj.get_properties())
        log_api(&#34;&lt;= js_handle.get_properties succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= js_handle.get_properties failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.JSHandle.get_property"><code class="name flex">
<span>async def <span class="ident">get_property</span></span>(<span>self, property_name: str) ‑> playwright.async_api._generated.JSHandle</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.get_property</p>
<p>Fetches a single property from the referenced object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property_name</code></strong> :&ensp;<code>str</code></dt>
<dd>property to get</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_property(self, property_name: str) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;JSHandle.get_property

    Fetches a single property from the referenced object.

    Parameters
    ----------
    property_name : str
        property to get

    Returns
    -------
    JSHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; js_handle.get_property started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.get_property(propertyName=property_name)
        )
        log_api(&#34;&lt;= js_handle.get_property succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= js_handle.get_property failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.JSHandle.json_value"><code class="name flex">
<span>async def <span class="ident">json_value</span></span>(<span>self) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>JSHandle.json_value</p>
<p>Returns a JSON representation of the object. If the object has a <code>toJSON</code> function, it <strong>will not be called</strong>.</p>
<blockquote>
<p>NOTE: The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an
error if the object has circular references.</p>
</blockquote>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def json_value(self) -&gt; typing.Any:
    &#34;&#34;&#34;JSHandle.json_value

    Returns a JSON representation of the object. If the object has a `toJSON` function, it **will not be called**.

    &gt; NOTE: The method will return an empty JSON object if the referenced object is not stringifiable. It will throw an
    error if the object has circular references.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; js_handle.json_value started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.json_value())
        log_api(&#34;&lt;= js_handle.json_value succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= js_handle.json_value failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Keyboard"><code class="flex name class">
<span>class <span class="ident">Keyboard</span></span>
<span>(</span><span>obj: playwright._impl._input.Keyboard)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Keyboard(AsyncBase):
    def __init__(self, obj: KeyboardImpl):
        super().__init__(obj)

    async def down(self, key: str) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.down

        Dispatches a `keydown` event.

        `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
        value or a single character to generate the text for. A superset of the `key` values can be found
        [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
        `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

        Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
        texts.

        If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`, subsequent key presses will be sent with that modifier
        active. To release the modifier key, use `keyboard.up()`.

        After the key is pressed once, subsequent calls to `keyboard.down()` will have
        [repeat](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat) set to true. To release the key, use
        `keyboard.up()`.

        &gt; NOTE: Modifier keys DO influence `keyboard.down`. Holding down `Shift` will type the text in upper case.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; keyboard.down started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.down(key=key))
            log_api(&#34;&lt;= keyboard.down succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= keyboard.down failed&#34;)
            raise e

    async def up(self, key: str) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.up

        Dispatches a `keyup` event.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; keyboard.up started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.up(key=key))
            log_api(&#34;&lt;= keyboard.up succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= keyboard.up failed&#34;)
            raise e

    async def insert_text(self, text: str) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.insert_text

        Dispatches only `input` event, does not emit the `keydown`, `keyup` or `keypress` events.

        ```py
        await page.keyboard.insert_text(\&#34;嗨\&#34;)
        ```

        &gt; NOTE: Modifier keys DO NOT effect `keyboard.insertText`. Holding down `Shift` will not type the text in upper case.

        Parameters
        ----------
        text : str
            Sets input to the specified text value.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; keyboard.insert_text started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.insert_text(text=text)
            )
            log_api(&#34;&lt;= keyboard.insert_text succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= keyboard.insert_text failed&#34;)
            raise e

    async def type(self, text: str, delay: float = None) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.type

        Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.

        To press a special key, like `Control` or `ArrowDown`, use `keyboard.press()`.

        ```py
        await page.keyboard.type(\&#34;Hello\&#34;) # types instantly
        await page.keyboard.type(\&#34;World\&#34;, delay=100) # types slower, like a user
        ```

        &gt; NOTE: Modifier keys DO NOT effect `keyboard.type`. Holding down `Shift` will not type the text in upper case.

        Parameters
        ----------
        text : str
            A text to type into a focused element.
        delay : Union[float, NoneType]
            Time to wait between key presses in milliseconds. Defaults to 0.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; keyboard.type started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.type(text=text, delay=delay)
            )
            log_api(&#34;&lt;= keyboard.type succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= keyboard.type failed&#34;)
            raise e

    async def press(self, key: str, delay: float = None) -&gt; NoneType:
        &#34;&#34;&#34;Keyboard.press

        `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
        value or a single character to generate the text for. A superset of the `key` values can be found
        [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
        `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

        Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
        texts.

        Shortcuts such as `key: \&#34;Control+o\&#34;` or `key: \&#34;Control+Shift+T\&#34;` are supported as well. When speficied with the
        modifier, modifier is pressed and being held while the subsequent key is being pressed.

        ```py
        page = await browser.new_page()
        await page.goto(\&#34;https://keycode.info\&#34;)
        await page.keyboard.press(\&#34;a\&#34;)
        await page.screenshot(path=\&#34;a.png\&#34;)
        await page.keyboard.press(\&#34;ArrowLeft\&#34;)
        await page.screenshot(path=\&#34;arrow_left.png\&#34;)
        await page.keyboard.press(\&#34;Shift+O\&#34;)
        await page.screenshot(path=\&#34;o.png\&#34;)
        await browser.close()
        ```

        Shortcut for `keyboard.down()` and `keyboard.up()`.

        Parameters
        ----------
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Union[float, NoneType]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; keyboard.press started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.press(key=key, delay=delay)
            )
            log_api(&#34;&lt;= keyboard.press succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= keyboard.press failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Keyboard.down"><code class="name flex">
<span>async def <span class="ident">down</span></span>(<span>self, key: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.down</p>
<p>Dispatches a <code>keydown</code> event.</p>
<p><code>key</code> can specify the intended <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key">keyboardEvent.key</a>
value or a single character to generate the text for. A superset of the <code>key</code> values can be found
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">here</a>. Examples of the keys are:</p>
<p><code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>,
<code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.</p>
<p>Following modification shortcuts are also supported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.</p>
<p>Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.</p>
<p>If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective
texts.</p>
<p>If <code>key</code> is a modifier key, <code>Shift</code>, <code>Meta</code>, <code>Control</code>, or <code>Alt</code>, subsequent key presses will be sent with that modifier
active. To release the modifier key, use <code>keyboard.up()</code>.</p>
<p>After the key is pressed once, subsequent calls to <code>keyboard.down()</code> will have
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat">repeat</a> set to true. To release the key, use
<code>keyboard.up()</code>.</p>
<blockquote>
<p>NOTE: Modifier keys DO influence <code>keyboard.down</code>. Holding down <code>Shift</code> will type the text in upper case.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def down(self, key: str) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.down

    Dispatches a `keydown` event.

    `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
    value or a single character to generate the text for. A superset of the `key` values can be found
    [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
    `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

    Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
    texts.

    If `key` is a modifier key, `Shift`, `Meta`, `Control`, or `Alt`, subsequent key presses will be sent with that modifier
    active. To release the modifier key, use `keyboard.up()`.

    After the key is pressed once, subsequent calls to `keyboard.down()` will have
    [repeat](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat) set to true. To release the key, use
    `keyboard.up()`.

    &gt; NOTE: Modifier keys DO influence `keyboard.down`. Holding down `Shift` will type the text in upper case.

    Parameters
    ----------
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; keyboard.down started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.down(key=key))
        log_api(&#34;&lt;= keyboard.down succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= keyboard.down failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Keyboard.insert_text"><code class="name flex">
<span>async def <span class="ident">insert_text</span></span>(<span>self, text: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.insert_text</p>
<p>Dispatches only <code>input</code> event, does not emit the <code>keydown</code>, <code>keyup</code> or <code>keypress</code> events.</p>
<pre><code class="language-py">await page.keyboard.insert_text(&quot;嗨&quot;)
</code></pre>
<blockquote>
<p>NOTE: Modifier keys DO NOT effect <code>keyboard.insertText</code>. Holding down <code>Shift</code> will not type the text in upper case.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>Sets input to the specified text value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def insert_text(self, text: str) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.insert_text

    Dispatches only `input` event, does not emit the `keydown`, `keyup` or `keypress` events.

    ```py
    await page.keyboard.insert_text(\&#34;嗨\&#34;)
    ```

    &gt; NOTE: Modifier keys DO NOT effect `keyboard.insertText`. Holding down `Shift` will not type the text in upper case.

    Parameters
    ----------
    text : str
        Sets input to the specified text value.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; keyboard.insert_text started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.insert_text(text=text)
        )
        log_api(&#34;&lt;= keyboard.insert_text succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= keyboard.insert_text failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Keyboard.press"><code class="name flex">
<span>async def <span class="ident">press</span></span>(<span>self, key: str, delay: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.press</p>
<p><code>key</code> can specify the intended <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key">keyboardEvent.key</a>
value or a single character to generate the text for. A superset of the <code>key</code> values can be found
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">here</a>. Examples of the keys are:</p>
<p><code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>,
<code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.</p>
<p>Following modification shortcuts are also supported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.</p>
<p>Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.</p>
<p>If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective
texts.</p>
<p>Shortcuts such as <code>key: "Control+o"</code> or <code>key: "Control+Shift+T"</code> are supported as well. When speficied with the
modifier, modifier is pressed and being held while the subsequent key is being pressed.</p>
<pre><code class="language-py">page = await browser.new_page()
await page.goto(&quot;https://keycode.info&quot;)
await page.keyboard.press(&quot;a&quot;)
await page.screenshot(path=&quot;a.png&quot;)
await page.keyboard.press(&quot;ArrowLeft&quot;)
await page.screenshot(path=&quot;arrow_left.png&quot;)
await page.keyboard.press(&quot;Shift+O&quot;)
await page.screenshot(path=&quot;o.png&quot;)
await browser.close()
</code></pre>
<p>Shortcut for <code>keyboard.down()</code> and <code>keyboard.up()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>keydown</code> and <code>keyup</code> in milliseconds. Defaults to 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def press(self, key: str, delay: float = None) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.press

    `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
    value or a single character to generate the text for. A superset of the `key` values can be found
    [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
    `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

    Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
    texts.

    Shortcuts such as `key: \&#34;Control+o\&#34;` or `key: \&#34;Control+Shift+T\&#34;` are supported as well. When speficied with the
    modifier, modifier is pressed and being held while the subsequent key is being pressed.

    ```py
    page = await browser.new_page()
    await page.goto(\&#34;https://keycode.info\&#34;)
    await page.keyboard.press(\&#34;a\&#34;)
    await page.screenshot(path=\&#34;a.png\&#34;)
    await page.keyboard.press(\&#34;ArrowLeft\&#34;)
    await page.screenshot(path=\&#34;arrow_left.png\&#34;)
    await page.keyboard.press(\&#34;Shift+O\&#34;)
    await page.screenshot(path=\&#34;o.png\&#34;)
    await browser.close()
    ```

    Shortcut for `keyboard.down()` and `keyboard.up()`.

    Parameters
    ----------
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    delay : Union[float, NoneType]
        Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; keyboard.press started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.press(key=key, delay=delay)
        )
        log_api(&#34;&lt;= keyboard.press succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= keyboard.press failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Keyboard.type"><code class="name flex">
<span>async def <span class="ident">type</span></span>(<span>self, text: str, delay: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.type</p>
<p>Sends a <code>keydown</code>, <code>keypress</code>/<code>input</code>, and <code>keyup</code> event for each character in the text.</p>
<p>To press a special key, like <code>Control</code> or <code>ArrowDown</code>, use <code>keyboard.press()</code>.</p>
<pre><code class="language-py">await page.keyboard.type(&quot;Hello&quot;) # types instantly
await page.keyboard.type(&quot;World&quot;, delay=100) # types slower, like a user
</code></pre>
<blockquote>
<p>NOTE: Modifier keys DO NOT effect <code>keyboard.type</code>. Holding down <code>Shift</code> will not type the text in upper case.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>A text to type into a focused element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between key presses in milliseconds. Defaults to 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def type(self, text: str, delay: float = None) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.type

    Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text.

    To press a special key, like `Control` or `ArrowDown`, use `keyboard.press()`.

    ```py
    await page.keyboard.type(\&#34;Hello\&#34;) # types instantly
    await page.keyboard.type(\&#34;World\&#34;, delay=100) # types slower, like a user
    ```

    &gt; NOTE: Modifier keys DO NOT effect `keyboard.type`. Holding down `Shift` will not type the text in upper case.

    Parameters
    ----------
    text : str
        A text to type into a focused element.
    delay : Union[float, NoneType]
        Time to wait between key presses in milliseconds. Defaults to 0.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; keyboard.type started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.type(text=text, delay=delay)
        )
        log_api(&#34;&lt;= keyboard.type succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= keyboard.type failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Keyboard.up"><code class="name flex">
<span>async def <span class="ident">up</span></span>(<span>self, key: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Keyboard.up</p>
<p>Dispatches a <code>keyup</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def up(self, key: str) -&gt; NoneType:
    &#34;&#34;&#34;Keyboard.up

    Dispatches a `keyup` event.

    Parameters
    ----------
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; keyboard.up started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.up(key=key))
        log_api(&#34;&lt;= keyboard.up succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= keyboard.up failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Mouse"><code class="flex name class">
<span>class <span class="ident">Mouse</span></span>
<span>(</span><span>obj: playwright._impl._input.Mouse)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mouse(AsyncBase):
    def __init__(self, obj: MouseImpl):
        super().__init__(obj)

    async def move(self, x: float, y: float, steps: int = None) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.move

        Dispatches a `mousemove` event.

        Parameters
        ----------
        x : float
        y : float
        steps : Union[int, NoneType]
            defaults to 1. Sends intermediate `mousemove` events.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; mouse.move started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.move(x=x, y=y, steps=steps)
            )
            log_api(&#34;&lt;= mouse.move succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= mouse.move failed&#34;)
            raise e

    async def down(
        self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, click_count: int = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.down

        Dispatches a `mousedown` event.

        Parameters
        ----------
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        click_count : Union[int, NoneType]
            defaults to 1. See [UIEvent.detail].
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; mouse.down started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.down(button=button, clickCount=click_count)
            )
            log_api(&#34;&lt;= mouse.down succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= mouse.down failed&#34;)
            raise e

    async def up(
        self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, click_count: int = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.up

        Dispatches a `mouseup` event.

        Parameters
        ----------
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        click_count : Union[int, NoneType]
            defaults to 1. See [UIEvent.detail].
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; mouse.up started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.up(button=button, clickCount=click_count)
            )
            log_api(&#34;&lt;= mouse.up succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= mouse.up failed&#34;)
            raise e

    async def click(
        self,
        x: float,
        y: float,
        delay: float = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        click_count: int = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.click

        Shortcut for `mouse.move()`, `mouse.down()`, `mouse.up()`.

        Parameters
        ----------
        x : float
        y : float
        delay : Union[float, NoneType]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        click_count : Union[int, NoneType]
            defaults to 1. See [UIEvent.detail].
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; mouse.click started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.click(
                    x=x, y=y, delay=delay, button=button, clickCount=click_count
                )
            )
            log_api(&#34;&lt;= mouse.click succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= mouse.click failed&#34;)
            raise e

    async def dblclick(
        self,
        x: float,
        y: float,
        delay: float = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Mouse.dblclick

        Shortcut for `mouse.move()`, `mouse.down()`, `mouse.up()`, `mouse.down()` and
        `mouse.up()`.

        Parameters
        ----------
        x : float
        y : float
        delay : Union[float, NoneType]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; mouse.dblclick started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.dblclick(x=x, y=y, delay=delay, button=button)
            )
            log_api(&#34;&lt;= mouse.dblclick succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= mouse.dblclick failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Mouse.click"><code class="name flex">
<span>async def <span class="ident">click</span></span>(<span>self, x: float, y: float, delay: float = None, button: Literal['left', 'middle', 'right'] = None, click_count: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.click</p>
<p>Shortcut for <code>mouse.move()</code>, <code>mouse.down()</code>, <code>mouse.up()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>click_count</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>defaults to 1. See [UIEvent.detail].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def click(
    self,
    x: float,
    y: float,
    delay: float = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    click_count: int = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.click

    Shortcut for `mouse.move()`, `mouse.down()`, `mouse.up()`.

    Parameters
    ----------
    x : float
    y : float
    delay : Union[float, NoneType]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    click_count : Union[int, NoneType]
        defaults to 1. See [UIEvent.detail].
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; mouse.click started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.click(
                x=x, y=y, delay=delay, button=button, clickCount=click_count
            )
        )
        log_api(&#34;&lt;= mouse.click succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= mouse.click failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Mouse.dblclick"><code class="name flex">
<span>async def <span class="ident">dblclick</span></span>(<span>self, x: float, y: float, delay: float = None, button: Literal['left', 'middle', 'right'] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.dblclick</p>
<p>Shortcut for <code>mouse.move()</code>, <code>mouse.down()</code>, <code>mouse.up()</code>, <code>mouse.down()</code> and
<code>mouse.up()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dblclick(
    self,
    x: float,
    y: float,
    delay: float = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.dblclick

    Shortcut for `mouse.move()`, `mouse.down()`, `mouse.up()`, `mouse.down()` and
    `mouse.up()`.

    Parameters
    ----------
    x : float
    y : float
    delay : Union[float, NoneType]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; mouse.dblclick started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.dblclick(x=x, y=y, delay=delay, button=button)
        )
        log_api(&#34;&lt;= mouse.dblclick succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= mouse.dblclick failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Mouse.down"><code class="name flex">
<span>async def <span class="ident">down</span></span>(<span>self, button: Literal['left', 'middle', 'right'] = None, click_count: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.down</p>
<p>Dispatches a <code>mousedown</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>click_count</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>defaults to 1. See [UIEvent.detail].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def down(
    self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, click_count: int = None
) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.down

    Dispatches a `mousedown` event.

    Parameters
    ----------
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    click_count : Union[int, NoneType]
        defaults to 1. See [UIEvent.detail].
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; mouse.down started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.down(button=button, clickCount=click_count)
        )
        log_api(&#34;&lt;= mouse.down succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= mouse.down failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Mouse.move"><code class="name flex">
<span>async def <span class="ident">move</span></span>(<span>self, x: float, y: float, steps: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.move</p>
<p>Dispatches a <code>mousemove</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>steps</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>defaults to 1. Sends intermediate <code>mousemove</code> events.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def move(self, x: float, y: float, steps: int = None) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.move

    Dispatches a `mousemove` event.

    Parameters
    ----------
    x : float
    y : float
    steps : Union[int, NoneType]
        defaults to 1. Sends intermediate `mousemove` events.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; mouse.move started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.move(x=x, y=y, steps=steps)
        )
        log_api(&#34;&lt;= mouse.move succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= mouse.move failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Mouse.up"><code class="name flex">
<span>async def <span class="ident">up</span></span>(<span>self, button: Literal['left', 'middle', 'right'] = None, click_count: int = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Mouse.up</p>
<p>Dispatches a <code>mouseup</code> event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>click_count</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>defaults to 1. See [UIEvent.detail].</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def up(
    self, button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None, click_count: int = None
) -&gt; NoneType:
    &#34;&#34;&#34;Mouse.up

    Dispatches a `mouseup` event.

    Parameters
    ----------
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    click_count : Union[int, NoneType]
        defaults to 1. See [UIEvent.detail].
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; mouse.up started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.up(button=button, clickCount=click_count)
        )
        log_api(&#34;&lt;= mouse.up succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= mouse.up failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Page"><code class="flex name class">
<span>class <span class="ident">Page</span></span>
<span>(</span><span>obj: playwright._impl._page.Page)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Page(AsyncBase):
    def __init__(self, obj: PageImpl):
        super().__init__(obj)

    @property
    def accessibility(self) -&gt; &#34;Accessibility&#34;:
        &#34;&#34;&#34;Page.accessibility

        Returns
        -------
        Accessibility
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.accessibility)

    @property
    def keyboard(self) -&gt; &#34;Keyboard&#34;:
        &#34;&#34;&#34;Page.keyboard

        Returns
        -------
        Keyboard
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.keyboard)

    @property
    def mouse(self) -&gt; &#34;Mouse&#34;:
        &#34;&#34;&#34;Page.mouse

        Returns
        -------
        Mouse
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.mouse)

    @property
    def touchscreen(self) -&gt; &#34;Touchscreen&#34;:
        &#34;&#34;&#34;Page.touchscreen

        Returns
        -------
        Touchscreen
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.touchscreen)

    @property
    def context(self) -&gt; &#34;BrowserContext&#34;:
        &#34;&#34;&#34;Page.context

        Get the browser context that the page belongs to.

        Returns
        -------
        BrowserContext
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.context)

    @property
    def main_frame(self) -&gt; &#34;Frame&#34;:
        &#34;&#34;&#34;Page.main_frame

        The page&#39;s main frame. Page is guaranteed to have a main frame which persists during navigations.

        Returns
        -------
        Frame
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.main_frame)

    @property
    def frames(self) -&gt; typing.List[&#34;Frame&#34;]:
        &#34;&#34;&#34;Page.frames

        An array of all frames attached to the page.

        Returns
        -------
        List[Frame]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.frames)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Page.url

        Shortcut for main frame&#39;s `frame.url()`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def viewport_size(self) -&gt; typing.Union[ViewportSize, NoneType]:
        &#34;&#34;&#34;Page.viewport_size

        Returns
        -------
        Union[{width: int, height: int}, NoneType]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.viewport_size)

    @property
    def workers(self) -&gt; typing.List[&#34;Worker&#34;]:
        &#34;&#34;&#34;Page.workers

        This method returns all of the dedicated [WebWorkers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
        associated with the page.

        &gt; NOTE: This does not contain ServiceWorkers

        Returns
        -------
        List[Worker]
        &#34;&#34;&#34;
        return mapping.from_impl_list(self._impl_obj.workers)

    @property
    def video(self) -&gt; typing.Union[&#34;Video&#34;, NoneType]:
        &#34;&#34;&#34;Page.video

        Video object associated with this page.

        Returns
        -------
        Union[Video, NoneType]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.video)

    async def opener(self) -&gt; typing.Union[&#34;Page&#34;, NoneType]:
        &#34;&#34;&#34;Page.opener

        Returns the opener for popup pages and `null` for others. If the opener has been closed already the returns `null`.

        Returns
        -------
        Union[Page, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.opener started&#34;)
            result = mapping.from_impl_nullable(await self._impl_obj.opener())
            log_api(&#34;&lt;= page.opener succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.opener failed&#34;)
            raise e

    def frame(
        self,
        name: str = None,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    ) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
        &#34;&#34;&#34;Page.frame

        Returns frame matching the specified criteria. Either `name` or `url` must be specified.

        ```py
        frame = page.frame(name=\&#34;frame-name\&#34;)
        ```

        ```py
        frame = page.frame(url=r\&#34;.*domain.*\&#34;)
        ```

        Parameters
        ----------
        name : Union[str, NoneType]
            Frame name specified in the `iframe`&#39;s `name` attribute. Optional.
        url : Union[Callable[[str], bool], Pattern, str, NoneType]
            A glob pattern, regex pattern or predicate receiving frame&#39;s `url` as a [URL] object. Optional.

        Returns
        -------
        Union[Frame, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.frame started&#34;)
            result = mapping.from_impl_nullable(
                self._impl_obj.frame(name=name, url=self._wrap_handler(url))
            )
            log_api(&#34;&lt;= page.frame succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.frame failed&#34;)
            raise e

    def set_default_navigation_timeout(self, timeout: float) -&gt; NoneType:
        &#34;&#34;&#34;Page.set_default_navigation_timeout

        This setting will change the default maximum navigation time for the following methods and related shortcuts:
        - `page.go_back()`
        - `page.go_forward()`
        - `page.goto()`
        - `page.reload()`
        - `page.set_content()`
        - `page.wait_for_navigation()`

        &gt; NOTE: `page.set_default_navigation_timeout()` takes priority over `page.set_default_timeout()`,
        `browser_context.set_default_timeout()` and `browser_context.set_default_navigation_timeout()`.

        Parameters
        ----------
        timeout : float
            Maximum navigation time in milliseconds
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.set_default_navigation_timeout started&#34;)
            result = mapping.from_maybe_impl(
                self._impl_obj.set_default_navigation_timeout(timeout=timeout)
            )
            log_api(&#34;&lt;= page.set_default_navigation_timeout succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.set_default_navigation_timeout failed&#34;)
            raise e

    def set_default_timeout(self, timeout: float) -&gt; NoneType:
        &#34;&#34;&#34;Page.set_default_timeout

        This setting will change the default maximum time for all the methods accepting `timeout` option.

        &gt; NOTE: `page.set_default_navigation_timeout()` takes priority over `page.set_default_timeout()`.

        Parameters
        ----------
        timeout : float
            Maximum time in milliseconds
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.set_default_timeout started&#34;)
            result = mapping.from_maybe_impl(
                self._impl_obj.set_default_timeout(timeout=timeout)
            )
            log_api(&#34;&lt;= page.set_default_timeout succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.set_default_timeout failed&#34;)
            raise e

    async def query_selector(
        self, selector: str
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Page.query_selector

        The method finds an element matching the specified selector within the page. If no elements match the selector, the
        return value resolves to `null`.

        Shortcut for main frame&#39;s `frame.$()`.

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

        Returns
        -------
        Union[ElementHandle, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.query_selector started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.query_selector(selector=selector)
            )
            log_api(&#34;&lt;= page.query_selector succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.query_selector failed&#34;)
            raise e

    async def query_selector_all(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
        &#34;&#34;&#34;Page.query_selector_all

        The method finds all elements matching the specified selector within the page. If no elements match the selector, the
        return value resolves to `[]`.

        Shortcut for main frame&#39;s `frame.$$()`.

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

        Returns
        -------
        List[ElementHandle]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.query_selector_all started&#34;)
            result = mapping.from_impl_list(
                await self._impl_obj.query_selector_all(selector=selector)
            )
            log_api(&#34;&lt;= page.query_selector_all succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.query_selector_all failed&#34;)
            raise e

    async def wait_for_selector(
        self,
        selector: str,
        timeout: float = None,
        state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
    ) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
        &#34;&#34;&#34;Page.wait_for_selector

        Returns when element specified by selector satisfies `state` option. Returns `null` if waiting for `hidden` or
        `detached`.

        Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at
        the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the
        selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.

        This method works across navigations:

        ```py
        import asyncio
        from playwright.async_api import async_playwright

        async def run(playwright):
            chromium = playwright.chromium
            browser = await chromium.launch()
            page = await browser.new_page()
            for current_url in [\&#34;https://google.com\&#34;, \&#34;https://bbc.com\&#34;]:
                await page.goto(current_url, wait_until=\&#34;domcontentloaded\&#34;)
                element = await page.wait_for_selector(\&#34;img\&#34;)
                print(\&#34;Loaded image: \&#34; + str(await element.get_attribute(\&#34;src\&#34;)))
            await browser.close()

        async def main():
            async with async_playwright() as playwright:
                await run(playwright)
        asyncio.run(main())
        ```

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        state : Union[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;, NoneType]
            Defaults to `&#39;visible&#39;`. Can be either:
            - `&#39;attached&#39;` - wait for element to be present in DOM.
            - `&#39;detached&#39;` - wait for element to not be present in DOM.
            - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without
              any content or with `display:none` has an empty bounding box and is not considered visible.
            - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`.
              This is opposite to the `&#39;visible&#39;` option.

        Returns
        -------
        Union[ElementHandle, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.wait_for_selector started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.wait_for_selector(
                    selector=selector, timeout=timeout, state=state
                )
            )
            log_api(&#34;&lt;= page.wait_for_selector succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.wait_for_selector failed&#34;)
            raise e

    async def is_checked(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Page.is_checked

        Returns whether the element is checked. Throws if the element is not a checkbox or radio input.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.is_checked started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_checked(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.is_checked succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.is_checked failed&#34;)
            raise e

    async def is_disabled(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Page.is_disabled

        Returns whether the element is disabled, the opposite of [enabled](./actionability.md#enabled).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.is_disabled started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_disabled(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.is_disabled succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.is_disabled failed&#34;)
            raise e

    async def is_editable(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Page.is_editable

        Returns whether the element is [editable](./actionability.md#editable).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.is_editable started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_editable(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.is_editable succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.is_editable failed&#34;)
            raise e

    async def is_enabled(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Page.is_enabled

        Returns whether the element is [enabled](./actionability.md#enabled).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.is_enabled started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_enabled(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.is_enabled succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.is_enabled failed&#34;)
            raise e

    async def is_hidden(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Page.is_hidden

        Returns whether the element is hidden, the opposite of [visible](./actionability.md#visible).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.is_hidden started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_hidden(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.is_hidden succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.is_hidden failed&#34;)
            raise e

    async def is_visible(self, selector: str, timeout: float = None) -&gt; bool:
        &#34;&#34;&#34;Page.is_visible

        Returns whether the element is [visible](./actionability.md#visible).

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.is_visible started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.is_visible(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.is_visible succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.is_visible failed&#34;)
            raise e

    async def dispatch_event(
        self,
        selector: str,
        type: str,
        event_init: typing.Dict = None,
        timeout: float = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.dispatch_event

        The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click`
        is dispatched. This is equivalend to calling
        [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

        ```py
        await page.dispatch_event(\&#34;button#submit\&#34;, \&#34;click\&#34;)
        ```

        Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties
        and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.

        Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:
        - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
        - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
        - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
        - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
        - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
        - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
        - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)

        You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

        ```py
        # note you can only create data_transfer in chromium and firefox
        data_transfer = await page.evaluate_handle(\&#34;new DataTransfer()\&#34;)
        await page.dispatch_event(\&#34;#source\&#34;, \&#34;dragstart\&#34;, { \&#34;dataTransfer\&#34;: data_transfer })
        ```

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        type : str
            DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
        event_init : Union[Dict, NoneType]
            Optional event-specific initialization properties.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.dispatch_event started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.dispatch_event(
                    selector=selector,
                    type=type,
                    eventInit=mapping.to_impl(event_init),
                    timeout=timeout,
                )
            )
            log_api(&#34;&lt;= page.dispatch_event succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.dispatch_event failed&#34;)
            raise e

    async def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.evaluate

        Returns the value of the `pageFunction` invocation.

        If the function passed to the `page.evaluate()` returns a [Promise], then `page.evaluate()` would wait
        for the promise to resolve and return its value.

        If the function passed to the `page.evaluate()` returns a non-[Serializable] value,
        then[ method: `Page.evaluate`] resolves to `undefined`. DevTools Protocol also supports transferring some additional
        values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.

        Passing argument to `pageFunction`:

        ```py
        result = await page.evaluate(\&#34;([x, y]) =&gt; Promise.resolve(x * y)\&#34;, [7, 8])
        print(result) # prints \&#34;56\&#34;
        ```

        A string can also be passed in instead of a function:

        ```py
        print(await page.evaluate(\&#34;1 + 2\&#34;)) # prints \&#34;3\&#34;
        x = 10
        print(await page.evaluate(f\&#34;1 + {x}\&#34;)) # prints \&#34;11\&#34;
        ```

        `ElementHandle` instances can be passed as an argument to the `page.evaluate()`:

        ```py
        body_handle = await page.query_selector(\&#34;body\&#34;)
        html = await page.evaluate(\&#34;([body, suffix]) =&gt; body.innerHTML + suffix\&#34;, [body_handle, \&#34;hello\&#34;])
        await body_handle.dispose()
        ```

        Shortcut for main frame&#39;s `frame.evaluate()`.

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.evaluate started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= page.evaluate succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.evaluate failed&#34;)
            raise e

    async def evaluate_handle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Page.evaluate_handle

        Returns the value of the `pageFunction` invocation as in-page object (JSHandle).

        The only difference between `page.evaluate()` and `page.evaluate_handle()` is that
        `page.evaluate_handle()` returns in-page object (JSHandle).

        If the function passed to the `page.evaluate_handle()` returns a [Promise], then [`method:Ppage.EvaluateHandle`]
        would wait for the promise to resolve and return its value.

        ```py
        # FIXME
        a_window_handle = await page.evaluate_handle(\&#34;Promise.resolve(window)\&#34;)
        a_window_handle # handle for the window object.
        ```

        A string can also be passed in instead of a function:

        ```py
        a_handle = await page.evaluate_handle(\&#34;document\&#34;) # handle for the \&#34;document\&#34;
        ```

        `JSHandle` instances can be passed as an argument to the `page.evaluate_handle()`:

        ```py
        a_handle = await page.evaluate_handle(\&#34;document.body\&#34;)
        result_handle = await page.evaluate_handle(\&#34;body =&gt; body.innerHTML\&#34;, a_handle)
        print(await result_handle.json_value())
        await result_handle.dispose()
        ```

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        JSHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.evaluate_handle started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.evaluate_handle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= page.evaluate_handle succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.evaluate_handle failed&#34;)
            raise e

    async def eval_on_selector(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.eval_on_selector

        The method finds an element matching the specified selector within the page and passes it as a first argument to
        `pageFunction`. If no elements match the selector, the method throws an error. Returns the value of `pageFunction`.

        If `pageFunction` returns a [Promise], then `page.$eval()` would wait for the promise to resolve and return its
        value.

        Examples:

        ```py
        search_value = await page.eval_on_selector(\&#34;#search\&#34;, \&#34;el =&gt; el.value\&#34;)
        preload_href = await page.eval_on_selector(\&#34;link[rel=preload]\&#34;, \&#34;el =&gt; el.href\&#34;)
        html = await page.eval_on_selector(\&#34;.main-container\&#34;, \&#34;(e, suffix) =&gt; e.outer_html + suffix\&#34;, \&#34;hello\&#34;)
        ```

        Shortcut for main frame&#39;s `frame.$eval()`.

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.eval_on_selector started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.eval_on_selector(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= page.eval_on_selector succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.eval_on_selector failed&#34;)
            raise e

    async def eval_on_selector_all(
        self,
        selector: str,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.eval_on_selector_all

        The method finds all elements matching the specified selector within the page and passes an array of matched elements as
        a first argument to `pageFunction`. Returns the result of `pageFunction` invocation.

        If `pageFunction` returns a [Promise], then `page.$$eval()` would wait for the promise to resolve and return its
        value.

        Examples:

        ```py
        div_counts = await page.eval_on_selector_all(\&#34;div\&#34;, \&#34;(divs, min) =&gt; divs.length &gt;= min\&#34;, 10)
        ```

        Parameters
        ----------
        selector : str
            A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.eval_on_selector_all started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.eval_on_selector_all(
                    selector=selector,
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= page.eval_on_selector_all succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.eval_on_selector_all failed&#34;)
            raise e

    async def add_script_tag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
        type: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Page.add_script_tag

        Adds a `&lt;script&gt;` tag into the page with the desired url or content. Returns the added tag when the script&#39;s onload
        fires or when the script content was injected into frame.

        Shortcut for main frame&#39;s `frame.add_script_tag()`.

        Parameters
        ----------
        url : Union[str, NoneType]
            URL of a script to be added.
        path : Union[pathlib.Path, str, NoneType]
            Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to the
            current working directory.
        content : Union[str, NoneType]
            Raw JavaScript content to be injected into frame.
        type : Union[str, NoneType]
            Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See
            [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) for more details.

        Returns
        -------
        ElementHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.add_script_tag started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.add_script_tag(
                    url=url, path=path, content=content, type=type
                )
            )
            log_api(&#34;&lt;= page.add_script_tag succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.add_script_tag failed&#34;)
            raise e

    async def add_style_tag(
        self,
        url: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content: str = None,
    ) -&gt; &#34;ElementHandle&#34;:
        &#34;&#34;&#34;Page.add_style_tag

        Adds a `&lt;link rel=\&#34;stylesheet\&#34;&gt;` tag into the page with the desired url or a `&lt;style type=\&#34;text/css\&#34;&gt;` tag with the
        content. Returns the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.

        Shortcut for main frame&#39;s `frame.add_style_tag()`.

        Parameters
        ----------
        url : Union[str, NoneType]
            URL of the `&lt;link&gt;` tag.
        path : Union[pathlib.Path, str, NoneType]
            Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to the
            current working directory.
        content : Union[str, NoneType]
            Raw CSS content to be injected into frame.

        Returns
        -------
        ElementHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.add_style_tag started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.add_style_tag(url=url, path=path, content=content)
            )
            log_api(&#34;&lt;= page.add_style_tag succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.add_style_tag failed&#34;)
            raise e

    async def expose_function(self, name: str, callback: typing.Callable) -&gt; NoneType:
        &#34;&#34;&#34;Page.expose_function

        The method adds a function called `name` on the `window` object of every frame in the page. When called, the function
        executes `callback` and returns a [Promise] which resolves to the return value of `callback`.

        If the `callback` returns a [Promise], it will be awaited.

        See `browser_context.expose_function()` for context-wide exposed function.

        &gt; NOTE: Functions installed via `page.expose_function()` survive navigations.

        An example of adding an `sha1` function to the page:

        ```py
        import asyncio
        import hashlib
        from playwright.async_api import async_playwright

        async def sha1(text):
            m = hashlib.sha1()
            m.update(bytes(text, \&#34;utf8\&#34;))
            return m.hexdigest()

        async def run(playwright):
            webkit = playwright.webkit
            browser = await webkit.launch(headless=False)
            page = await browser.new_page()
            await page.expose_function(\&#34;sha1\&#34;, sha1)
            await page.set_content(\&#34;\&#34;\&#34;
                &lt;script&gt;
                  async function onClick() {
                    document.querySelector(&#39;div&#39;).textContent = await window.sha1(&#39;PLAYWRIGHT&#39;);
                  }
                &lt;/script&gt;
                &lt;button onclick=\&#34;onClick()\&#34;&gt;Click me&lt;/button&gt;
                &lt;div&gt;&lt;/div&gt;
            \&#34;\&#34;\&#34;)
            await page.click(\&#34;button\&#34;)

        async def main():
            async with async_playwright() as playwright:
                await run(playwright)
        asyncio.run(main())
        ```

        Parameters
        ----------
        name : str
            Name of the function on the window object
        callback : Callable
            Callback function which will be called in Playwright&#39;s context.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.expose_function started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.expose_function(
                    name=name, callback=self._wrap_handler(callback)
                )
            )
            log_api(&#34;&lt;= page.expose_function succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.expose_function failed&#34;)
            raise e

    async def expose_binding(
        self, name: str, callback: typing.Callable, handle: bool = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.expose_binding

        The method adds a function called `name` on the `window` object of every frame in this page. When called, the function
        executes `callback` and returns a [Promise] which resolves to the return value of `callback`. If the `callback` returns
        a [Promise], it will be awaited.

        The first argument of the `callback` function contains information about the caller: `{ browserContext: BrowserContext,
        page: Page, frame: Frame }`.

        See `browser_context.expose_binding()` for the context-wide version.

        &gt; NOTE: Functions installed via `page.expose_binding()` survive navigations.

        An example of exposing page URL to all frames in a page:

        ```py
        import asyncio
        from playwright.async_api import async_playwright

        async def run(playwright):
            webkit = playwright.webkit
            browser = await webkit.launch(headless=false)
            context = await browser.new_context()
            page = await context.new_page()
            await page.expose_binding(\&#34;pageURL\&#34;, lambda source: source[\&#34;page\&#34;].url)
            await page.set_content(\&#34;\&#34;\&#34;
            &lt;script&gt;
              async function onClick() {
                document.querySelector(&#39;div&#39;).textContent = await window.pageURL();
              }
            &lt;/script&gt;
            &lt;button onclick=\&#34;onClick()\&#34;&gt;Click me&lt;/button&gt;
            &lt;div&gt;&lt;/div&gt;
            \&#34;\&#34;\&#34;)
            await page.click(\&#34;button\&#34;)

        async def main():
            async with async_playwright() as playwright:
                await run(playwright)
        asyncio.run(main())
        ```

        An example of passing an element handle:

        ```py
        async def print(source, element):
            print(await element.text_content())

        await page.expose_binding(\&#34;clicked\&#34;, print, handle=true)
        await page.set_content(\&#34;\&#34;\&#34;
          &lt;script&gt;
            document.addEventListener(&#39;click&#39;, event =&gt; window.clicked(event.target));
          &lt;/script&gt;
          &lt;div&gt;Click me&lt;/div&gt;
          &lt;div&gt;Or click me&lt;/div&gt;
        \&#34;\&#34;\&#34;)
        ```

        Parameters
        ----------
        name : str
            Name of the function on the window object.
        callback : Callable
            Callback function that will be called in the Playwright&#39;s context.
        handle : Union[bool, NoneType]
            Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is
            supported. When passing by value, multiple arguments are supported.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.expose_binding started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.expose_binding(
                    name=name, callback=self._wrap_handler(callback), handle=handle
                )
            )
            log_api(&#34;&lt;= page.expose_binding succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.expose_binding failed&#34;)
            raise e

    async def set_extra_http_headers(self, headers: typing.Dict[str, str]) -&gt; NoneType:
        &#34;&#34;&#34;Page.set_extra_http_headers

        The extra HTTP headers will be sent with every request the page initiates.

        &gt; NOTE: `page.set_extra_http_headers()` does not guarantee the order of headers in the outgoing requests.

        Parameters
        ----------
        headers : Dict[str, str]
            An object containing additional HTTP headers to be sent with every request. All header values must be strings.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.set_extra_http_headers started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_extra_http_headers(
                    headers=mapping.to_impl(headers)
                )
            )
            log_api(&#34;&lt;= page.set_extra_http_headers succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.set_extra_http_headers failed&#34;)
            raise e

    async def content(self) -&gt; str:
        &#34;&#34;&#34;Page.content

        Gets the full HTML contents of the page, including the doctype.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.content started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.content())
            log_api(&#34;&lt;= page.content succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.content failed&#34;)
            raise e

    async def set_content(
        self,
        html: str,
        timeout: float = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.set_content

        Parameters
        ----------
        html : str
            HTML markup to assign to the page.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.set_content started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_content(
                    html=html, timeout=timeout, waitUntil=wait_until
                )
            )
            log_api(&#34;&lt;= page.set_content succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.set_content failed&#34;)
            raise e

    async def goto(
        self,
        url: str,
        timeout: float = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        referer: str = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.goto

        Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
        last redirect.

        `page.goto` will throw an error if:
        - there&#39;s an SSL error (e.g. in case of self-signed certificates).
        - target URL is invalid.
        - the `timeout` is exceeded during navigation.
        - the remote server does not respond or is unreachable.
        - the main resource failed to load.

        `page.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 \&#34;Not
        Found\&#34; and 500 \&#34;Internal Server Error\&#34;.  The status code for such responses can be retrieved by calling
        `response.status()`.

        &gt; NOTE: `page.goto` either throws an error or returns a main resource response. The only exceptions are navigation to
        `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
        &gt; NOTE: Headless mode doesn&#39;t support navigation to a PDF document. See the
        [upstream issue](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).

        Shortcut for main frame&#39;s `frame.goto()`

        Parameters
        ----------
        url : str
            URL to navigate page to. The url should include scheme, e.g. `https://`.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
        referer : Union[str, NoneType]
            Referer header value. If provided it will take preference over the referer header value set by
            `page.set_extra_http_headers()`.

        Returns
        -------
        Union[Response, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.goto started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.goto(
                    url=url, timeout=timeout, waitUntil=wait_until, referer=referer
                )
            )
            log_api(&#34;&lt;= page.goto succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.goto failed&#34;)
            raise e

    async def reload(
        self,
        timeout: float = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.reload

        Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
        last redirect.

        Parameters
        ----------
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.

        Returns
        -------
        Union[Response, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.reload started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.reload(timeout=timeout, waitUntil=wait_until)
            )
            log_api(&#34;&lt;= page.reload succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.reload failed&#34;)
            raise e

    async def wait_for_load_state(
        self,
        state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: float = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.wait_for_load_state

        Returns when the required load state has been reached.

        This resolves when the page reaches a required load state, `load` by default. The navigation must have been committed
        when this method is called. If current document has already reached the required state, resolves immediately.

        ```py
        await page.click(\&#34;button\&#34;) # click triggers navigation.
        await page.wait_for_load_state() # the promise resolves after \&#34;load\&#34; event.
        ```

        ```py
        async with page.expect_popup() as page_info:
            await page.click(\&#34;button\&#34;) # click triggers a popup.
        popup = await page_info.value
         # Following resolves after \&#34;domcontentloaded\&#34; event.
        await popup.wait_for_load_state(\&#34;domcontentloaded\&#34;)
        print(await popup.title()) # popup is ready to use.
        ```

        Shortcut for main frame&#39;s `frame.wait_for_load_state()`.

        Parameters
        ----------
        state : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            Optional load state to wait for, defaults to `load`. If the state has been already reached while loading current
            document, the method resolves immediately. Can be one of:
            - `&#39;load&#39;` - wait for the `load` event to be fired.
            - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
            - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.wait_for_load_state started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.wait_for_load_state(state=state, timeout=timeout)
            )
            log_api(&#34;&lt;= page.wait_for_load_state succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.wait_for_load_state failed&#34;)
            raise e

    async def wait_for_navigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: float = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.wait_for_navigation

        Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
        last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will
        resolve with `null`.

        This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
        cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`.
        Consider this example:

        ```py
        async with page.expect_navigation():
            await page.click(\&#34;a.delayed-navigation\&#34;) # clicking the link will indirectly cause a navigation
        # Resolves after navigation has finished
        ```

        &gt; NOTE: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is
        considered a navigation.

        Shortcut for main frame&#39;s `frame.wait_for_navigation()`.

        Parameters
        ----------
        url : Union[Callable[[str], bool], Pattern, str, NoneType]
            A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.

        Returns
        -------
        Union[Response, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.wait_for_navigation started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.wait_for_navigation(
                    url=self._wrap_handler(url), waitUntil=wait_until, timeout=timeout
                )
            )
            log_api(&#34;&lt;= page.wait_for_navigation succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.wait_for_navigation failed&#34;)
            raise e

    async def wait_for_request(
        self,
        url_or_predicate: typing.Union[
            str, typing.Pattern, typing.Callable[[&#34;Request&#34;], bool]
        ],
        timeout: float = None,
    ) -&gt; &#34;Request&#34;:
        &#34;&#34;&#34;Page.wait_for_request

        Waits for the matching request and returns it.

        ```py
        first_request = await page.wait_for_request(\&#34;http://example.com/resource\&#34;)
        final_request = await page.wait_for_request(lambda request: request.url == \&#34;http://example.com\&#34; and request.method == \&#34;get\&#34;)
        return first_request.url
        ```

        Parameters
        ----------
        url_or_predicate : Union[Callable[[Request], bool], Pattern, str]
            Request URL string, regex or predicate receiving `Request` object.
        timeout : Union[float, NoneType]
            Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be
            changed by using the `page.set_default_timeout()` method.

        Returns
        -------
        Request
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.wait_for_request started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.wait_for_request(
                    urlOrPredicate=self._wrap_handler(url_or_predicate), timeout=timeout
                )
            )
            log_api(&#34;&lt;= page.wait_for_request succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.wait_for_request failed&#34;)
            raise e

    async def wait_for_response(
        self,
        url_or_predicate: typing.Union[
            str, typing.Pattern, typing.Callable[[&#34;Response&#34;], bool]
        ],
        timeout: float = None,
    ) -&gt; &#34;Response&#34;:
        &#34;&#34;&#34;Page.wait_for_response

        Returns the matched response.

        ```py
        first_response = await page.wait_for_response(\&#34;https://example.com/resource\&#34;)
        final_response = await page.wait_for_response(lambda response: response.url == \&#34;https://example.com\&#34; and response.status === 200)
        return final_response.ok
        ```

        Parameters
        ----------
        url_or_predicate : Union[Callable[[Response], bool], Pattern, str]
            Request URL string, regex or predicate receiving `Response` object.
        timeout : Union[float, NoneType]
            Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be
            changed by using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        Response
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.wait_for_response started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.wait_for_response(
                    urlOrPredicate=self._wrap_handler(url_or_predicate), timeout=timeout
                )
            )
            log_api(&#34;&lt;= page.wait_for_response succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.wait_for_response failed&#34;)
            raise e

    async def wait_for_event(
        self, event: str, predicate: typing.Callable = None, timeout: float = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Page.wait_for_event

        Returns the event data value.

        Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
        value. Will throw an error if the page is closed before the event is fired.

        Parameters
        ----------
        event : str
            Event name, same one typically passed into `*.on(event)`.
        predicate : Union[Callable, NoneType]
            Receives the event data and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.wait_for_event started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.wait_for_event(
                    event=event,
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
            log_api(&#34;&lt;= page.wait_for_event succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.wait_for_event failed&#34;)
            raise e

    async def go_back(
        self,
        timeout: float = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.go_back

        Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
        last redirect. If can not go back, returns `null`.

        Navigate to the previous page in history.

        Parameters
        ----------
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.

        Returns
        -------
        Union[Response, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.go_back started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.go_back(timeout=timeout, waitUntil=wait_until)
            )
            log_api(&#34;&lt;= page.go_back succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.go_back failed&#34;)
            raise e

    async def go_forward(
        self,
        timeout: float = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    ) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Page.go_forward

        Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
        last redirect. If can not go forward, returns `null`.

        Navigate to the next page in history.

        Parameters
        ----------
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.

        Returns
        -------
        Union[Response, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.go_forward started&#34;)
            result = mapping.from_impl_nullable(
                await self._impl_obj.go_forward(timeout=timeout, waitUntil=wait_until)
            )
            log_api(&#34;&lt;= page.go_forward succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.go_forward failed&#34;)
            raise e

    async def emulate_media(
        self,
        media: Literal[&#34;print&#34;, &#34;screen&#34;] = None,
        color_scheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.emulate_media

        ```py
        await page.evaluate(\&#34;matchMedia(&#39;screen&#39;).matches\&#34;)
        # → True
        await page.evaluate(\&#34;matchMedia(&#39;print&#39;).matches\&#34;)
        # → False

        await page.emulate_media(media=\&#34;print\&#34;)
        await page.evaluate(\&#34;matchMedia(&#39;screen&#39;).matches\&#34;)
        # → False
        await page.evaluate(\&#34;matchMedia(&#39;print&#39;).matches\&#34;)
        # → True

        await page.emulate_media()
        await page.evaluate(\&#34;matchMedia(&#39;screen&#39;).matches\&#34;)
        # → True
        await page.evaluate(\&#34;matchMedia(&#39;print&#39;).matches\&#34;)
        # → False
        ```

        ```py
        await page.emulate_media(color_scheme=\&#34;dark\&#34;)
        await page.evaluate(\&#34;matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches\&#34;)
        # → True
        await page.evaluate(\&#34;matchMedia(&#39;(prefers-color-scheme: light)&#39;).matches\&#34;)
        # → False
        await page.evaluate(\&#34;matchMedia(&#39;(prefers-color-scheme: no-preference)&#39;).matches\&#34;)
        # → False
        ```

        Parameters
        ----------
        media : Union[&#34;print&#34;, &#34;screen&#34;, NoneType]
            Changes the CSS media type of the page. The only allowed values are `&#39;screen&#39;`, `&#39;print&#39;` and `null`. Passing `null`
            disables CSS media emulation. Omitting `media` or passing `undefined` does not change the emulated value. Optional.
        color_scheme : Union[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;, NoneType]
            Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. Passing
            `null` disables color scheme emulation. Omitting `colorScheme` or passing `undefined` does not change the emulated
            value. Optional.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.emulate_media started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.emulate_media(
                    media=media, colorScheme=color_scheme
                )
            )
            log_api(&#34;&lt;= page.emulate_media succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.emulate_media failed&#34;)
            raise e

    async def set_viewport_size(self, viewport_size: ViewportSize) -&gt; NoneType:
        &#34;&#34;&#34;Page.set_viewport_size

        In the case of multiple pages in a single browser, each page can have its own viewport size. However,
        `browser.new_context()` allows to set viewport size (and more) for all pages in the context at once.

        `page.setViewportSize` will resize the page. A lot of websites don&#39;t expect phones to change size, so you should set the
        viewport size before navigating to the page.

        ```py
        page = await browser.new_page()
        await page.set_viewport_size({\&#34;width\&#34;: 640, \&#34;height\&#34;: 480})
        await page.goto(\&#34;https://example.com\&#34;)
        ```

        Parameters
        ----------
        viewport_size : {width: int, height: int}
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.set_viewport_size started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_viewport_size(viewportSize=viewport_size)
            )
            log_api(&#34;&lt;= page.set_viewport_size succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.set_viewport_size failed&#34;)
            raise e

    async def bring_to_front(self) -&gt; NoneType:
        &#34;&#34;&#34;Page.bring_to_front

        Brings page to front (activates tab).
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.bring_to_front started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.bring_to_front())
            log_api(&#34;&lt;= page.bring_to_front succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.bring_to_front failed&#34;)
            raise e

    async def add_init_script(
        self, script: str = None, path: typing.Union[str, pathlib.Path] = None
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.add_init_script

        Adds a script which would be evaluated in one of the following scenarios:
        - Whenever the page is navigated.
        - Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly
          attached frame.

        The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
        the JavaScript environment, e.g. to seed `Math.random`.

        An example of overriding `Math.random` before the page loads:

        ```py
        # in your playwright script, assuming the preload.js file is in same directory
        await page.add_init_script(path=\&#34;./preload.js\&#34;)
        ```

        &gt; NOTE: The order of evaluation of multiple scripts installed via `browser_context.add_init_script()` and
        `page.add_init_script()` is not defined.

        Parameters
        ----------
        script : Union[str, NoneType]
            Script to be evaluated in all pages in the browser context. Optional.
        path : Union[pathlib.Path, str, NoneType]
            Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to the current working
            directory. Optional.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.add_init_script started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.add_init_script(script=script, path=path)
            )
            log_api(&#34;&lt;= page.add_init_script succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.add_init_script failed&#34;)
            raise e

    async def route(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Union[
            typing.Callable[[&#34;Route&#34;], typing.Any],
            typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
        ],
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.route

        Routing provides the capability to modify network requests that are made by a page.

        Once routing is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.

        &gt; NOTE: The handler will only be called for the first url if the response is a redirect.

        An example of a naïve handler that aborts all image requests:

        ```py
        page = await browser.new_page()
        await page.route(\&#34;**/*.{png,jpg,jpeg}\&#34;, lambda route: route.abort())
        await page.goto(\&#34;https://example.com\&#34;)
        await browser.close()
        ```

        or the same snippet using a regex pattern instead:

        ```py
        page = await browser.new_page()
        await page.route(r\&#34;(\\.png$)|(\\.jpg$)\&#34;, lambda route: route.abort())
        await page.goto(\&#34;https://example.com\&#34;)
        await browser.close()
        ```

        Page routes take precedence over browser context routes (set up with `browser_context.route()`) when request
        matches both handlers.

        &gt; NOTE: Enabling routing disables http cache.

        Parameters
        ----------
        url : Union[Callable[[str], bool], Pattern, str]
            A glob pattern, regex pattern or predicate receiving [URL] to match while routing.
        handler : Union[Callable[[Route, Request], Any], Callable[[Route], Any]]
            handler function to route the request.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.route started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.route(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
            log_api(&#34;&lt;= page.route succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.route failed&#34;)
            raise e

    async def unroute(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
        handler: typing.Union[
            typing.Callable[[&#34;Route&#34;], typing.Any],
            typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
        ] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.unroute

        Removes a route created with `page.route()`. When `handler` is not specified, removes all routes for the `url`.

        Parameters
        ----------
        url : Union[Callable[[str], bool], Pattern, str]
            A glob pattern, regex pattern or predicate receiving [URL] to match while routing.
        handler : Union[Callable[[Route, Request], Any], Callable[[Route], Any], NoneType]
            Optional handler function to route the request.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.unroute started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.unroute(
                    url=self._wrap_handler(url), handler=self._wrap_handler(handler)
                )
            )
            log_api(&#34;&lt;= page.unroute succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.unroute failed&#34;)
            raise e

    async def screenshot(
        self,
        timeout: float = None,
        type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
        path: typing.Union[str, pathlib.Path] = None,
        quality: int = None,
        omit_background: bool = None,
        full_page: bool = None,
        clip: FloatRect = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;Page.screenshot

        Returns the buffer with the captured screenshot.

        &gt; NOTE: Screenshots take at least 1/6 second on Chromium OS X and Chromium Windows. See https://crbug.com/741689 for
        discussion.

        Parameters
        ----------
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        type : Union[&#34;jpeg&#34;, &#34;png&#34;, NoneType]
            Specify screenshot type, defaults to `png`.
        path : Union[pathlib.Path, str, NoneType]
            The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative
            path, then it is resolved relative to the current working directory. If no path is provided, the image won&#39;t be saved to
            the disk.
        quality : Union[int, NoneType]
            The quality of the image, between 0-100. Not applicable to `png` images.
        omit_background : Union[bool, NoneType]
            Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images.
            Defaults to `false`.
        full_page : Union[bool, NoneType]
            When true, takes a screenshot of the full scrollable page, instead of the currently visible viewport. Defaults to
            `false`.
        clip : Union[{x: float, y: float, width: float, height: float}, NoneType]
            An object which specifies clipping of the resulting image. Should have the following fields:

        Returns
        -------
        bytes
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.screenshot started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.screenshot(
                    timeout=timeout,
                    type=type,
                    path=path,
                    quality=quality,
                    omitBackground=omit_background,
                    fullPage=full_page,
                    clip=clip,
                )
            )
            log_api(&#34;&lt;= page.screenshot succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.screenshot failed&#34;)
            raise e

    async def title(self) -&gt; str:
        &#34;&#34;&#34;Page.title

        Returns the page&#39;s title. Shortcut for main frame&#39;s `frame.title()`.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.title started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.title())
            log_api(&#34;&lt;= page.title succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.title failed&#34;)
            raise e

    async def close(self, run_before_unload: bool = None) -&gt; NoneType:
        &#34;&#34;&#34;Page.close

        If `runBeforeUnload` is `false`, does not run any unload handlers and waits for the page to be closed. If
        `runBeforeUnload` is `true` the method will run unload handlers, but will **not** wait for the page to close.

        By default, `page.close()` **does not** run `beforeunload` handlers.

        &gt; NOTE: if `runBeforeUnload` is passed as true, a `beforeunload` dialog might be summoned and should be handled manually
        via [`event: Page.dialog`] event.

        Parameters
        ----------
        run_before_unload : Union[bool, NoneType]
            Defaults to `false`. Whether to run the
            [before unload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload) page handlers.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.close started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.close(runBeforeUnload=run_before_unload)
            )
            log_api(&#34;&lt;= page.close succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.close failed&#34;)
            raise e

    def is_closed(self) -&gt; bool:
        &#34;&#34;&#34;Page.is_closed

        Indicates that the page has been closed.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.is_closed started&#34;)
            result = mapping.from_maybe_impl(self._impl_obj.is_closed())
            log_api(&#34;&lt;= page.is_closed succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.is_closed failed&#34;)
            raise e

    async def click(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        delay: float = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        click_count: int = None,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.click

        This method clicks an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to click in the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Shortcut for main frame&#39;s `frame.click()`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        delay : Union[float, NoneType]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        click_count : Union[int, NoneType]
            defaults to 1. See [UIEvent.detail].
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.click started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.click(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    clickCount=click_count,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.click succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.click failed&#34;)
            raise e

    async def dblclick(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        delay: float = None,
        button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.dblclick

        This method double clicks an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to double click in the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the
           first click of the `dblclick()` triggers a navigation event, this method will reject.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        &gt; NOTE: `page.dblclick()` dispatches two `click` events and a single `dblclick` event.

        Shortcut for main frame&#39;s `frame.dblclick()`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        delay : Union[float, NoneType]
            Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
        button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
            Defaults to `left`.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.dblclick started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.dblclick(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    delay=delay,
                    button=button,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.dblclick succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.dblclick failed&#34;)
            raise e

    async def tap(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.tap

        This method taps an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.touchscreen` to tap the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        &gt; NOTE: `page.tap()` requires that the `hasTouch` option of the browser context be set to true.

        Shortcut for main frame&#39;s `frame.tap()`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.tap started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.tap(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.tap succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.tap failed&#34;)
            raise e

    async def fill(
        self,
        selector: str,
        value: str,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.fill

        This method waits for an element matching `selector`, waits for [actionability](./actionability.md) checks, focuses the
        element, fills it and triggers an `input` event after filling. If the element matching `selector` is not an `&lt;input&gt;`,
        `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error. Note that you can pass an empty string to
        clear the input field.

        To send fine-grained keyboard events, use `page.type()`.

        Shortcut for main frame&#39;s `frame.fill()`

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        value : str
            Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.fill started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.fill(
                    selector=selector,
                    value=value,
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.fill succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.fill failed&#34;)
            raise e

    async def focus(self, selector: str, timeout: float = None) -&gt; NoneType:
        &#34;&#34;&#34;Page.focus

        This method fetches an element with `selector` and focuses it. If there&#39;s no element matching `selector`, the method
        waits until a matching element appears in the DOM.

        Shortcut for main frame&#39;s `frame.focus()`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.focus started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.focus(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.focus succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.focus failed&#34;)
            raise e

    async def text_content(
        self, selector: str, timeout: float = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Page.text_content

        Returns `element.textContent`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.text_content started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.text_content(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.text_content succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.text_content failed&#34;)
            raise e

    async def inner_text(self, selector: str, timeout: float = None) -&gt; str:
        &#34;&#34;&#34;Page.inner_text

        Returns `element.innerText`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.inner_text started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.inner_text(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.inner_text succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.inner_text failed&#34;)
            raise e

    async def inner_html(self, selector: str, timeout: float = None) -&gt; str:
        &#34;&#34;&#34;Page.inner_html

        Returns `element.innerHTML`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.inner_html started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.inner_html(selector=selector, timeout=timeout)
            )
            log_api(&#34;&lt;= page.inner_html succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.inner_html failed&#34;)
            raise e

    async def get_attribute(
        self, selector: str, name: str, timeout: float = None
    ) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Page.get_attribute

        Returns element attribute value.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        name : str
            Attribute name to get the value for.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.get_attribute started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.get_attribute(
                    selector=selector, name=name, timeout=timeout
                )
            )
            log_api(&#34;&lt;= page.get_attribute succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.get_attribute failed&#34;)
            raise e

    async def hover(
        self,
        selector: str,
        modifiers: typing.Union[
            typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
        ] = None,
        position: Position = None,
        timeout: float = None,
        force: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.hover

        This method hovers over an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to hover over the center of the element, or the specified `position`.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Shortcut for main frame&#39;s `frame.hover()`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
            Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
            modifiers back. If not specified, currently pressed modifiers are used.
        position : Union[{x: float, y: float}, NoneType]
            A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
            element.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.hover started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.hover(
                    selector=selector,
                    modifiers=modifiers,
                    position=position,
                    timeout=timeout,
                    force=force,
                )
            )
            log_api(&#34;&lt;= page.hover succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.hover failed&#34;)
            raise e

    async def select_option(
        self,
        selector: str,
        value: typing.Union[str, typing.List[str]] = None,
        index: typing.Union[int, typing.List[int]] = None,
        label: typing.Union[str, typing.List[str]] = None,
        element: typing.Union[&#34;ElementHandle&#34;, typing.List[&#34;ElementHandle&#34;]] = None,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; typing.List[str]:
        &#34;&#34;&#34;Page.select_option

        Returns the array of option values that have been successfully selected.

        Triggers a `change` and `input` event once all the provided options have been selected. If there&#39;s no `&lt;select&gt;` element
        matching `selector`, the method throws an error.

        ```py
        # single selection matching the value
        await page.select_option(\&#34;select#colors\&#34;, \&#34;blue\&#34;)
        # single selection matching the label
        await page.select_option(\&#34;select#colors\&#34;, label=\&#34;blue\&#34;)
        # multiple selection
        await page.select_option(\&#34;select#colors\&#34;, value=[\&#34;red\&#34;, \&#34;green\&#34;, \&#34;blue\&#34;])
        ```

        Shortcut for main frame&#39;s `frame.select_option()`

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        value : Union[List[str], str, NoneType]
            Options to select by value. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
            only the first option matching one of the passed options is selected. Optional.
        index : Union[List[int], int, NoneType]
            Options to select by index. Optional.
        label : Union[List[str], str, NoneType]
            Options to select by label. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
            only the first option matching one of the passed options is selected. Optional.
        element : Union[ElementHandle, List[ElementHandle], NoneType]
            Option elements to select. Optional.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.

        Returns
        -------
        List[str]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.select_option started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.select_option(
                    selector=selector,
                    value=value,
                    index=index,
                    label=label,
                    element=mapping.to_impl(element),
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.select_option succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.select_option failed&#34;)
            raise e

    async def set_input_files(
        self,
        selector: str,
        files: typing.Union[
            str,
            pathlib.Path,
            FilePayload,
            typing.List[typing.Union[str, pathlib.Path]],
            typing.List[FilePayload],
        ],
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.set_input_files

        This method expects `selector` to point to an
        [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).

        Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
        are resolved relative to the the current working directory. For empty array, clears the selected files.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        files : Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.set_input_files started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.set_input_files(
                    selector=selector,
                    files=files,
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.set_input_files succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.set_input_files failed&#34;)
            raise e

    async def type(
        self,
        selector: str,
        text: str,
        delay: float = None,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.type

        Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `page.type` can be used to send
        fine-grained keyboard events. To fill values in form fields, use `page.fill()`.

        To press a special key, like `Control` or `ArrowDown`, use `keyboard.press()`.

        ```py
        await page.type(\&#34;#mytextarea\&#34;, \&#34;hello\&#34;) # types instantly
        await page.type(\&#34;#mytextarea\&#34;, \&#34;world\&#34;, delay=100) # types slower, like a user
        ```

        Shortcut for main frame&#39;s `frame.type()`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        text : str
            A text to type into a focused element.
        delay : Union[float, NoneType]
            Time to wait between key presses in milliseconds. Defaults to 0.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.type started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.type(
                    selector=selector,
                    text=text,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.type succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.type failed&#34;)
            raise e

    async def press(
        self,
        selector: str,
        key: str,
        delay: float = None,
        timeout: float = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.press

        Focuses the element, and then uses `keyboard.down()` and `keyboard.up()`.

        `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
        value or a single character to generate the text for. A superset of the `key` values can be found
        [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

        `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
        `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

        Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

        Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

        If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
        texts.

        Shortcuts such as `key: \&#34;Control+o\&#34;` or `key: \&#34;Control+Shift+T\&#34;` are supported as well. When speficied with the
        modifier, modifier is pressed and being held while the subsequent key is being pressed.

        ```py
        page = await browser.new_page()
        await page.goto(\&#34;https://keycode.info\&#34;)
        await page.press(\&#34;body\&#34;, \&#34;A\&#34;)
        await page.screenshot(path=\&#34;a.png\&#34;)
        await page.press(\&#34;body\&#34;, \&#34;ArrowLeft\&#34;)
        await page.screenshot(path=\&#34;arrow_left.png\&#34;)
        await page.press(\&#34;body\&#34;, \&#34;Shift+O\&#34;)
        await page.screenshot(path=\&#34;o.png\&#34;)
        await browser.close()
        ```

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        key : str
            Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
        delay : Union[float, NoneType]
            Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.press started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.press(
                    selector=selector,
                    key=key,
                    delay=delay,
                    timeout=timeout,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.press succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.press failed&#34;)
            raise e

    async def check(
        self,
        selector: str,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.check

        This method checks an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
           checked, this method returns immediately.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to click in the center of the element.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        1. Ensure that the element is now checked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Shortcut for main frame&#39;s `frame.check()`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.check started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.check(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.check succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.check failed&#34;)
            raise e

    async def uncheck(
        self,
        selector: str,
        timeout: float = None,
        force: bool = None,
        no_wait_after: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Page.uncheck

        This method unchecks an element matching `selector` by performing the following steps:
        1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
        1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
           unchecked, this method returns immediately.
        1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
           element is detached during the checks, the whole action is retried.
        1. Scroll the element into view if needed.
        1. Use `page.mouse` to click in the center of the element.
        1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
        1. Ensure that the element is now unchecked. If not, this method rejects.

        When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
        Passing zero timeout disables this.

        Shortcut for main frame&#39;s `frame.uncheck()`.

        Parameters
        ----------
        selector : str
            A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
            [working with selectors](./selectors.md#working-with-selectors) for more details.
        timeout : Union[float, NoneType]
            Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
            using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
        force : Union[bool, NoneType]
            Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
        no_wait_after : Union[bool, NoneType]
            Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
            opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
            inaccessible pages. Defaults to `false`.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.uncheck started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.uncheck(
                    selector=selector,
                    timeout=timeout,
                    force=force,
                    noWaitAfter=no_wait_after,
                )
            )
            log_api(&#34;&lt;= page.uncheck succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.uncheck failed&#34;)
            raise e

    async def wait_for_timeout(self, timeout: float) -&gt; NoneType:
        &#34;&#34;&#34;Page.wait_for_timeout

        Waits for the given `timeout` in milliseconds.

        Note that `page.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be
        flaky. Use signals such as network events, selectors becoming visible and others instead.

        ```py
        # wait for 1 second
        await page.wait_for_timeout(1000)
        ```

        Shortcut for main frame&#39;s `frame.wait_for_timeout()`.

        Parameters
        ----------
        timeout : float
            A timeout to wait for
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.wait_for_timeout started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.wait_for_timeout(timeout=timeout)
            )
            log_api(&#34;&lt;= page.wait_for_timeout succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.wait_for_timeout failed&#34;)
            raise e

    async def wait_for_function(
        self,
        expression: str,
        arg: typing.Any = None,
        force_expr: bool = None,
        timeout: float = None,
        polling: typing.Union[float, Literal[&#34;raf&#34;]] = None,
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Page.wait_for_function

        Returns when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.

        The `waitForFunction` can be used to observe viewport size change:

        ```py
        import asyncio
        from playwright.async_api import async_playwright

        async def run(playwright):
            webkit = playwright.webkit
            browser = await webkit.launch()
            page = await browser.new_page()
            watch_dog = page.wait_for_function(\&#34;() =&gt; window.innerWidth &lt; 100\&#34;)
            await page.set_viewport_size({\&#34;width\&#34;: 50, \&#34;height\&#34;: 50})
            await watch_dog
            await browser.close()

        async def main():
            async with async_playwright() as playwright:
                await run(playwright)
        asyncio.run(main())
        ```

        To pass an argument to the predicate of `page.wait_for_function()` function:

        ```py
        selector = \&#34;.foo\&#34;
        await page.wait_for_function(\&#34;selector =&gt; !!document.querySelector(selector)\&#34;, selector)
        ```

        Shortcut for main frame&#39;s `frame.wait_for_function()`.

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.
        timeout : Union[float, NoneType]
            maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.
        polling : Union[&#34;raf&#34;, float, NoneType]
            If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is
            a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

        Returns
        -------
        JSHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.wait_for_function started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.wait_for_function(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                    timeout=timeout,
                    polling=polling,
                )
            )
            log_api(&#34;&lt;= page.wait_for_function succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.wait_for_function failed&#34;)
            raise e

    async def pdf(
        self,
        scale: float = None,
        display_header_footer: bool = None,
        header_template: str = None,
        footer_template: str = None,
        print_background: bool = None,
        landscape: bool = None,
        page_ranges: str = None,
        format: str = None,
        width: typing.Union[str, float] = None,
        height: typing.Union[str, float] = None,
        prefer_css_page_size: bool = None,
        margin: PdfMargins = None,
        path: typing.Union[str, pathlib.Path] = None,
    ) -&gt; bytes:
        &#34;&#34;&#34;Page.pdf

        Returns the PDF buffer.

        &gt; NOTE: Generating a pdf is currently only supported in Chromium headless.

        `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call
        `page.emulate_media()` before calling `page.pdf()`:

        &gt; NOTE: By default, `page.pdf()` generates a pdf with modified colors for printing. Use the
        [`-webkit-print-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust) property to
        force rendering of exact colors.

        ```py
        # generates a pdf with \&#34;screen\&#34; media type.
        await page.emulate_media(media=\&#34;screen\&#34;)
        await page.pdf(path=\&#34;page.pdf\&#34;)
        ```

        The `width`, `height`, and `margin` options accept values labeled with units. Unlabeled values are treated as pixels.

        A few examples:
        - `page.pdf({width: 100})` - prints with width set to 100 pixels
        - `page.pdf({width: &#39;100px&#39;})` - prints with width set to 100 pixels
        - `page.pdf({width: &#39;10cm&#39;})` - prints with width set to 10 centimeters.

        All possible units are:
        - `px` - pixel
        - `in` - inch
        - `cm` - centimeter
        - `mm` - millimeter

        The `format` options are:
        - `Letter`: 8.5in x 11in
        - `Legal`: 8.5in x 14in
        - `Tabloid`: 11in x 17in
        - `Ledger`: 17in x 11in
        - `A0`: 33.1in x 46.8in
        - `A1`: 23.4in x 33.1in
        - `A2`: 16.54in x 23.4in
        - `A3`: 11.7in x 16.54in
        - `A4`: 8.27in x 11.7in
        - `A5`: 5.83in x 8.27in
        - `A6`: 4.13in x 5.83in

        &gt; NOTE: `headerTemplate` and `footerTemplate` markup have the following limitations: &gt; 1. Script tags inside templates
        are not evaluated. &gt; 2. Page styles are not visible inside templates.

        Parameters
        ----------
        scale : Union[float, NoneType]
            Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2.
        display_header_footer : Union[bool, NoneType]
            Display header and footer. Defaults to `false`.
        header_template : Union[str, NoneType]
            HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values
            into them:
            - `&#39;date&#39;` formatted print date
            - `&#39;title&#39;` document title
            - `&#39;url&#39;` document location
            - `&#39;pageNumber&#39;` current page number
            - `&#39;totalPages&#39;` total pages in the document
        footer_template : Union[str, NoneType]
            HTML template for the print footer. Should use the same format as the `headerTemplate`.
        print_background : Union[bool, NoneType]
            Print background graphics. Defaults to `false`.
        landscape : Union[bool, NoneType]
            Paper orientation. Defaults to `false`.
        page_ranges : Union[str, NoneType]
            Paper ranges to print, e.g., &#39;1-5, 8, 11-13&#39;. Defaults to the empty string, which means print all pages.
        format : Union[str, NoneType]
            Paper format. If set, takes priority over `width` or `height` options. Defaults to &#39;Letter&#39;.
        width : Union[float, str, NoneType]
            Paper width, accepts values labeled with units.
        height : Union[float, str, NoneType]
            Paper height, accepts values labeled with units.
        prefer_css_page_size : Union[bool, NoneType]
            Give any CSS `@page` size declared in the page priority over what is declared in `width` and `height` or `format`
            options. Defaults to `false`, which will scale the content to fit the paper size.
        margin : Union[{top: Union[float, str, NoneType], right: Union[float, str, NoneType], bottom: Union[float, str, NoneType], left: Union[float, str, NoneType]}, NoneType]
            Paper margins, defaults to none.
        path : Union[pathlib.Path, str, NoneType]
            The file path to save the PDF to. If `path` is a relative path, then it is resolved relative to the current working
            directory. If no path is provided, the PDF won&#39;t be saved to the disk.

        Returns
        -------
        bytes
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; page.pdf started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.pdf(
                    scale=scale,
                    displayHeaderFooter=display_header_footer,
                    headerTemplate=header_template,
                    footerTemplate=footer_template,
                    printBackground=print_background,
                    landscape=landscape,
                    pageRanges=page_ranges,
                    format=format,
                    width=width,
                    height=height,
                    preferCSSPageSize=prefer_css_page_size,
                    margin=margin,
                    path=path,
                )
            )
            log_api(&#34;&lt;= page.pdf succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= page.pdf failed&#34;)
            raise e

    def expect_event(
        self, event: str, predicate: typing.Callable = None, timeout: float = None
    ) -&gt; AsyncEventContextManager:
        &#34;&#34;&#34;Page.expect_event

        Performs action and waits for given `event` to fire. If predicate is provided, it passes event&#39;s value into the
        `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
        closed before the `event` is fired.

        ```py
        async with page.expect_event(event_name) as event_info:
            await page.click(\&#34;button\&#34;)
        value = await event_info.value
        ```

        Parameters
        ----------
        event : str
            Event name, same one typically passed into `*.on(event)`.
        predicate : Union[Callable, NoneType]
            Receives the event data and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_event(
                event=event, predicate=self._wrap_handler(predicate), timeout=timeout
            ).future
        )

    def expect_console_message(
        self,
        predicate: typing.Union[typing.Callable[[&#34;ConsoleMessage&#34;], bool]] = None,
        timeout: float = None,
    ) -&gt; AsyncEventContextManager[&#34;ConsoleMessage&#34;]:
        &#34;&#34;&#34;Page.expect_console_message

        Performs action and waits for `console` event to fire. If predicate is provided, it passes `ConsoleMessage` value into
        the `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
        closed before the worker event is fired.

        Parameters
        ----------
        predicate : Union[Callable[[ConsoleMessage], bool], NoneType]
            Receives the `ConsoleMessage` object and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager[ConsoleMessage]
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_console_message(
                predicate=self._wrap_handler(predicate), timeout=timeout
            ).future
        )

    def expect_download(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Download&#34;], bool]] = None,
        timeout: float = None,
    ) -&gt; AsyncEventContextManager[&#34;Download&#34;]:
        &#34;&#34;&#34;Page.expect_download

        Performs action and waits for `download` event to fire. If predicate is provided, it passes `Download` value into the
        `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
        closed before the download event is fired.

        Parameters
        ----------
        predicate : Union[Callable[[Download], bool], NoneType]
            Receives the `Download` object and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager[Download]
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_download(
                predicate=self._wrap_handler(predicate), timeout=timeout
            ).future
        )

    def expect_file_chooser(
        self,
        predicate: typing.Union[typing.Callable[[&#34;FileChooser&#34;], bool]] = None,
        timeout: float = None,
    ) -&gt; AsyncEventContextManager[&#34;FileChooser&#34;]:
        &#34;&#34;&#34;Page.expect_file_chooser

        Performs action and waits for `filechooser` event to fire. If predicate is provided, it passes `FileChooser` value into
        the `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
        closed before the worker event is fired.

        Parameters
        ----------
        predicate : Union[Callable[[FileChooser], bool], NoneType]
            Receives the `FileChooser` object and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager[FileChooser]
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_file_chooser(
                predicate=self._wrap_handler(predicate), timeout=timeout
            ).future
        )

    def expect_navigation(
        self,
        url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
        wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
        timeout: float = None,
    ) -&gt; AsyncEventContextManager:
        &#34;&#34;&#34;Page.expect_navigation

        Performs action and waits for the next navigation. In case of multiple redirects, the navigation will resolve with the
        response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the
        navigation will resolve with `null`.

        This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
        cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`.
        Consider this example:

        ```py
        async with page.expect_navigation():
            await page.click(\&#34;a.delayed-navigation\&#34;) # Clicking the link will indirectly cause a navigation
        # Context manager waited for the navigation to happen.
        ```

        &gt; NOTE: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is
        considered a navigation.

        Shortcut for main frame&#39;s `frame.expect_navigation()`.

        Parameters
        ----------
        url : Union[Callable[[str], bool], Pattern, str, NoneType]
            A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation.
        wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
            When to consider operation succeeded, defaults to `load`. Events can be either:
            - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
            - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
            - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
        timeout : Union[float, NoneType]
            Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
            changed by using the `browser_context.set_default_navigation_timeout()`,
            `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
            `page.set_default_timeout()` methods.

        Returns
        -------
        EventContextManager
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_navigation(
                url=self._wrap_handler(url), wait_until=wait_until, timeout=timeout
            ).future
        )

    def expect_popup(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
        timeout: float = None,
    ) -&gt; AsyncEventContextManager[&#34;Page&#34;]:
        &#34;&#34;&#34;Page.expect_popup

        Performs action and waits for `popup` event to fire. If predicate is provided, it passes [Popup] value into the
        `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
        closed before the popup event is fired.

        Parameters
        ----------
        predicate : Union[Callable[[Page], bool], NoneType]
            Receives the [Popup] object and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager[Page]
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_popup(
                predicate=self._wrap_handler(predicate), timeout=timeout
            ).future
        )

    def expect_request(
        self,
        url_or_predicate: typing.Union[
            str, typing.Pattern, typing.Callable[[&#34;Request&#34;], bool]
        ],
        timeout: float = None,
    ) -&gt; AsyncEventContextManager[&#34;Request&#34;]:
        &#34;&#34;&#34;Page.expect_request

        Performs action and waits for `response` event to fire. If predicate is provided, it passes `Request` value into the
        `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
        closed before the download event is fired.

        Parameters
        ----------
        url_or_predicate : Union[Callable[[Request], bool], Pattern, str]
            Receives the `Request` object and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager[Request]
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_request(
                url_or_predicate=self._wrap_handler(url_or_predicate), timeout=timeout
            ).future
        )

    def expect_response(
        self,
        url_or_predicate: typing.Union[
            str, typing.Pattern, typing.Callable[[&#34;Response&#34;], bool]
        ],
        timeout: float = None,
    ) -&gt; AsyncEventContextManager[&#34;Response&#34;]:
        &#34;&#34;&#34;Page.expect_response

        Performs action and waits for `response` event to fire. If predicate is provided, it passes `Response` value into the
        `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
        closed before the download event is fired.

        Parameters
        ----------
        url_or_predicate : Union[Callable[[Response], bool], Pattern, str]
            Receives the `Response` object and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager[Response]
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_response(
                url_or_predicate=self._wrap_handler(url_or_predicate), timeout=timeout
            ).future
        )

    def expect_worker(
        self,
        predicate: typing.Union[typing.Callable[[&#34;Worker&#34;], bool]] = None,
        timeout: float = None,
    ) -&gt; AsyncEventContextManager[&#34;Worker&#34;]:
        &#34;&#34;&#34;Page.expect_worker

        Performs action and waits for `worker` event to fire. If predicate is provided, it passes `Worker` value into the
        `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
        closed before the worker event is fired.

        Parameters
        ----------
        predicate : Union[Callable[[Worker], bool], NoneType]
            Receives the `Worker` object and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager[Worker]
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_worker(
                predicate=self._wrap_handler(predicate), timeout=timeout
            ).future
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Page.accessibility"><code class="name">var <span class="ident">accessibility</span> : playwright.async_api._generated.Accessibility</code></dt>
<dd>
<div class="desc"><p>Page.accessibility</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Accessibility" href="#playwright.async_api.Accessibility">Accessibility</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def accessibility(self) -&gt; &#34;Accessibility&#34;:
    &#34;&#34;&#34;Page.accessibility

    Returns
    -------
    Accessibility
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.accessibility)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.context"><code class="name">var <span class="ident">context</span> : playwright.async_api._generated.BrowserContext</code></dt>
<dd>
<div class="desc"><p>Page.context</p>
<p>Get the browser context that the page belongs to.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.BrowserContext" href="#playwright.async_api.BrowserContext">BrowserContext</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def context(self) -&gt; &#34;BrowserContext&#34;:
    &#34;&#34;&#34;Page.context

    Get the browser context that the page belongs to.

    Returns
    -------
    BrowserContext
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.context)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.frames"><code class="name">var <span class="ident">frames</span> : List[playwright.async_api._generated.Frame]</code></dt>
<dd>
<div class="desc"><p>Page.frames</p>
<p>An array of all frames attached to the page.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frames(self) -&gt; typing.List[&#34;Frame&#34;]:
    &#34;&#34;&#34;Page.frames

    An array of all frames attached to the page.

    Returns
    -------
    List[Frame]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.frames)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.keyboard"><code class="name">var <span class="ident">keyboard</span> : playwright.async_api._generated.Keyboard</code></dt>
<dd>
<div class="desc"><p>Page.keyboard</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Keyboard" href="#playwright.async_api.Keyboard">Keyboard</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def keyboard(self) -&gt; &#34;Keyboard&#34;:
    &#34;&#34;&#34;Page.keyboard

    Returns
    -------
    Keyboard
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.keyboard)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.main_frame"><code class="name">var <span class="ident">main_frame</span> : playwright.async_api._generated.Frame</code></dt>
<dd>
<div class="desc"><p>Page.main_frame</p>
<p>The page's main frame. Page is guaranteed to have a main frame which persists during navigations.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def main_frame(self) -&gt; &#34;Frame&#34;:
    &#34;&#34;&#34;Page.main_frame

    The page&#39;s main frame. Page is guaranteed to have a main frame which persists during navigations.

    Returns
    -------
    Frame
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.main_frame)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.mouse"><code class="name">var <span class="ident">mouse</span> : playwright.async_api._generated.Mouse</code></dt>
<dd>
<div class="desc"><p>Page.mouse</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Mouse" href="#playwright.async_api.Mouse">Mouse</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mouse(self) -&gt; &#34;Mouse&#34;:
    &#34;&#34;&#34;Page.mouse

    Returns
    -------
    Mouse
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.mouse)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.touchscreen"><code class="name">var <span class="ident">touchscreen</span> : playwright.async_api._generated.Touchscreen</code></dt>
<dd>
<div class="desc"><p>Page.touchscreen</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Touchscreen" href="#playwright.async_api.Touchscreen">Touchscreen</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def touchscreen(self) -&gt; &#34;Touchscreen&#34;:
    &#34;&#34;&#34;Page.touchscreen

    Returns
    -------
    Touchscreen
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.touchscreen)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Page.url</p>
<p>Shortcut for main frame's <code>frame.url()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Page.url

    Shortcut for main frame&#39;s `frame.url()`.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.video"><code class="name">var <span class="ident">video</span> : Union[playwright.async_api._generated.Video, NoneType]</code></dt>
<dd>
<div class="desc"><p>Page.video</p>
<p>Video object associated with this page.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Video" href="#playwright.async_api.Video">Video</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def video(self) -&gt; typing.Union[&#34;Video&#34;, NoneType]:
    &#34;&#34;&#34;Page.video

    Video object associated with this page.

    Returns
    -------
    Union[Video, NoneType]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.video)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.viewport_size"><code class="name">var <span class="ident">viewport_size</span> : Union[playwright._impl._api_structures.ViewportSize, NoneType]</code></dt>
<dd>
<div class="desc"><p>Page.viewport_size</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[{width: int, height: int}, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def viewport_size(self) -&gt; typing.Union[ViewportSize, NoneType]:
    &#34;&#34;&#34;Page.viewport_size

    Returns
    -------
    Union[{width: int, height: int}, NoneType]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.viewport_size)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.workers"><code class="name">var <span class="ident">workers</span> : List[playwright.async_api._generated.Worker]</code></dt>
<dd>
<div class="desc"><p>Page.workers</p>
<p>This method returns all of the dedicated <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">WebWorkers</a>
associated with the page.</p>
<blockquote>
<p>NOTE: This does not contain ServiceWorkers</p>
</blockquote>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.Worker" href="#playwright.async_api.Worker">Worker</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def workers(self) -&gt; typing.List[&#34;Worker&#34;]:
    &#34;&#34;&#34;Page.workers

    This method returns all of the dedicated [WebWorkers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
    associated with the page.

    &gt; NOTE: This does not contain ServiceWorkers

    Returns
    -------
    List[Worker]
    &#34;&#34;&#34;
    return mapping.from_impl_list(self._impl_obj.workers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Page.add_init_script"><code class="name flex">
<span>async def <span class="ident">add_init_script</span></span>(<span>self, script: str = None, path: Union[str, pathlib.Path] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.add_init_script</p>
<p>Adds a script which would be evaluated in one of the following scenarios:
- Whenever the page is navigated.
- Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly
attached frame.</p>
<p>The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
the JavaScript environment, e.g. to seed <code>Math.random</code>.</p>
<p>An example of overriding <code>Math.random</code> before the page loads:</p>
<pre><code class="language-py"># in your playwright script, assuming the preload.js file is in same directory
await page.add_init_script(path=&quot;./preload.js&quot;)
</code></pre>
<blockquote>
<p>NOTE: The order of evaluation of multiple scripts installed via <code>browser_context.add_init_script()</code> and
<code>page.add_init_script()</code> is not defined.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>script</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Script to be evaluated in all pages in the browser context. Optional.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the JavaScript file. If <code>path</code> is a relative path, then it is resolved relative to the current working
directory. Optional.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_init_script(
    self, script: str = None, path: typing.Union[str, pathlib.Path] = None
) -&gt; NoneType:
    &#34;&#34;&#34;Page.add_init_script

    Adds a script which would be evaluated in one of the following scenarios:
    - Whenever the page is navigated.
    - Whenever the child frame is attached or navigated. In this case, the script is evaluated in the context of the newly
      attached frame.

    The script is evaluated after the document was created but before any of its scripts were run. This is useful to amend
    the JavaScript environment, e.g. to seed `Math.random`.

    An example of overriding `Math.random` before the page loads:

    ```py
    # in your playwright script, assuming the preload.js file is in same directory
    await page.add_init_script(path=\&#34;./preload.js\&#34;)
    ```

    &gt; NOTE: The order of evaluation of multiple scripts installed via `browser_context.add_init_script()` and
    `page.add_init_script()` is not defined.

    Parameters
    ----------
    script : Union[str, NoneType]
        Script to be evaluated in all pages in the browser context. Optional.
    path : Union[pathlib.Path, str, NoneType]
        Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to the current working
        directory. Optional.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.add_init_script started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.add_init_script(script=script, path=path)
        )
        log_api(&#34;&lt;= page.add_init_script succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.add_init_script failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.add_script_tag"><code class="name flex">
<span>async def <span class="ident">add_script_tag</span></span>(<span>self, url: str = None, path: Union[str, pathlib.Path] = None, content: str = None, type: str = None) ‑> playwright.async_api._generated.ElementHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Page.add_script_tag</p>
<p>Adds a <code>&lt;script&gt;</code> tag into the page with the desired url or content. Returns the added tag when the script's onload
fires or when the script content was injected into frame.</p>
<p>Shortcut for main frame's <code>frame.add_script_tag()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>URL of a script to be added.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the JavaScript file to be injected into frame. If <code>path</code> is a relative path, then it is resolved relative to the
current working directory.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Raw JavaScript content to be injected into frame.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Script type. Use 'module' in order to load a Javascript ES6 module. See
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script">script</a> for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_script_tag(
    self,
    url: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    content: str = None,
    type: str = None,
) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Page.add_script_tag

    Adds a `&lt;script&gt;` tag into the page with the desired url or content. Returns the added tag when the script&#39;s onload
    fires or when the script content was injected into frame.

    Shortcut for main frame&#39;s `frame.add_script_tag()`.

    Parameters
    ----------
    url : Union[str, NoneType]
        URL of a script to be added.
    path : Union[pathlib.Path, str, NoneType]
        Path to the JavaScript file to be injected into frame. If `path` is a relative path, then it is resolved relative to the
        current working directory.
    content : Union[str, NoneType]
        Raw JavaScript content to be injected into frame.
    type : Union[str, NoneType]
        Script type. Use &#39;module&#39; in order to load a Javascript ES6 module. See
        [script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) for more details.

    Returns
    -------
    ElementHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.add_script_tag started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.add_script_tag(
                url=url, path=path, content=content, type=type
            )
        )
        log_api(&#34;&lt;= page.add_script_tag succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.add_script_tag failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.add_style_tag"><code class="name flex">
<span>async def <span class="ident">add_style_tag</span></span>(<span>self, url: str = None, path: Union[str, pathlib.Path] = None, content: str = None) ‑> playwright.async_api._generated.ElementHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Page.add_style_tag</p>
<p>Adds a <code>&lt;link rel="stylesheet"&gt;</code> tag into the page with the desired url or a <code>&lt;style type="text/css"&gt;</code> tag with the
content. Returns the added tag when the stylesheet's onload fires or when the CSS content was injected into frame.</p>
<p>Shortcut for main frame's <code>frame.add_style_tag()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>URL of the <code>&lt;link&gt;</code> tag.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the CSS file to be injected into frame. If <code>path</code> is a relative path, then it is resolved relative to the
current working directory.</dd>
<dt><strong><code>content</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Raw CSS content to be injected into frame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_style_tag(
    self,
    url: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    content: str = None,
) -&gt; &#34;ElementHandle&#34;:
    &#34;&#34;&#34;Page.add_style_tag

    Adds a `&lt;link rel=\&#34;stylesheet\&#34;&gt;` tag into the page with the desired url or a `&lt;style type=\&#34;text/css\&#34;&gt;` tag with the
    content. Returns the added tag when the stylesheet&#39;s onload fires or when the CSS content was injected into frame.

    Shortcut for main frame&#39;s `frame.add_style_tag()`.

    Parameters
    ----------
    url : Union[str, NoneType]
        URL of the `&lt;link&gt;` tag.
    path : Union[pathlib.Path, str, NoneType]
        Path to the CSS file to be injected into frame. If `path` is a relative path, then it is resolved relative to the
        current working directory.
    content : Union[str, NoneType]
        Raw CSS content to be injected into frame.

    Returns
    -------
    ElementHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.add_style_tag started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.add_style_tag(url=url, path=path, content=content)
        )
        log_api(&#34;&lt;= page.add_style_tag succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.add_style_tag failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.bring_to_front"><code class="name flex">
<span>async def <span class="ident">bring_to_front</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.bring_to_front</p>
<p>Brings page to front (activates tab).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def bring_to_front(self) -&gt; NoneType:
    &#34;&#34;&#34;Page.bring_to_front

    Brings page to front (activates tab).
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.bring_to_front started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.bring_to_front())
        log_api(&#34;&lt;= page.bring_to_front succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.bring_to_front failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.check"><code class="name flex">
<span>async def <span class="ident">check</span></span>(<span>self, selector: str, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.check</p>
<p>This method checks an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
checked, this method returns immediately.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to click in the center of the element.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
1. Ensure that the element is now checked. If not, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<p>Shortcut for main frame's <code>frame.check()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check(
    self,
    selector: str,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.check

    This method checks an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
       checked, this method returns immediately.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to click in the center of the element.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    1. Ensure that the element is now checked. If not, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Shortcut for main frame&#39;s `frame.check()`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.check started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.check(
                selector=selector,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.check succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.check failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.click"><code class="name flex">
<span>async def <span class="ident">click</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, delay: float = None, button: Literal['left', 'middle', 'right'] = None, click_count: int = None, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.click</p>
<p>This method clicks an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to click in the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<p>Shortcut for main frame's <code>frame.click()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>click_count</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>defaults to 1. See [UIEvent.detail].</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def click(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    delay: float = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    click_count: int = None,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.click

    This method clicks an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to click in the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Shortcut for main frame&#39;s `frame.click()`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    delay : Union[float, NoneType]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    click_count : Union[int, NoneType]
        defaults to 1. See [UIEvent.detail].
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.click started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.click(
                selector=selector,
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                clickCount=click_count,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.click succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.click failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self, run_before_unload: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.close</p>
<p>If <code>runBeforeUnload</code> is <code>false</code>, does not run any unload handlers and waits for the page to be closed. If
<code>runBeforeUnload</code> is <code>true</code> the method will run unload handlers, but will <strong>not</strong> wait for the page to close.</p>
<p>By default, <code>page.close()</code> <strong>does not</strong> run <code>beforeunload</code> handlers.</p>
<blockquote>
<p>NOTE: if <code>runBeforeUnload</code> is passed as true, a <code>beforeunload</code> dialog might be summoned and should be handled manually
via [<code>event: Page.dialog</code>] event.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>run_before_unload</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Defaults to <code>false</code>. Whether to run the
<a href="https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload">before unload</a> page handlers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self, run_before_unload: bool = None) -&gt; NoneType:
    &#34;&#34;&#34;Page.close

    If `runBeforeUnload` is `false`, does not run any unload handlers and waits for the page to be closed. If
    `runBeforeUnload` is `true` the method will run unload handlers, but will **not** wait for the page to close.

    By default, `page.close()` **does not** run `beforeunload` handlers.

    &gt; NOTE: if `runBeforeUnload` is passed as true, a `beforeunload` dialog might be summoned and should be handled manually
    via [`event: Page.dialog`] event.

    Parameters
    ----------
    run_before_unload : Union[bool, NoneType]
        Defaults to `false`. Whether to run the
        [before unload](https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload) page handlers.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.close started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.close(runBeforeUnload=run_before_unload)
        )
        log_api(&#34;&lt;= page.close succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.close failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.content"><code class="name flex">
<span>async def <span class="ident">content</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Page.content</p>
<p>Gets the full HTML contents of the page, including the doctype.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def content(self) -&gt; str:
    &#34;&#34;&#34;Page.content

    Gets the full HTML contents of the page, including the doctype.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.content started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.content())
        log_api(&#34;&lt;= page.content succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.content failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.dblclick"><code class="name flex">
<span>async def <span class="ident">dblclick</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, delay: float = None, button: Literal['left', 'middle', 'right'] = None, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.dblclick</p>
<p>This method double clicks an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to double click in the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set. Note that if the
first click of the <code>dblclick()</code> triggers a navigation event, this method will reject.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<blockquote>
<p>NOTE: <code>page.dblclick()</code> dispatches two <code>click</code> events and a single <code>dblclick</code> event.</p>
</blockquote>
<p>Shortcut for main frame's <code>frame.dblclick()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>mousedown</code> and <code>mouseup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>button</code></strong> :&ensp;<code>Union["left", "middle", "right", NoneType]</code></dt>
<dd>Defaults to <code>left</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dblclick(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    delay: float = None,
    button: Literal[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;] = None,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.dblclick

    This method double clicks an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to double click in the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set. Note that if the
       first click of the `dblclick()` triggers a navigation event, this method will reject.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    &gt; NOTE: `page.dblclick()` dispatches two `click` events and a single `dblclick` event.

    Shortcut for main frame&#39;s `frame.dblclick()`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    delay : Union[float, NoneType]
        Time to wait between `mousedown` and `mouseup` in milliseconds. Defaults to 0.
    button : Union[&#34;left&#34;, &#34;middle&#34;, &#34;right&#34;, NoneType]
        Defaults to `left`.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.dblclick started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.dblclick(
                selector=selector,
                modifiers=modifiers,
                position=position,
                delay=delay,
                button=button,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.dblclick succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.dblclick failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.dispatch_event"><code class="name flex">
<span>async def <span class="ident">dispatch_event</span></span>(<span>self, selector: str, type: str, event_init: Dict = None, timeout: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.dispatch_event</p>
<p>The snippet below dispatches the <code>click</code> event on the element. Regardless of the visibility state of the elment, <code>click</code>
is dispatched. This is equivalend to calling
<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click">element.click()</a>.</p>
<pre><code class="language-py">await page.dispatch_event(&quot;button#submit&quot;, &quot;click&quot;)
</code></pre>
<p>Under the hood, it creates an instance of an event based on the given <code>type</code>, initializes it with <code>eventInit</code> properties
and dispatches it on the element. Events are <code>composed</code>, <code>cancelable</code> and bubble by default.</p>
<p>Since <code>eventInit</code> is event-specific, please refer to the events documentation for the lists of initial properties:
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent">DragEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent">FocusEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent">KeyboardEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent">MouseEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent">PointerEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent">TouchEvent</a>
- <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event">Event</a></p>
<p>You can also specify <code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code> as the property value if you want live objects to be passed into the event:</p>
<pre><code class="language-py"># note you can only create data_transfer in chromium and firefox
data_transfer = await page.evaluate_handle(&quot;new DataTransfer()&quot;)
await page.dispatch_event(&quot;#source&quot;, &quot;dragstart&quot;, { &quot;dataTransfer&quot;: data_transfer })
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code></dt>
<dd>DOM event type: <code>"click"</code>, <code>"dragstart"</code>, etc.</dd>
<dt><strong><code>event_init</code></strong> :&ensp;<code>Union[Dict, NoneType]</code></dt>
<dd>Optional event-specific initialization properties.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def dispatch_event(
    self,
    selector: str,
    type: str,
    event_init: typing.Dict = None,
    timeout: float = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.dispatch_event

    The snippet below dispatches the `click` event on the element. Regardless of the visibility state of the elment, `click`
    is dispatched. This is equivalend to calling
    [element.click()](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click).

    ```py
    await page.dispatch_event(\&#34;button#submit\&#34;, \&#34;click\&#34;)
    ```

    Under the hood, it creates an instance of an event based on the given `type`, initializes it with `eventInit` properties
    and dispatches it on the element. Events are `composed`, `cancelable` and bubble by default.

    Since `eventInit` is event-specific, please refer to the events documentation for the lists of initial properties:
    - [DragEvent](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/DragEvent)
    - [FocusEvent](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/FocusEvent)
    - [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/KeyboardEvent)
    - [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent)
    - [PointerEvent](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/PointerEvent)
    - [TouchEvent](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/TouchEvent)
    - [Event](https://developer.mozilla.org/en-US/docs/Web/API/Event/Event)

    You can also specify `JSHandle` as the property value if you want live objects to be passed into the event:

    ```py
    # note you can only create data_transfer in chromium and firefox
    data_transfer = await page.evaluate_handle(\&#34;new DataTransfer()\&#34;)
    await page.dispatch_event(\&#34;#source\&#34;, \&#34;dragstart\&#34;, { \&#34;dataTransfer\&#34;: data_transfer })
    ```

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    type : str
        DOM event type: `&#34;click&#34;`, `&#34;dragstart&#34;`, etc.
    event_init : Union[Dict, NoneType]
        Optional event-specific initialization properties.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.dispatch_event started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.dispatch_event(
                selector=selector,
                type=type,
                eventInit=mapping.to_impl(event_init),
                timeout=timeout,
            )
        )
        log_api(&#34;&lt;= page.dispatch_event succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.dispatch_event failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.emulate_media"><code class="name flex">
<span>async def <span class="ident">emulate_media</span></span>(<span>self, media: Literal['print', 'screen'] = None, color_scheme: Literal['dark', 'light', 'no-preference'] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.emulate_media</p>
<pre><code class="language-py">await page.evaluate(&quot;matchMedia('screen').matches&quot;)
# → True
await page.evaluate(&quot;matchMedia('print').matches&quot;)
# → False

await page.emulate_media(media=&quot;print&quot;)
await page.evaluate(&quot;matchMedia('screen').matches&quot;)
# → False
await page.evaluate(&quot;matchMedia('print').matches&quot;)
# → True

await page.emulate_media()
await page.evaluate(&quot;matchMedia('screen').matches&quot;)
# → True
await page.evaluate(&quot;matchMedia('print').matches&quot;)
# → False
</code></pre>
<pre><code class="language-py">await page.emulate_media(color_scheme=&quot;dark&quot;)
await page.evaluate(&quot;matchMedia('(prefers-color-scheme: dark)').matches&quot;)
# → True
await page.evaluate(&quot;matchMedia('(prefers-color-scheme: light)').matches&quot;)
# → False
await page.evaluate(&quot;matchMedia('(prefers-color-scheme: no-preference)').matches&quot;)
# → False
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>media</code></strong> :&ensp;<code>Union["print", "screen", NoneType]</code></dt>
<dd>Changes the CSS media type of the page. The only allowed values are <code>'screen'</code>, <code>'print'</code> and <code>null</code>. Passing <code>null</code>
disables CSS media emulation. Omitting <code>media</code> or passing <code>undefined</code> does not change the emulated value. Optional.</dd>
<dt><strong><code>color_scheme</code></strong> :&ensp;<code>Union["dark", "light", "no-preference", NoneType]</code></dt>
<dd>Emulates <code>'prefers-colors-scheme'</code> media feature, supported values are <code>'light'</code>, <code>'dark'</code>, <code>'no-preference'</code>. Passing
<code>null</code> disables color scheme emulation. Omitting <code>colorScheme</code> or passing <code>undefined</code> does not change the emulated
value. Optional.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def emulate_media(
    self,
    media: Literal[&#34;print&#34;, &#34;screen&#34;] = None,
    color_scheme: Literal[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.emulate_media

    ```py
    await page.evaluate(\&#34;matchMedia(&#39;screen&#39;).matches\&#34;)
    # → True
    await page.evaluate(\&#34;matchMedia(&#39;print&#39;).matches\&#34;)
    # → False

    await page.emulate_media(media=\&#34;print\&#34;)
    await page.evaluate(\&#34;matchMedia(&#39;screen&#39;).matches\&#34;)
    # → False
    await page.evaluate(\&#34;matchMedia(&#39;print&#39;).matches\&#34;)
    # → True

    await page.emulate_media()
    await page.evaluate(\&#34;matchMedia(&#39;screen&#39;).matches\&#34;)
    # → True
    await page.evaluate(\&#34;matchMedia(&#39;print&#39;).matches\&#34;)
    # → False
    ```

    ```py
    await page.emulate_media(color_scheme=\&#34;dark\&#34;)
    await page.evaluate(\&#34;matchMedia(&#39;(prefers-color-scheme: dark)&#39;).matches\&#34;)
    # → True
    await page.evaluate(\&#34;matchMedia(&#39;(prefers-color-scheme: light)&#39;).matches\&#34;)
    # → False
    await page.evaluate(\&#34;matchMedia(&#39;(prefers-color-scheme: no-preference)&#39;).matches\&#34;)
    # → False
    ```

    Parameters
    ----------
    media : Union[&#34;print&#34;, &#34;screen&#34;, NoneType]
        Changes the CSS media type of the page. The only allowed values are `&#39;screen&#39;`, `&#39;print&#39;` and `null`. Passing `null`
        disables CSS media emulation. Omitting `media` or passing `undefined` does not change the emulated value. Optional.
    color_scheme : Union[&#34;dark&#34;, &#34;light&#34;, &#34;no-preference&#34;, NoneType]
        Emulates `&#39;prefers-colors-scheme&#39;` media feature, supported values are `&#39;light&#39;`, `&#39;dark&#39;`, `&#39;no-preference&#39;`. Passing
        `null` disables color scheme emulation. Omitting `colorScheme` or passing `undefined` does not change the emulated
        value. Optional.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.emulate_media started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.emulate_media(
                media=media, colorScheme=color_scheme
            )
        )
        log_api(&#34;&lt;= page.emulate_media succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.emulate_media failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.eval_on_selector"><code class="name flex">
<span>async def <span class="ident">eval_on_selector</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Page.eval_on_selector</p>
<p>The method finds an element matching the specified selector within the page and passes it as a first argument to
<code>pageFunction</code>. If no elements match the selector, the method throws an error. Returns the value of <code>pageFunction</code>.</p>
<p>If <code>pageFunction</code> returns a [Promise], then <code>page.$eval()</code> would wait for the promise to resolve and return its
value.</p>
<p>Examples:</p>
<pre><code class="language-py">search_value = await page.eval_on_selector(&quot;#search&quot;, &quot;el =&gt; el.value&quot;)
preload_href = await page.eval_on_selector(&quot;link[rel=preload]&quot;, &quot;el =&gt; el.href&quot;)
html = await page.eval_on_selector(&quot;.main-container&quot;, &quot;(e, suffix) =&gt; e.outer_html + suffix&quot;, &quot;hello&quot;)
</code></pre>
<p>Shortcut for main frame's <code>frame.$eval()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def eval_on_selector(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;Page.eval_on_selector

    The method finds an element matching the specified selector within the page and passes it as a first argument to
    `pageFunction`. If no elements match the selector, the method throws an error. Returns the value of `pageFunction`.

    If `pageFunction` returns a [Promise], then `page.$eval()` would wait for the promise to resolve and return its
    value.

    Examples:

    ```py
    search_value = await page.eval_on_selector(\&#34;#search\&#34;, \&#34;el =&gt; el.value\&#34;)
    preload_href = await page.eval_on_selector(\&#34;link[rel=preload]\&#34;, \&#34;el =&gt; el.href\&#34;)
    html = await page.eval_on_selector(\&#34;.main-container\&#34;, \&#34;(e, suffix) =&gt; e.outer_html + suffix\&#34;, \&#34;hello\&#34;)
    ```

    Shortcut for main frame&#39;s `frame.$eval()`.

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.eval_on_selector started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.eval_on_selector(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= page.eval_on_selector succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.eval_on_selector failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.eval_on_selector_all"><code class="name flex">
<span>async def <span class="ident">eval_on_selector_all</span></span>(<span>self, selector: str, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Page.eval_on_selector_all</p>
<p>The method finds all elements matching the specified selector within the page and passes an array of matched elements as
a first argument to <code>pageFunction</code>. Returns the result of <code>pageFunction</code> invocation.</p>
<p>If <code>pageFunction</code> returns a [Promise], then <code>page.$$eval()</code> would wait for the promise to resolve and return its
value.</p>
<p>Examples:</p>
<pre><code class="language-py">div_counts = await page.eval_on_selector_all(&quot;div&quot;, &quot;(divs, min) =&gt; divs.length &gt;= min&quot;, 10)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def eval_on_selector_all(
    self,
    selector: str,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
) -&gt; typing.Any:
    &#34;&#34;&#34;Page.eval_on_selector_all

    The method finds all elements matching the specified selector within the page and passes an array of matched elements as
    a first argument to `pageFunction`. Returns the result of `pageFunction` invocation.

    If `pageFunction` returns a [Promise], then `page.$$eval()` would wait for the promise to resolve and return its
    value.

    Examples:

    ```py
    div_counts = await page.eval_on_selector_all(\&#34;div\&#34;, \&#34;(divs, min) =&gt; divs.length &gt;= min\&#34;, 10)
    ```

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.eval_on_selector_all started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.eval_on_selector_all(
                selector=selector,
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= page.eval_on_selector_all succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.eval_on_selector_all failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.evaluate"><code class="name flex">
<span>async def <span class="ident">evaluate</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Page.evaluate</p>
<p>Returns the value of the <code>pageFunction</code> invocation.</p>
<p>If the function passed to the <code>page.evaluate()</code> returns a [Promise], then <code>page.evaluate()</code> would wait
for the promise to resolve and return its value.</p>
<p>If the function passed to the <code>page.evaluate()</code> returns a non-[Serializable] value,
then[ method: <code>Page.evaluate</code>] resolves to <code>undefined</code>. DevTools Protocol also supports transferring some additional
values that are not serializable by <code>JSON</code>: <code>-0</code>, <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>, and bigint literals.</p>
<p>Passing argument to <code>pageFunction</code>:</p>
<pre><code class="language-py">result = await page.evaluate(&quot;([x, y]) =&gt; Promise.resolve(x * y)&quot;, [7, 8])
print(result) # prints &quot;56&quot;
</code></pre>
<p>A string can also be passed in instead of a function:</p>
<pre><code class="language-py">print(await page.evaluate(&quot;1 + 2&quot;)) # prints &quot;3&quot;
x = 10
print(await page.evaluate(f&quot;1 + {x}&quot;)) # prints &quot;11&quot;
</code></pre>
<p><code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code> instances can be passed as an argument to the <code>page.evaluate()</code>:</p>
<pre><code class="language-py">body_handle = await page.query_selector(&quot;body&quot;)
html = await page.evaluate(&quot;([body, suffix]) =&gt; body.innerHTML + suffix&quot;, [body_handle, &quot;hello&quot;])
await body_handle.dispose()
</code></pre>
<p>Shortcut for main frame's <code>frame.evaluate()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def evaluate(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; typing.Any:
    &#34;&#34;&#34;Page.evaluate

    Returns the value of the `pageFunction` invocation.

    If the function passed to the `page.evaluate()` returns a [Promise], then `page.evaluate()` would wait
    for the promise to resolve and return its value.

    If the function passed to the `page.evaluate()` returns a non-[Serializable] value,
    then[ method: `Page.evaluate`] resolves to `undefined`. DevTools Protocol also supports transferring some additional
    values that are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.

    Passing argument to `pageFunction`:

    ```py
    result = await page.evaluate(\&#34;([x, y]) =&gt; Promise.resolve(x * y)\&#34;, [7, 8])
    print(result) # prints \&#34;56\&#34;
    ```

    A string can also be passed in instead of a function:

    ```py
    print(await page.evaluate(\&#34;1 + 2\&#34;)) # prints \&#34;3\&#34;
    x = 10
    print(await page.evaluate(f\&#34;1 + {x}\&#34;)) # prints \&#34;11\&#34;
    ```

    `ElementHandle` instances can be passed as an argument to the `page.evaluate()`:

    ```py
    body_handle = await page.query_selector(\&#34;body\&#34;)
    html = await page.evaluate(\&#34;([body, suffix]) =&gt; body.innerHTML + suffix\&#34;, [body_handle, \&#34;hello\&#34;])
    await body_handle.dispose()
    ```

    Shortcut for main frame&#39;s `frame.evaluate()`.

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.evaluate started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.evaluate(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= page.evaluate succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.evaluate failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.evaluate_handle"><code class="name flex">
<span>async def <span class="ident">evaluate_handle</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> playwright.async_api._generated.JSHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Page.evaluate_handle</p>
<p>Returns the value of the <code>pageFunction</code> invocation as in-page object (JSHandle).</p>
<p>The only difference between <code>page.evaluate()</code> and <code>page.evaluate_handle()</code> is that
<code>page.evaluate_handle()</code> returns in-page object (JSHandle).</p>
<p>If the function passed to the <code>page.evaluate_handle()</code> returns a [Promise], then [<code>method:Ppage.EvaluateHandle</code>]
would wait for the promise to resolve and return its value.</p>
<pre><code class="language-py"># FIXME
a_window_handle = await page.evaluate_handle(&quot;Promise.resolve(window)&quot;)
a_window_handle # handle for the window object.
</code></pre>
<p>A string can also be passed in instead of a function:</p>
<pre><code class="language-py">a_handle = await page.evaluate_handle(&quot;document&quot;) # handle for the &quot;document&quot;
</code></pre>
<p><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code> instances can be passed as an argument to the <code>page.evaluate_handle()</code>:</p>
<pre><code class="language-py">a_handle = await page.evaluate_handle(&quot;document.body&quot;)
result_handle = await page.evaluate_handle(&quot;body =&gt; body.innerHTML&quot;, a_handle)
print(await result_handle.json_value())
await result_handle.dispose()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def evaluate_handle(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Page.evaluate_handle

    Returns the value of the `pageFunction` invocation as in-page object (JSHandle).

    The only difference between `page.evaluate()` and `page.evaluate_handle()` is that
    `page.evaluate_handle()` returns in-page object (JSHandle).

    If the function passed to the `page.evaluate_handle()` returns a [Promise], then [`method:Ppage.EvaluateHandle`]
    would wait for the promise to resolve and return its value.

    ```py
    # FIXME
    a_window_handle = await page.evaluate_handle(\&#34;Promise.resolve(window)\&#34;)
    a_window_handle # handle for the window object.
    ```

    A string can also be passed in instead of a function:

    ```py
    a_handle = await page.evaluate_handle(\&#34;document\&#34;) # handle for the \&#34;document\&#34;
    ```

    `JSHandle` instances can be passed as an argument to the `page.evaluate_handle()`:

    ```py
    a_handle = await page.evaluate_handle(\&#34;document.body\&#34;)
    result_handle = await page.evaluate_handle(\&#34;body =&gt; body.innerHTML\&#34;, a_handle)
    print(await result_handle.json_value())
    await result_handle.dispose()
    ```

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    JSHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.evaluate_handle started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.evaluate_handle(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= page.evaluate_handle succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.evaluate_handle failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expect_console_message"><code class="name flex">
<span>def <span class="ident">expect_console_message</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.async_api.ConsoleMessage" href="#playwright.async_api.ConsoleMessage">ConsoleMessage</a>')], bool] = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager[playwright.async_api._generated.ConsoleMessage]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expect_console_message</p>
<p>Performs action and waits for <code>console</code> event to fire. If predicate is provided, it passes <code><a title="playwright.async_api.ConsoleMessage" href="#playwright.async_api.ConsoleMessage">ConsoleMessage</a></code> value into
the <code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the page is
closed before the worker event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.ConsoleMessage" href="#playwright.async_api.ConsoleMessage">ConsoleMessage</a>], bool], NoneType]</code></dt>
<dd>Receives the <code><a title="playwright.async_api.ConsoleMessage" href="#playwright.async_api.ConsoleMessage">ConsoleMessage</a></code> object and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager[<a title="playwright.async_api.ConsoleMessage" href="#playwright.async_api.ConsoleMessage">ConsoleMessage</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_console_message(
    self,
    predicate: typing.Union[typing.Callable[[&#34;ConsoleMessage&#34;], bool]] = None,
    timeout: float = None,
) -&gt; AsyncEventContextManager[&#34;ConsoleMessage&#34;]:
    &#34;&#34;&#34;Page.expect_console_message

    Performs action and waits for `console` event to fire. If predicate is provided, it passes `ConsoleMessage` value into
    the `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
    closed before the worker event is fired.

    Parameters
    ----------
    predicate : Union[Callable[[ConsoleMessage], bool], NoneType]
        Receives the `ConsoleMessage` object and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager[ConsoleMessage]
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_console_message(
            predicate=self._wrap_handler(predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expect_download"><code class="name flex">
<span>def <span class="ident">expect_download</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.async_api.Download" href="#playwright.async_api.Download">Download</a>')], bool] = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager[playwright.async_api._generated.Download]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expect_download</p>
<p>Performs action and waits for <code>download</code> event to fire. If predicate is provided, it passes <code><a title="playwright.async_api.Download" href="#playwright.async_api.Download">Download</a></code> value into the
<code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the page is
closed before the download event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Download" href="#playwright.async_api.Download">Download</a>], bool], NoneType]</code></dt>
<dd>Receives the <code><a title="playwright.async_api.Download" href="#playwright.async_api.Download">Download</a></code> object and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager[<a title="playwright.async_api.Download" href="#playwright.async_api.Download">Download</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_download(
    self,
    predicate: typing.Union[typing.Callable[[&#34;Download&#34;], bool]] = None,
    timeout: float = None,
) -&gt; AsyncEventContextManager[&#34;Download&#34;]:
    &#34;&#34;&#34;Page.expect_download

    Performs action and waits for `download` event to fire. If predicate is provided, it passes `Download` value into the
    `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
    closed before the download event is fired.

    Parameters
    ----------
    predicate : Union[Callable[[Download], bool], NoneType]
        Receives the `Download` object and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager[Download]
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_download(
            predicate=self._wrap_handler(predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expect_event"><code class="name flex">
<span>def <span class="ident">expect_event</span></span>(<span>self, event: str, predicate: Callable = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expect_event</p>
<p>Performs action and waits for given <code>event</code> to fire. If predicate is provided, it passes event's value into the
<code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the page is
closed before the <code>event</code> is fired.</p>
<pre><code class="language-py">async with page.expect_event(event_name) as event_info:
    await page.click(&quot;button&quot;)
value = await event_info.value
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>Event name, same one typically passed into <code>*.on(event)</code>.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable, NoneType]</code></dt>
<dd>Receives the event data and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_event(
    self, event: str, predicate: typing.Callable = None, timeout: float = None
) -&gt; AsyncEventContextManager:
    &#34;&#34;&#34;Page.expect_event

    Performs action and waits for given `event` to fire. If predicate is provided, it passes event&#39;s value into the
    `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
    closed before the `event` is fired.

    ```py
    async with page.expect_event(event_name) as event_info:
        await page.click(\&#34;button\&#34;)
    value = await event_info.value
    ```

    Parameters
    ----------
    event : str
        Event name, same one typically passed into `*.on(event)`.
    predicate : Union[Callable, NoneType]
        Receives the event data and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_event(
            event=event, predicate=self._wrap_handler(predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expect_file_chooser"><code class="name flex">
<span>def <span class="ident">expect_file_chooser</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.async_api.FileChooser" href="#playwright.async_api.FileChooser">FileChooser</a>')], bool] = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager[playwright.async_api._generated.FileChooser]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expect_file_chooser</p>
<p>Performs action and waits for <code>filechooser</code> event to fire. If predicate is provided, it passes <code><a title="playwright.async_api.FileChooser" href="#playwright.async_api.FileChooser">FileChooser</a></code> value into
the <code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the page is
closed before the worker event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.FileChooser" href="#playwright.async_api.FileChooser">FileChooser</a>], bool], NoneType]</code></dt>
<dd>Receives the <code><a title="playwright.async_api.FileChooser" href="#playwright.async_api.FileChooser">FileChooser</a></code> object and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager[<a title="playwright.async_api.FileChooser" href="#playwright.async_api.FileChooser">FileChooser</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_file_chooser(
    self,
    predicate: typing.Union[typing.Callable[[&#34;FileChooser&#34;], bool]] = None,
    timeout: float = None,
) -&gt; AsyncEventContextManager[&#34;FileChooser&#34;]:
    &#34;&#34;&#34;Page.expect_file_chooser

    Performs action and waits for `filechooser` event to fire. If predicate is provided, it passes `FileChooser` value into
    the `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
    closed before the worker event is fired.

    Parameters
    ----------
    predicate : Union[Callable[[FileChooser], bool], NoneType]
        Receives the `FileChooser` object and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager[FileChooser]
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_file_chooser(
            predicate=self._wrap_handler(predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expect_navigation"><code class="name flex">
<span>def <span class="ident">expect_navigation</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expect_navigation</p>
<p>Performs action and waits for the next navigation. In case of multiple redirects, the navigation will resolve with the
response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the
navigation will resolve with <code>null</code>.</p>
<p>This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
cause the page to navigate. e.g. The click target has an <code>onclick</code> handler that triggers navigation from a <code>setTimeout</code>.
Consider this example:</p>
<pre><code class="language-py">async with page.expect_navigation():
    await page.click(&quot;a.delayed-navigation&quot;) # Clicking the link will indirectly cause a navigation
# Context manager waited for the navigation to happen.
</code></pre>
<blockquote>
<p>NOTE: Usage of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">History API</a> to change the URL is
considered a navigation.</p>
</blockquote>
<p>Shortcut for main frame's <code>frame.expect_navigation()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[Callable[[str], bool], Pattern, str, NoneType]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_navigation(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: float = None,
) -&gt; AsyncEventContextManager:
    &#34;&#34;&#34;Page.expect_navigation

    Performs action and waits for the next navigation. In case of multiple redirects, the navigation will resolve with the
    response of the last redirect. In case of navigation to a different anchor or navigation due to History API usage, the
    navigation will resolve with `null`.

    This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
    cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`.
    Consider this example:

    ```py
    async with page.expect_navigation():
        await page.click(\&#34;a.delayed-navigation\&#34;) # Clicking the link will indirectly cause a navigation
    # Context manager waited for the navigation to happen.
    ```

    &gt; NOTE: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is
    considered a navigation.

    Shortcut for main frame&#39;s `frame.expect_navigation()`.

    Parameters
    ----------
    url : Union[Callable[[str], bool], Pattern, str, NoneType]
        A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.

    Returns
    -------
    EventContextManager
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_navigation(
            url=self._wrap_handler(url), wait_until=wait_until, timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expect_popup"><code class="name flex">
<span>def <span class="ident">expect_popup</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>')], bool] = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager[playwright.async_api._generated.Page]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expect_popup</p>
<p>Performs action and waits for <code>popup</code> event to fire. If predicate is provided, it passes [Popup] value into the
<code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the page is
closed before the popup event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>], bool], NoneType]</code></dt>
<dd>Receives the [Popup] object and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager[<a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_popup(
    self,
    predicate: typing.Union[typing.Callable[[&#34;Page&#34;], bool]] = None,
    timeout: float = None,
) -&gt; AsyncEventContextManager[&#34;Page&#34;]:
    &#34;&#34;&#34;Page.expect_popup

    Performs action and waits for `popup` event to fire. If predicate is provided, it passes [Popup] value into the
    `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
    closed before the popup event is fired.

    Parameters
    ----------
    predicate : Union[Callable[[Page], bool], NoneType]
        Receives the [Popup] object and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager[Page]
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_popup(
            predicate=self._wrap_handler(predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expect_request"><code class="name flex">
<span>def <span class="ident">expect_request</span></span>(<span>self, url_or_predicate: Union[str, Pattern, Callable[[ForwardRef('<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>')], bool]], timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager[playwright.async_api._generated.Request]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expect_request</p>
<p>Performs action and waits for <code>response</code> event to fire. If predicate is provided, it passes <code><a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a></code> value into the
<code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the page is
closed before the download event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url_or_predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>], bool], Pattern, str]</code></dt>
<dd>Receives the <code><a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a></code> object and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager[<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_request(
    self,
    url_or_predicate: typing.Union[
        str, typing.Pattern, typing.Callable[[&#34;Request&#34;], bool]
    ],
    timeout: float = None,
) -&gt; AsyncEventContextManager[&#34;Request&#34;]:
    &#34;&#34;&#34;Page.expect_request

    Performs action and waits for `response` event to fire. If predicate is provided, it passes `Request` value into the
    `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
    closed before the download event is fired.

    Parameters
    ----------
    url_or_predicate : Union[Callable[[Request], bool], Pattern, str]
        Receives the `Request` object and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager[Request]
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_request(
            url_or_predicate=self._wrap_handler(url_or_predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expect_response"><code class="name flex">
<span>def <span class="ident">expect_response</span></span>(<span>self, url_or_predicate: Union[str, Pattern, Callable[[ForwardRef('<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>')], bool]], timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager[playwright.async_api._generated.Response]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expect_response</p>
<p>Performs action and waits for <code>response</code> event to fire. If predicate is provided, it passes <code><a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a></code> value into the
<code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the page is
closed before the download event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url_or_predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>], bool], Pattern, str]</code></dt>
<dd>Receives the <code><a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a></code> object and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_response(
    self,
    url_or_predicate: typing.Union[
        str, typing.Pattern, typing.Callable[[&#34;Response&#34;], bool]
    ],
    timeout: float = None,
) -&gt; AsyncEventContextManager[&#34;Response&#34;]:
    &#34;&#34;&#34;Page.expect_response

    Performs action and waits for `response` event to fire. If predicate is provided, it passes `Response` value into the
    `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
    closed before the download event is fired.

    Parameters
    ----------
    url_or_predicate : Union[Callable[[Response], bool], Pattern, str]
        Receives the `Response` object and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager[Response]
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_response(
            url_or_predicate=self._wrap_handler(url_or_predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expect_worker"><code class="name flex">
<span>def <span class="ident">expect_worker</span></span>(<span>self, predicate: Callable[[ForwardRef('<a title="playwright.async_api.Worker" href="#playwright.async_api.Worker">Worker</a>')], bool] = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager[playwright.async_api._generated.Worker]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expect_worker</p>
<p>Performs action and waits for <code>worker</code> event to fire. If predicate is provided, it passes <code><a title="playwright.async_api.Worker" href="#playwright.async_api.Worker">Worker</a></code> value into the
<code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the page is
closed before the worker event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Worker" href="#playwright.async_api.Worker">Worker</a>], bool], NoneType]</code></dt>
<dd>Receives the <code><a title="playwright.async_api.Worker" href="#playwright.async_api.Worker">Worker</a></code> object and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager[<a title="playwright.async_api.Worker" href="#playwright.async_api.Worker">Worker</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_worker(
    self,
    predicate: typing.Union[typing.Callable[[&#34;Worker&#34;], bool]] = None,
    timeout: float = None,
) -&gt; AsyncEventContextManager[&#34;Worker&#34;]:
    &#34;&#34;&#34;Page.expect_worker

    Performs action and waits for `worker` event to fire. If predicate is provided, it passes `Worker` value into the
    `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the page is
    closed before the worker event is fired.

    Parameters
    ----------
    predicate : Union[Callable[[Worker], bool], NoneType]
        Receives the `Worker` object and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager[Worker]
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_worker(
            predicate=self._wrap_handler(predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expose_binding"><code class="name flex">
<span>async def <span class="ident">expose_binding</span></span>(<span>self, name: str, callback: Callable, handle: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expose_binding</p>
<p>The method adds a function called <code>name</code> on the <code>window</code> object of every frame in this page. When called, the function
executes <code>callback</code> and returns a [Promise] which resolves to the return value of <code>callback</code>. If the <code>callback</code> returns
a [Promise], it will be awaited.</p>
<p>The first argument of the <code>callback</code> function contains information about the caller: <code>{ browserContext: BrowserContext,
page: Page, frame: Frame }</code>.</p>
<p>See <code>browser_context.expose_binding()</code> for the context-wide version.</p>
<blockquote>
<p>NOTE: Functions installed via <code>page.expose_binding()</code> survive navigations.</p>
</blockquote>
<p>An example of exposing page URL to all frames in a page:</p>
<pre><code class="language-py">import asyncio
from playwright.async_api import async_playwright

async def run(playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=false)
    context = await browser.new_context()
    page = await context.new_page()
    await page.expose_binding(&quot;pageURL&quot;, lambda source: source[&quot;page&quot;].url)
    await page.set_content(&quot;&quot;&quot;
    &lt;script&gt;
      async function onClick() {
        document.querySelector('div').textContent = await window.pageURL();
      }
    &lt;/script&gt;
    &lt;button onclick=&quot;onClick()&quot;&gt;Click me&lt;/button&gt;
    &lt;div&gt;&lt;/div&gt;
    &quot;&quot;&quot;)
    await page.click(&quot;button&quot;)

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
</code></pre>
<p>An example of passing an element handle:</p>
<pre><code class="language-py">async def print(source, element):
    print(await element.text_content())

await page.expose_binding(&quot;clicked&quot;, print, handle=true)
await page.set_content(&quot;&quot;&quot;
  &lt;script&gt;
    document.addEventListener('click', event =&gt; window.clicked(event.target));
  &lt;/script&gt;
  &lt;div&gt;Click me&lt;/div&gt;
  &lt;div&gt;Or click me&lt;/div&gt;
&quot;&quot;&quot;)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the function on the window object.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Callback function that will be called in the Playwright's context.</dd>
<dt><strong><code>handle</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is
supported. When passing by value, multiple arguments are supported.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def expose_binding(
    self, name: str, callback: typing.Callable, handle: bool = None
) -&gt; NoneType:
    &#34;&#34;&#34;Page.expose_binding

    The method adds a function called `name` on the `window` object of every frame in this page. When called, the function
    executes `callback` and returns a [Promise] which resolves to the return value of `callback`. If the `callback` returns
    a [Promise], it will be awaited.

    The first argument of the `callback` function contains information about the caller: `{ browserContext: BrowserContext,
    page: Page, frame: Frame }`.

    See `browser_context.expose_binding()` for the context-wide version.

    &gt; NOTE: Functions installed via `page.expose_binding()` survive navigations.

    An example of exposing page URL to all frames in a page:

    ```py
    import asyncio
    from playwright.async_api import async_playwright

    async def run(playwright):
        webkit = playwright.webkit
        browser = await webkit.launch(headless=false)
        context = await browser.new_context()
        page = await context.new_page()
        await page.expose_binding(\&#34;pageURL\&#34;, lambda source: source[\&#34;page\&#34;].url)
        await page.set_content(\&#34;\&#34;\&#34;
        &lt;script&gt;
          async function onClick() {
            document.querySelector(&#39;div&#39;).textContent = await window.pageURL();
          }
        &lt;/script&gt;
        &lt;button onclick=\&#34;onClick()\&#34;&gt;Click me&lt;/button&gt;
        &lt;div&gt;&lt;/div&gt;
        \&#34;\&#34;\&#34;)
        await page.click(\&#34;button\&#34;)

    async def main():
        async with async_playwright() as playwright:
            await run(playwright)
    asyncio.run(main())
    ```

    An example of passing an element handle:

    ```py
    async def print(source, element):
        print(await element.text_content())

    await page.expose_binding(\&#34;clicked\&#34;, print, handle=true)
    await page.set_content(\&#34;\&#34;\&#34;
      &lt;script&gt;
        document.addEventListener(&#39;click&#39;, event =&gt; window.clicked(event.target));
      &lt;/script&gt;
      &lt;div&gt;Click me&lt;/div&gt;
      &lt;div&gt;Or click me&lt;/div&gt;
    \&#34;\&#34;\&#34;)
    ```

    Parameters
    ----------
    name : str
        Name of the function on the window object.
    callback : Callable
        Callback function that will be called in the Playwright&#39;s context.
    handle : Union[bool, NoneType]
        Whether to pass the argument as a handle, instead of passing by value. When passing a handle, only one argument is
        supported. When passing by value, multiple arguments are supported.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.expose_binding started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.expose_binding(
                name=name, callback=self._wrap_handler(callback), handle=handle
            )
        )
        log_api(&#34;&lt;= page.expose_binding succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.expose_binding failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.expose_function"><code class="name flex">
<span>async def <span class="ident">expose_function</span></span>(<span>self, name: str, callback: Callable) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.expose_function</p>
<p>The method adds a function called <code>name</code> on the <code>window</code> object of every frame in the page. When called, the function
executes <code>callback</code> and returns a [Promise] which resolves to the return value of <code>callback</code>.</p>
<p>If the <code>callback</code> returns a [Promise], it will be awaited.</p>
<p>See <code>browser_context.expose_function()</code> for context-wide exposed function.</p>
<blockquote>
<p>NOTE: Functions installed via <code>page.expose_function()</code> survive navigations.</p>
</blockquote>
<p>An example of adding an <code>sha1</code> function to the page:</p>
<pre><code class="language-py">import asyncio
import hashlib
from playwright.async_api import async_playwright

async def sha1(text):
    m = hashlib.sha1()
    m.update(bytes(text, &quot;utf8&quot;))
    return m.hexdigest()

async def run(playwright):
    webkit = playwright.webkit
    browser = await webkit.launch(headless=False)
    page = await browser.new_page()
    await page.expose_function(&quot;sha1&quot;, sha1)
    await page.set_content(&quot;&quot;&quot;
        &lt;script&gt;
          async function onClick() {
            document.querySelector('div').textContent = await window.sha1('PLAYWRIGHT');
          }
        &lt;/script&gt;
        &lt;button onclick=&quot;onClick()&quot;&gt;Click me&lt;/button&gt;
        &lt;div&gt;&lt;/div&gt;
    &quot;&quot;&quot;)
    await page.click(&quot;button&quot;)

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the function on the window object</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Callback function which will be called in Playwright's context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def expose_function(self, name: str, callback: typing.Callable) -&gt; NoneType:
    &#34;&#34;&#34;Page.expose_function

    The method adds a function called `name` on the `window` object of every frame in the page. When called, the function
    executes `callback` and returns a [Promise] which resolves to the return value of `callback`.

    If the `callback` returns a [Promise], it will be awaited.

    See `browser_context.expose_function()` for context-wide exposed function.

    &gt; NOTE: Functions installed via `page.expose_function()` survive navigations.

    An example of adding an `sha1` function to the page:

    ```py
    import asyncio
    import hashlib
    from playwright.async_api import async_playwright

    async def sha1(text):
        m = hashlib.sha1()
        m.update(bytes(text, \&#34;utf8\&#34;))
        return m.hexdigest()

    async def run(playwright):
        webkit = playwright.webkit
        browser = await webkit.launch(headless=False)
        page = await browser.new_page()
        await page.expose_function(\&#34;sha1\&#34;, sha1)
        await page.set_content(\&#34;\&#34;\&#34;
            &lt;script&gt;
              async function onClick() {
                document.querySelector(&#39;div&#39;).textContent = await window.sha1(&#39;PLAYWRIGHT&#39;);
              }
            &lt;/script&gt;
            &lt;button onclick=\&#34;onClick()\&#34;&gt;Click me&lt;/button&gt;
            &lt;div&gt;&lt;/div&gt;
        \&#34;\&#34;\&#34;)
        await page.click(\&#34;button\&#34;)

    async def main():
        async with async_playwright() as playwright:
            await run(playwright)
    asyncio.run(main())
    ```

    Parameters
    ----------
    name : str
        Name of the function on the window object
    callback : Callable
        Callback function which will be called in Playwright&#39;s context.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.expose_function started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.expose_function(
                name=name, callback=self._wrap_handler(callback)
            )
        )
        log_api(&#34;&lt;= page.expose_function succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.expose_function failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.fill"><code class="name flex">
<span>async def <span class="ident">fill</span></span>(<span>self, selector: str, value: str, timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.fill</p>
<p>This method waits for an element matching <code>selector</code>, waits for <a href="./actionability.md">actionability</a> checks, focuses the
element, fills it and triggers an <code>input</code> event after filling. If the element matching <code>selector</code> is not an <code>&lt;input&gt;</code>,
<code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element, this method throws an error. Note that you can pass an empty string to
clear the input field.</p>
<p>To send fine-grained keyboard events, use <code>page.type()</code>.</p>
<p>Shortcut for main frame's <code>frame.fill()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Value to fill for the <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code> or <code>[contenteditable]</code> element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fill(
    self,
    selector: str,
    value: str,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.fill

    This method waits for an element matching `selector`, waits for [actionability](./actionability.md) checks, focuses the
    element, fills it and triggers an `input` event after filling. If the element matching `selector` is not an `&lt;input&gt;`,
    `&lt;textarea&gt;` or `[contenteditable]` element, this method throws an error. Note that you can pass an empty string to
    clear the input field.

    To send fine-grained keyboard events, use `page.type()`.

    Shortcut for main frame&#39;s `frame.fill()`

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    value : str
        Value to fill for the `&lt;input&gt;`, `&lt;textarea&gt;` or `[contenteditable]` element.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.fill started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.fill(
                selector=selector,
                value=value,
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.fill succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.fill failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.focus"><code class="name flex">
<span>async def <span class="ident">focus</span></span>(<span>self, selector: str, timeout: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.focus</p>
<p>This method fetches an element with <code>selector</code> and focuses it. If there's no element matching <code>selector</code>, the method
waits until a matching element appears in the DOM.</p>
<p>Shortcut for main frame's <code>frame.focus()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def focus(self, selector: str, timeout: float = None) -&gt; NoneType:
    &#34;&#34;&#34;Page.focus

    This method fetches an element with `selector` and focuses it. If there&#39;s no element matching `selector`, the method
    waits until a matching element appears in the DOM.

    Shortcut for main frame&#39;s `frame.focus()`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.focus started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.focus(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.focus succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.focus failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.frame"><code class="name flex">
<span>def <span class="ident">frame</span></span>(<span>self, name: str = None, url: Union[str, Pattern, Callable[[str], bool]] = None) ‑> Union[playwright.async_api._generated.Frame, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.frame</p>
<p>Returns frame matching the specified criteria. Either <code>name</code> or <code>url</code> must be specified.</p>
<pre><code class="language-py">frame = page.frame(name=&quot;frame-name&quot;)
</code></pre>
<pre><code class="language-py">frame = page.frame(url=r&quot;.*domain.*&quot;)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Frame name specified in the <code>iframe</code>'s <code>name</code> attribute. Optional.</dd>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[Callable[[str], bool], Pattern, str, NoneType]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving frame's <code>url</code> as a [URL] object. Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frame(
    self,
    name: str = None,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
) -&gt; typing.Union[&#34;Frame&#34;, NoneType]:
    &#34;&#34;&#34;Page.frame

    Returns frame matching the specified criteria. Either `name` or `url` must be specified.

    ```py
    frame = page.frame(name=\&#34;frame-name\&#34;)
    ```

    ```py
    frame = page.frame(url=r\&#34;.*domain.*\&#34;)
    ```

    Parameters
    ----------
    name : Union[str, NoneType]
        Frame name specified in the `iframe`&#39;s `name` attribute. Optional.
    url : Union[Callable[[str], bool], Pattern, str, NoneType]
        A glob pattern, regex pattern or predicate receiving frame&#39;s `url` as a [URL] object. Optional.

    Returns
    -------
    Union[Frame, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.frame started&#34;)
        result = mapping.from_impl_nullable(
            self._impl_obj.frame(name=name, url=self._wrap_handler(url))
        )
        log_api(&#34;&lt;= page.frame succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.frame failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.get_attribute"><code class="name flex">
<span>async def <span class="ident">get_attribute</span></span>(<span>self, selector: str, name: str, timeout: float = None) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.get_attribute</p>
<p>Returns element attribute value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Attribute name to get the value for.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_attribute(
    self, selector: str, name: str, timeout: float = None
) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Page.get_attribute

    Returns element attribute value.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    name : str
        Attribute name to get the value for.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.get_attribute started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.get_attribute(
                selector=selector, name=name, timeout=timeout
            )
        )
        log_api(&#34;&lt;= page.get_attribute succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.get_attribute failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.go_back"><code class="name flex">
<span>async def <span class="ident">go_back</span></span>(<span>self, timeout: float = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> Union[playwright.async_api._generated.Response, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.go_back</p>
<p>Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
last redirect. If can not go back, returns <code>null</code>.</p>
<p>Navigate to the previous page in history.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def go_back(
    self,
    timeout: float = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.go_back

    Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
    last redirect. If can not go back, returns `null`.

    Navigate to the previous page in history.

    Parameters
    ----------
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.

    Returns
    -------
    Union[Response, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.go_back started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.go_back(timeout=timeout, waitUntil=wait_until)
        )
        log_api(&#34;&lt;= page.go_back succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.go_back failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.go_forward"><code class="name flex">
<span>async def <span class="ident">go_forward</span></span>(<span>self, timeout: float = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> Union[playwright.async_api._generated.Response, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.go_forward</p>
<p>Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
last redirect. If can not go forward, returns <code>null</code>.</p>
<p>Navigate to the next page in history.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def go_forward(
    self,
    timeout: float = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.go_forward

    Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
    last redirect. If can not go forward, returns `null`.

    Navigate to the next page in history.

    Parameters
    ----------
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.

    Returns
    -------
    Union[Response, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.go_forward started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.go_forward(timeout=timeout, waitUntil=wait_until)
        )
        log_api(&#34;&lt;= page.go_forward succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.go_forward failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.goto"><code class="name flex">
<span>async def <span class="ident">goto</span></span>(<span>self, url: str, timeout: float = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None, referer: str = None) ‑> Union[playwright.async_api._generated.Response, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.goto</p>
<p>Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
last redirect.</p>
<p><code>page.goto</code> will throw an error if:
- there's an SSL error (e.g. in case of self-signed certificates).
- target URL is invalid.
- the <code>timeout</code> is exceeded during navigation.
- the remote server does not respond or is unreachable.
- the main resource failed to load.</p>
<p><code>page.goto</code> will not throw an error when any valid HTTP status code is returned by the remote server, including 404 "Not
Found" and 500 "Internal Server Error".
The status code for such responses can be retrieved by calling
<code>response.status()</code>.</p>
<blockquote>
<p>NOTE: <code>page.goto</code> either throws an error or returns a main resource response. The only exceptions are navigation to
<code>about:blank</code> or navigation to the same URL with a different hash, which would succeed and return <code>null</code>.
NOTE: Headless mode doesn't support navigation to a PDF document. See the
<a href="https://bugs.chromium.org/p/chromium/issues/detail?id=761295">upstream issue</a>.</p>
</blockquote>
<p>Shortcut for main frame's <code>frame.goto()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL to navigate page to. The url should include scheme, e.g. <code>https://</code>.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>referer</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Referer header value. If provided it will take preference over the referer header value set by
<code>page.set_extra_http_headers()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def goto(
    self,
    url: str,
    timeout: float = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    referer: str = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.goto

    Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
    last redirect.

    `page.goto` will throw an error if:
    - there&#39;s an SSL error (e.g. in case of self-signed certificates).
    - target URL is invalid.
    - the `timeout` is exceeded during navigation.
    - the remote server does not respond or is unreachable.
    - the main resource failed to load.

    `page.goto` will not throw an error when any valid HTTP status code is returned by the remote server, including 404 \&#34;Not
    Found\&#34; and 500 \&#34;Internal Server Error\&#34;.  The status code for such responses can be retrieved by calling
    `response.status()`.

    &gt; NOTE: `page.goto` either throws an error or returns a main resource response. The only exceptions are navigation to
    `about:blank` or navigation to the same URL with a different hash, which would succeed and return `null`.
    &gt; NOTE: Headless mode doesn&#39;t support navigation to a PDF document. See the
    [upstream issue](https://bugs.chromium.org/p/chromium/issues/detail?id=761295).

    Shortcut for main frame&#39;s `frame.goto()`

    Parameters
    ----------
    url : str
        URL to navigate page to. The url should include scheme, e.g. `https://`.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
    referer : Union[str, NoneType]
        Referer header value. If provided it will take preference over the referer header value set by
        `page.set_extra_http_headers()`.

    Returns
    -------
    Union[Response, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.goto started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.goto(
                url=url, timeout=timeout, waitUntil=wait_until, referer=referer
            )
        )
        log_api(&#34;&lt;= page.goto succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.goto failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.hover"><code class="name flex">
<span>async def <span class="ident">hover</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, timeout: float = None, force: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.hover</p>
<p>This method hovers over an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to hover over the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<p>Shortcut for main frame's <code>frame.hover()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def hover(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    timeout: float = None,
    force: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.hover

    This method hovers over an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to hover over the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Shortcut for main frame&#39;s `frame.hover()`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.hover started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.hover(
                selector=selector,
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
            )
        )
        log_api(&#34;&lt;= page.hover succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.hover failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.inner_html"><code class="name flex">
<span>async def <span class="ident">inner_html</span></span>(<span>self, selector: str, timeout: float = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Page.inner_html</p>
<p>Returns <code>element.innerHTML</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def inner_html(self, selector: str, timeout: float = None) -&gt; str:
    &#34;&#34;&#34;Page.inner_html

    Returns `element.innerHTML`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.inner_html started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.inner_html(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.inner_html succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.inner_html failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.inner_text"><code class="name flex">
<span>async def <span class="ident">inner_text</span></span>(<span>self, selector: str, timeout: float = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Page.inner_text</p>
<p>Returns <code>element.innerText</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def inner_text(self, selector: str, timeout: float = None) -&gt; str:
    &#34;&#34;&#34;Page.inner_text

    Returns `element.innerText`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.inner_text started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.inner_text(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.inner_text succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.inner_text failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.is_checked"><code class="name flex">
<span>async def <span class="ident">is_checked</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Page.is_checked</p>
<p>Returns whether the element is checked. Throws if the element is not a checkbox or radio input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_checked(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Page.is_checked

    Returns whether the element is checked. Throws if the element is not a checkbox or radio input.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.is_checked started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_checked(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.is_checked succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.is_checked failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.is_closed"><code class="name flex">
<span>def <span class="ident">is_closed</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Page.is_closed</p>
<p>Indicates that the page has been closed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_closed(self) -&gt; bool:
    &#34;&#34;&#34;Page.is_closed

    Indicates that the page has been closed.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.is_closed started&#34;)
        result = mapping.from_maybe_impl(self._impl_obj.is_closed())
        log_api(&#34;&lt;= page.is_closed succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.is_closed failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.is_disabled"><code class="name flex">
<span>async def <span class="ident">is_disabled</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Page.is_disabled</p>
<p>Returns whether the element is disabled, the opposite of <a href="./actionability.md#enabled">enabled</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_disabled(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Page.is_disabled

    Returns whether the element is disabled, the opposite of [enabled](./actionability.md#enabled).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.is_disabled started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_disabled(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.is_disabled succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.is_disabled failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.is_editable"><code class="name flex">
<span>async def <span class="ident">is_editable</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Page.is_editable</p>
<p>Returns whether the element is <a href="./actionability.md#editable">editable</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_editable(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Page.is_editable

    Returns whether the element is [editable](./actionability.md#editable).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.is_editable started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_editable(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.is_editable succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.is_editable failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.is_enabled"><code class="name flex">
<span>async def <span class="ident">is_enabled</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Page.is_enabled</p>
<p>Returns whether the element is <a href="./actionability.md#enabled">enabled</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_enabled(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Page.is_enabled

    Returns whether the element is [enabled](./actionability.md#enabled).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.is_enabled started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_enabled(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.is_enabled succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.is_enabled failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.is_hidden"><code class="name flex">
<span>async def <span class="ident">is_hidden</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Page.is_hidden</p>
<p>Returns whether the element is hidden, the opposite of <a href="./actionability.md#visible">visible</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_hidden(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Page.is_hidden

    Returns whether the element is hidden, the opposite of [visible](./actionability.md#visible).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.is_hidden started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_hidden(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.is_hidden succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.is_hidden failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.is_visible"><code class="name flex">
<span>async def <span class="ident">is_visible</span></span>(<span>self, selector: str, timeout: float = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Page.is_visible</p>
<p>Returns whether the element is <a href="./actionability.md#visible">visible</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def is_visible(self, selector: str, timeout: float = None) -&gt; bool:
    &#34;&#34;&#34;Page.is_visible

    Returns whether the element is [visible](./actionability.md#visible).

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.is_visible started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.is_visible(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.is_visible succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.is_visible failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.opener"><code class="name flex">
<span>async def <span class="ident">opener</span></span>(<span>self) ‑> Union[playwright.async_api._generated.Page, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.opener</p>
<p>Returns the opener for popup pages and <code>null</code> for others. If the opener has been closed already the returns <code>null</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def opener(self) -&gt; typing.Union[&#34;Page&#34;, NoneType]:
    &#34;&#34;&#34;Page.opener

    Returns the opener for popup pages and `null` for others. If the opener has been closed already the returns `null`.

    Returns
    -------
    Union[Page, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.opener started&#34;)
        result = mapping.from_impl_nullable(await self._impl_obj.opener())
        log_api(&#34;&lt;= page.opener succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.opener failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.pdf"><code class="name flex">
<span>async def <span class="ident">pdf</span></span>(<span>self, scale: float = None, display_header_footer: bool = None, header_template: str = None, footer_template: str = None, print_background: bool = None, landscape: bool = None, page_ranges: str = None, format: str = None, width: Union[str, float] = None, height: Union[str, float] = None, prefer_css_page_size: bool = None, margin: playwright._impl._api_structures.PdfMargins = None, path: Union[str, pathlib.Path] = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Page.pdf</p>
<p>Returns the PDF buffer.</p>
<blockquote>
<p>NOTE: Generating a pdf is currently only supported in Chromium headless.</p>
</blockquote>
<p><code>page.pdf()</code> generates a pdf of the page with <code>print</code> css media. To generate a pdf with <code>screen</code> media, call
<code>page.emulate_media()</code> before calling <code>page.pdf()</code>:</p>
<blockquote>
<p>NOTE: By default, <code>page.pdf()</code> generates a pdf with modified colors for printing. Use the
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust"><code>-webkit-print-color-adjust</code></a> property to
force rendering of exact colors.</p>
</blockquote>
<pre><code class="language-py"># generates a pdf with &quot;screen&quot; media type.
await page.emulate_media(media=&quot;screen&quot;)
await page.pdf(path=&quot;page.pdf&quot;)
</code></pre>
<p>The <code>width</code>, <code>height</code>, and <code>margin</code> options accept values labeled with units. Unlabeled values are treated as pixels.</p>
<p>A few examples:
- <code>page.pdf({width: 100})</code> - prints with width set to 100 pixels
- <code>page.pdf({width: '100px'})</code> - prints with width set to 100 pixels
- <code>page.pdf({width: '10cm'})</code> - prints with width set to 10 centimeters.</p>
<p>All possible units are:
- <code>px</code> - pixel
- <code>in</code> - inch
- <code>cm</code> - centimeter
- <code>mm</code> - millimeter</p>
<p>The <code>format</code> options are:
- <code>Letter</code>: 8.5in x 11in
- <code>Legal</code>: 8.5in x 14in
- <code>Tabloid</code>: 11in x 17in
- <code>Ledger</code>: 17in x 11in
- <code>A0</code>: 33.1in x 46.8in
- <code>A1</code>: 23.4in x 33.1in
- <code>A2</code>: 16.54in x 23.4in
- <code>A3</code>: 11.7in x 16.54in
- <code>A4</code>: 8.27in x 11.7in
- <code>A5</code>: 5.83in x 8.27in
- <code>A6</code>: 4.13in x 5.83in</p>
<blockquote>
<p>NOTE: <code>headerTemplate</code> and <code>footerTemplate</code> markup have the following limitations: &gt; 1. Script tags inside templates
are not evaluated. &gt; 2. Page styles are not visible inside templates.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scale</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Scale of the webpage rendering. Defaults to <code>1</code>. Scale amount must be between 0.1 and 2.</dd>
<dt><strong><code>display_header_footer</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Display header and footer. Defaults to <code>false</code>.</dd>
<dt><strong><code>header_template</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values
into them:
- <code>'date'</code> formatted print date
- <code>'title'</code> document title
- <code>'url'</code> document location
- <code>'pageNumber'</code> current page number
- <code>'totalPages'</code> total pages in the document</dd>
<dt><strong><code>footer_template</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>HTML template for the print footer. Should use the same format as the <code>headerTemplate</code>.</dd>
<dt><strong><code>print_background</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Print background graphics. Defaults to <code>false</code>.</dd>
<dt><strong><code>landscape</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Paper orientation. Defaults to <code>false</code>.</dd>
<dt><strong><code>page_ranges</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Paper ranges to print, e.g., '1-5, 8, 11-13'. Defaults to the empty string, which means print all pages.</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Paper format. If set, takes priority over <code>width</code> or <code>height</code> options. Defaults to 'Letter'.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>Union[float, str, NoneType]</code></dt>
<dd>Paper width, accepts values labeled with units.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>Union[float, str, NoneType]</code></dt>
<dd>Paper height, accepts values labeled with units.</dd>
<dt><strong><code>prefer_css_page_size</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Give any CSS <code>@page</code> size declared in the page priority over what is declared in <code>width</code> and <code>height</code> or <code>format</code>
options. Defaults to <code>false</code>, which will scale the content to fit the paper size.</dd>
<dt><strong><code>margin</code></strong> :&ensp;<code>Union[{top: Union[float, str, NoneType], right: Union[float, str, NoneType], bottom: Union[float, str, NoneType], left: Union[float, str, NoneType]}, NoneType]</code></dt>
<dd>Paper margins, defaults to none.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>The file path to save the PDF to. If <code>path</code> is a relative path, then it is resolved relative to the current working
directory. If no path is provided, the PDF won't be saved to the disk.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def pdf(
    self,
    scale: float = None,
    display_header_footer: bool = None,
    header_template: str = None,
    footer_template: str = None,
    print_background: bool = None,
    landscape: bool = None,
    page_ranges: str = None,
    format: str = None,
    width: typing.Union[str, float] = None,
    height: typing.Union[str, float] = None,
    prefer_css_page_size: bool = None,
    margin: PdfMargins = None,
    path: typing.Union[str, pathlib.Path] = None,
) -&gt; bytes:
    &#34;&#34;&#34;Page.pdf

    Returns the PDF buffer.

    &gt; NOTE: Generating a pdf is currently only supported in Chromium headless.

    `page.pdf()` generates a pdf of the page with `print` css media. To generate a pdf with `screen` media, call
    `page.emulate_media()` before calling `page.pdf()`:

    &gt; NOTE: By default, `page.pdf()` generates a pdf with modified colors for printing. Use the
    [`-webkit-print-color-adjust`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust) property to
    force rendering of exact colors.

    ```py
    # generates a pdf with \&#34;screen\&#34; media type.
    await page.emulate_media(media=\&#34;screen\&#34;)
    await page.pdf(path=\&#34;page.pdf\&#34;)
    ```

    The `width`, `height`, and `margin` options accept values labeled with units. Unlabeled values are treated as pixels.

    A few examples:
    - `page.pdf({width: 100})` - prints with width set to 100 pixels
    - `page.pdf({width: &#39;100px&#39;})` - prints with width set to 100 pixels
    - `page.pdf({width: &#39;10cm&#39;})` - prints with width set to 10 centimeters.

    All possible units are:
    - `px` - pixel
    - `in` - inch
    - `cm` - centimeter
    - `mm` - millimeter

    The `format` options are:
    - `Letter`: 8.5in x 11in
    - `Legal`: 8.5in x 14in
    - `Tabloid`: 11in x 17in
    - `Ledger`: 17in x 11in
    - `A0`: 33.1in x 46.8in
    - `A1`: 23.4in x 33.1in
    - `A2`: 16.54in x 23.4in
    - `A3`: 11.7in x 16.54in
    - `A4`: 8.27in x 11.7in
    - `A5`: 5.83in x 8.27in
    - `A6`: 4.13in x 5.83in

    &gt; NOTE: `headerTemplate` and `footerTemplate` markup have the following limitations: &gt; 1. Script tags inside templates
    are not evaluated. &gt; 2. Page styles are not visible inside templates.

    Parameters
    ----------
    scale : Union[float, NoneType]
        Scale of the webpage rendering. Defaults to `1`. Scale amount must be between 0.1 and 2.
    display_header_footer : Union[bool, NoneType]
        Display header and footer. Defaults to `false`.
    header_template : Union[str, NoneType]
        HTML template for the print header. Should be valid HTML markup with following classes used to inject printing values
        into them:
        - `&#39;date&#39;` formatted print date
        - `&#39;title&#39;` document title
        - `&#39;url&#39;` document location
        - `&#39;pageNumber&#39;` current page number
        - `&#39;totalPages&#39;` total pages in the document
    footer_template : Union[str, NoneType]
        HTML template for the print footer. Should use the same format as the `headerTemplate`.
    print_background : Union[bool, NoneType]
        Print background graphics. Defaults to `false`.
    landscape : Union[bool, NoneType]
        Paper orientation. Defaults to `false`.
    page_ranges : Union[str, NoneType]
        Paper ranges to print, e.g., &#39;1-5, 8, 11-13&#39;. Defaults to the empty string, which means print all pages.
    format : Union[str, NoneType]
        Paper format. If set, takes priority over `width` or `height` options. Defaults to &#39;Letter&#39;.
    width : Union[float, str, NoneType]
        Paper width, accepts values labeled with units.
    height : Union[float, str, NoneType]
        Paper height, accepts values labeled with units.
    prefer_css_page_size : Union[bool, NoneType]
        Give any CSS `@page` size declared in the page priority over what is declared in `width` and `height` or `format`
        options. Defaults to `false`, which will scale the content to fit the paper size.
    margin : Union[{top: Union[float, str, NoneType], right: Union[float, str, NoneType], bottom: Union[float, str, NoneType], left: Union[float, str, NoneType]}, NoneType]
        Paper margins, defaults to none.
    path : Union[pathlib.Path, str, NoneType]
        The file path to save the PDF to. If `path` is a relative path, then it is resolved relative to the current working
        directory. If no path is provided, the PDF won&#39;t be saved to the disk.

    Returns
    -------
    bytes
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.pdf started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.pdf(
                scale=scale,
                displayHeaderFooter=display_header_footer,
                headerTemplate=header_template,
                footerTemplate=footer_template,
                printBackground=print_background,
                landscape=landscape,
                pageRanges=page_ranges,
                format=format,
                width=width,
                height=height,
                preferCSSPageSize=prefer_css_page_size,
                margin=margin,
                path=path,
            )
        )
        log_api(&#34;&lt;= page.pdf succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.pdf failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.press"><code class="name flex">
<span>async def <span class="ident">press</span></span>(<span>self, selector: str, key: str, delay: float = None, timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.press</p>
<p>Focuses the element, and then uses <code>keyboard.down()</code> and <code>keyboard.up()</code>.</p>
<p><code>key</code> can specify the intended <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key">keyboardEvent.key</a>
value or a single character to generate the text for. A superset of the <code>key</code> values can be found
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values">here</a>. Examples of the keys are:</p>
<p><code>F1</code> - <code>F12</code>, <code>Digit0</code>- <code>Digit9</code>, <code>KeyA</code>- <code>KeyZ</code>, <code>Backquote</code>, <code>Minus</code>, <code>Equal</code>, <code>Backslash</code>, <code>Backspace</code>, <code>Tab</code>,
<code>Delete</code>, <code>Escape</code>, <code>ArrowDown</code>, <code>End</code>, <code>Enter</code>, <code>Home</code>, <code>Insert</code>, <code>PageDown</code>, <code>PageUp</code>, <code>ArrowRight</code>, <code>ArrowUp</code>, etc.</p>
<p>Following modification shortcuts are also supported: <code>Shift</code>, <code>Control</code>, <code>Alt</code>, <code>Meta</code>, <code>ShiftLeft</code>.</p>
<p>Holding down <code>Shift</code> will type the text that corresponds to the <code>key</code> in the upper case.</p>
<p>If <code>key</code> is a single character, it is case-sensitive, so the values <code>a</code> and <code>A</code> will generate different respective
texts.</p>
<p>Shortcuts such as <code>key: "Control+o"</code> or <code>key: "Control+Shift+T"</code> are supported as well. When speficied with the
modifier, modifier is pressed and being held while the subsequent key is being pressed.</p>
<pre><code class="language-py">page = await browser.new_page()
await page.goto(&quot;https://keycode.info&quot;)
await page.press(&quot;body&quot;, &quot;A&quot;)
await page.screenshot(path=&quot;a.png&quot;)
await page.press(&quot;body&quot;, &quot;ArrowLeft&quot;)
await page.screenshot(path=&quot;arrow_left.png&quot;)
await page.press(&quot;body&quot;, &quot;Shift+O&quot;)
await page.screenshot(path=&quot;o.png&quot;)
await browser.close()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the key to press or a character to generate, such as <code>ArrowLeft</code> or <code>a</code>.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between <code>keydown</code> and <code>keyup</code> in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def press(
    self,
    selector: str,
    key: str,
    delay: float = None,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.press

    Focuses the element, and then uses `keyboard.down()` and `keyboard.up()`.

    `key` can specify the intended [keyboardEvent.key](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
    value or a single character to generate the text for. A superset of the `key` values can be found
    [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values). Examples of the keys are:

    `F1` - `F12`, `Digit0`- `Digit9`, `KeyA`- `KeyZ`, `Backquote`, `Minus`, `Equal`, `Backslash`, `Backspace`, `Tab`,
    `Delete`, `Escape`, `ArrowDown`, `End`, `Enter`, `Home`, `Insert`, `PageDown`, `PageUp`, `ArrowRight`, `ArrowUp`, etc.

    Following modification shortcuts are also supported: `Shift`, `Control`, `Alt`, `Meta`, `ShiftLeft`.

    Holding down `Shift` will type the text that corresponds to the `key` in the upper case.

    If `key` is a single character, it is case-sensitive, so the values `a` and `A` will generate different respective
    texts.

    Shortcuts such as `key: \&#34;Control+o\&#34;` or `key: \&#34;Control+Shift+T\&#34;` are supported as well. When speficied with the
    modifier, modifier is pressed and being held while the subsequent key is being pressed.

    ```py
    page = await browser.new_page()
    await page.goto(\&#34;https://keycode.info\&#34;)
    await page.press(\&#34;body\&#34;, \&#34;A\&#34;)
    await page.screenshot(path=\&#34;a.png\&#34;)
    await page.press(\&#34;body\&#34;, \&#34;ArrowLeft\&#34;)
    await page.screenshot(path=\&#34;arrow_left.png\&#34;)
    await page.press(\&#34;body\&#34;, \&#34;Shift+O\&#34;)
    await page.screenshot(path=\&#34;o.png\&#34;)
    await browser.close()
    ```

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    key : str
        Name of the key to press or a character to generate, such as `ArrowLeft` or `a`.
    delay : Union[float, NoneType]
        Time to wait between `keydown` and `keyup` in milliseconds. Defaults to 0.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.press started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.press(
                selector=selector,
                key=key,
                delay=delay,
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.press succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.press failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.query_selector"><code class="name flex">
<span>async def <span class="ident">query_selector</span></span>(<span>self, selector: str) ‑> Union[playwright.async_api._generated.ElementHandle, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.query_selector</p>
<p>The method finds an element matching the specified selector within the page. If no elements match the selector, the
return value resolves to <code>null</code>.</p>
<p>Shortcut for main frame's <code>frame.$()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_selector(
    self, selector: str
) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;Page.query_selector

    The method finds an element matching the specified selector within the page. If no elements match the selector, the
    return value resolves to `null`.

    Shortcut for main frame&#39;s `frame.$()`.

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

    Returns
    -------
    Union[ElementHandle, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.query_selector started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.query_selector(selector=selector)
        )
        log_api(&#34;&lt;= page.query_selector succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.query_selector failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.query_selector_all"><code class="name flex">
<span>async def <span class="ident">query_selector_all</span></span>(<span>self, selector: str) ‑> List[playwright.async_api._generated.ElementHandle]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.query_selector_all</p>
<p>The method finds all elements matching the specified selector within the page. If no elements match the selector, the
return value resolves to <code>[]</code>.</p>
<p>Shortcut for main frame's <code>frame.$$()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_selector_all(self, selector: str) -&gt; typing.List[&#34;ElementHandle&#34;]:
    &#34;&#34;&#34;Page.query_selector_all

    The method finds all elements matching the specified selector within the page. If no elements match the selector, the
    return value resolves to `[]`.

    Shortcut for main frame&#39;s `frame.$$()`.

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.

    Returns
    -------
    List[ElementHandle]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.query_selector_all started&#34;)
        result = mapping.from_impl_list(
            await self._impl_obj.query_selector_all(selector=selector)
        )
        log_api(&#34;&lt;= page.query_selector_all succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.query_selector_all failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.reload"><code class="name flex">
<span>async def <span class="ident">reload</span></span>(<span>self, timeout: float = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> Union[playwright.async_api._generated.Response, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.reload</p>
<p>Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
last redirect.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def reload(
    self,
    timeout: float = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.reload

    Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
    last redirect.

    Parameters
    ----------
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.

    Returns
    -------
    Union[Response, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.reload started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.reload(timeout=timeout, waitUntil=wait_until)
        )
        log_api(&#34;&lt;= page.reload succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.reload failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.route"><code class="name flex">
<span>async def <span class="ident">route</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]], handler: Union[Callable[[ForwardRef('<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>')], Any], Callable[[ForwardRef('<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>'), ForwardRef('<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>')], Any]]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.route</p>
<p>Routing provides the capability to modify network requests that are made by a page.</p>
<p>Once routing is enabled, every request matching the url pattern will stall unless it's continued, fulfilled or aborted.</p>
<blockquote>
<p>NOTE: The handler will only be called for the first url if the response is a redirect.</p>
</blockquote>
<p>An example of a naïve handler that aborts all image requests:</p>
<pre><code class="language-py">page = await browser.new_page()
await page.route(&quot;**/*.{png,jpg,jpeg}&quot;, lambda route: route.abort())
await page.goto(&quot;https://example.com&quot;)
await browser.close()
</code></pre>
<p>or the same snippet using a regex pattern instead:</p>
<pre><code class="language-py">page = await browser.new_page()
await page.route(r&quot;(\.png$)|(\.jpg$)&quot;, lambda route: route.abort())
await page.goto(&quot;https://example.com&quot;)
await browser.close()
</code></pre>
<p>Page routes take precedence over browser context routes (set up with <code>browser_context.route()</code>) when request
matches both handlers.</p>
<blockquote>
<p>NOTE: Enabling routing disables http cache.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[Callable[[str], bool], Pattern, str]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving [URL] to match while routing.</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>, <a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>], Any], Callable[[<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>], Any]]</code></dt>
<dd>handler function to route the request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def route(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
    handler: typing.Union[
        typing.Callable[[&#34;Route&#34;], typing.Any],
        typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
    ],
) -&gt; NoneType:
    &#34;&#34;&#34;Page.route

    Routing provides the capability to modify network requests that are made by a page.

    Once routing is enabled, every request matching the url pattern will stall unless it&#39;s continued, fulfilled or aborted.

    &gt; NOTE: The handler will only be called for the first url if the response is a redirect.

    An example of a naïve handler that aborts all image requests:

    ```py
    page = await browser.new_page()
    await page.route(\&#34;**/*.{png,jpg,jpeg}\&#34;, lambda route: route.abort())
    await page.goto(\&#34;https://example.com\&#34;)
    await browser.close()
    ```

    or the same snippet using a regex pattern instead:

    ```py
    page = await browser.new_page()
    await page.route(r\&#34;(\\.png$)|(\\.jpg$)\&#34;, lambda route: route.abort())
    await page.goto(\&#34;https://example.com\&#34;)
    await browser.close()
    ```

    Page routes take precedence over browser context routes (set up with `browser_context.route()`) when request
    matches both handlers.

    &gt; NOTE: Enabling routing disables http cache.

    Parameters
    ----------
    url : Union[Callable[[str], bool], Pattern, str]
        A glob pattern, regex pattern or predicate receiving [URL] to match while routing.
    handler : Union[Callable[[Route, Request], Any], Callable[[Route], Any]]
        handler function to route the request.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.route started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.route(
                url=self._wrap_handler(url), handler=self._wrap_handler(handler)
            )
        )
        log_api(&#34;&lt;= page.route succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.route failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.screenshot"><code class="name flex">
<span>async def <span class="ident">screenshot</span></span>(<span>self, timeout: float = None, type: Literal['jpeg', 'png'] = None, path: Union[str, pathlib.Path] = None, quality: int = None, omit_background: bool = None, full_page: bool = None, clip: playwright._impl._api_structures.FloatRect = None) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Page.screenshot</p>
<p>Returns the buffer with the captured screenshot.</p>
<blockquote>
<p>NOTE: Screenshots take at least 1/6 second on Chromium OS X and Chromium Windows. See <a href="https://crbug.com/741689">https://crbug.com/741689</a> for
discussion.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>Union["jpeg", "png", NoneType]</code></dt>
<dd>Specify screenshot type, defaults to <code>png</code>.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>The file path to save the image to. The screenshot type will be inferred from file extension. If <code>path</code> is a relative
path, then it is resolved relative to the current working directory. If no path is provided, the image won't be saved to
the disk.</dd>
<dt><strong><code>quality</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>The quality of the image, between 0-100. Not applicable to <code>png</code> images.</dd>
<dt><strong><code>omit_background</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Hides default white background and allows capturing screenshots with transparency. Not applicable to <code>jpeg</code> images.
Defaults to <code>false</code>.</dd>
<dt><strong><code>full_page</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>When true, takes a screenshot of the full scrollable page, instead of the currently visible viewport. Defaults to
<code>false</code>.</dd>
<dt><strong><code>clip</code></strong> :&ensp;<code>Union[{x: float, y: float, width: float, height: float}, NoneType]</code></dt>
<dd>An object which specifies clipping of the resulting image. Should have the following fields:</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def screenshot(
    self,
    timeout: float = None,
    type: Literal[&#34;jpeg&#34;, &#34;png&#34;] = None,
    path: typing.Union[str, pathlib.Path] = None,
    quality: int = None,
    omit_background: bool = None,
    full_page: bool = None,
    clip: FloatRect = None,
) -&gt; bytes:
    &#34;&#34;&#34;Page.screenshot

    Returns the buffer with the captured screenshot.

    &gt; NOTE: Screenshots take at least 1/6 second on Chromium OS X and Chromium Windows. See https://crbug.com/741689 for
    discussion.

    Parameters
    ----------
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    type : Union[&#34;jpeg&#34;, &#34;png&#34;, NoneType]
        Specify screenshot type, defaults to `png`.
    path : Union[pathlib.Path, str, NoneType]
        The file path to save the image to. The screenshot type will be inferred from file extension. If `path` is a relative
        path, then it is resolved relative to the current working directory. If no path is provided, the image won&#39;t be saved to
        the disk.
    quality : Union[int, NoneType]
        The quality of the image, between 0-100. Not applicable to `png` images.
    omit_background : Union[bool, NoneType]
        Hides default white background and allows capturing screenshots with transparency. Not applicable to `jpeg` images.
        Defaults to `false`.
    full_page : Union[bool, NoneType]
        When true, takes a screenshot of the full scrollable page, instead of the currently visible viewport. Defaults to
        `false`.
    clip : Union[{x: float, y: float, width: float, height: float}, NoneType]
        An object which specifies clipping of the resulting image. Should have the following fields:

    Returns
    -------
    bytes
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.screenshot started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.screenshot(
                timeout=timeout,
                type=type,
                path=path,
                quality=quality,
                omitBackground=omit_background,
                fullPage=full_page,
                clip=clip,
            )
        )
        log_api(&#34;&lt;= page.screenshot succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.screenshot failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.select_option"><code class="name flex">
<span>async def <span class="ident">select_option</span></span>(<span>self, selector: str, value: Union[str, List[str]] = None, index: Union[int, List[int]] = None, label: Union[str, List[str]] = None, element: Union[ForwardRef('<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>'), List[ForwardRef('<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>')]] = None, timeout: float = None, no_wait_after: bool = None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.select_option</p>
<p>Returns the array of option values that have been successfully selected.</p>
<p>Triggers a <code>change</code> and <code>input</code> event once all the provided options have been selected. If there's no <code>&lt;select&gt;</code> element
matching <code>selector</code>, the method throws an error.</p>
<pre><code class="language-py"># single selection matching the value
await page.select_option(&quot;select#colors&quot;, &quot;blue&quot;)
# single selection matching the label
await page.select_option(&quot;select#colors&quot;, label=&quot;blue&quot;)
# multiple selection
await page.select_option(&quot;select#colors&quot;, value=[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;])
</code></pre>
<p>Shortcut for main frame's <code>frame.select_option()</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>Union[List[str], str, NoneType]</code></dt>
<dd>Options to select by value. If the <code>&lt;select&gt;</code> has the <code>multiple</code> attribute, all given options are selected, otherwise
only the first option matching one of the passed options is selected. Optional.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>Union[List[int], int, NoneType]</code></dt>
<dd>Options to select by index. Optional.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>Union[List[str], str, NoneType]</code></dt>
<dd>Options to select by label. If the <code>&lt;select&gt;</code> has the <code>multiple</code> attribute, all given options are selected, otherwise
only the first option matching one of the passed options is selected. Optional.</dd>
<dt><strong><code>element</code></strong> :&ensp;<code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, List[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>], NoneType]</code></dt>
<dd>Option elements to select. Optional.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def select_option(
    self,
    selector: str,
    value: typing.Union[str, typing.List[str]] = None,
    index: typing.Union[int, typing.List[int]] = None,
    label: typing.Union[str, typing.List[str]] = None,
    element: typing.Union[&#34;ElementHandle&#34;, typing.List[&#34;ElementHandle&#34;]] = None,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; typing.List[str]:
    &#34;&#34;&#34;Page.select_option

    Returns the array of option values that have been successfully selected.

    Triggers a `change` and `input` event once all the provided options have been selected. If there&#39;s no `&lt;select&gt;` element
    matching `selector`, the method throws an error.

    ```py
    # single selection matching the value
    await page.select_option(\&#34;select#colors\&#34;, \&#34;blue\&#34;)
    # single selection matching the label
    await page.select_option(\&#34;select#colors\&#34;, label=\&#34;blue\&#34;)
    # multiple selection
    await page.select_option(\&#34;select#colors\&#34;, value=[\&#34;red\&#34;, \&#34;green\&#34;, \&#34;blue\&#34;])
    ```

    Shortcut for main frame&#39;s `frame.select_option()`

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    value : Union[List[str], str, NoneType]
        Options to select by value. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
        only the first option matching one of the passed options is selected. Optional.
    index : Union[List[int], int, NoneType]
        Options to select by index. Optional.
    label : Union[List[str], str, NoneType]
        Options to select by label. If the `&lt;select&gt;` has the `multiple` attribute, all given options are selected, otherwise
        only the first option matching one of the passed options is selected. Optional.
    element : Union[ElementHandle, List[ElementHandle], NoneType]
        Option elements to select. Optional.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.

    Returns
    -------
    List[str]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.select_option started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.select_option(
                selector=selector,
                value=value,
                index=index,
                label=label,
                element=mapping.to_impl(element),
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.select_option succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.select_option failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.set_content"><code class="name flex">
<span>async def <span class="ident">set_content</span></span>(<span>self, html: str, timeout: float = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.set_content</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>html</code></strong> :&ensp;<code>str</code></dt>
<dd>HTML markup to assign to the page.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_content(
    self,
    html: str,
    timeout: float = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.set_content

    Parameters
    ----------
    html : str
        HTML markup to assign to the page.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.set_content started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_content(
                html=html, timeout=timeout, waitUntil=wait_until
            )
        )
        log_api(&#34;&lt;= page.set_content succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.set_content failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.set_default_navigation_timeout"><code class="name flex">
<span>def <span class="ident">set_default_navigation_timeout</span></span>(<span>self, timeout: float) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.set_default_navigation_timeout</p>
<p>This setting will change the default maximum navigation time for the following methods and related shortcuts:
- <code>page.go_back()</code>
- <code>page.go_forward()</code>
- <code>page.goto()</code>
- <code>page.reload()</code>
- <code>page.set_content()</code>
- <code>page.wait_for_navigation()</code></p>
<blockquote>
<p>NOTE: <code>page.set_default_navigation_timeout()</code> takes priority over <code>page.set_default_timeout()</code>,
<code>browser_context.set_default_timeout()</code> and <code>browser_context.set_default_navigation_timeout()</code>.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum navigation time in milliseconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_navigation_timeout(self, timeout: float) -&gt; NoneType:
    &#34;&#34;&#34;Page.set_default_navigation_timeout

    This setting will change the default maximum navigation time for the following methods and related shortcuts:
    - `page.go_back()`
    - `page.go_forward()`
    - `page.goto()`
    - `page.reload()`
    - `page.set_content()`
    - `page.wait_for_navigation()`

    &gt; NOTE: `page.set_default_navigation_timeout()` takes priority over `page.set_default_timeout()`,
    `browser_context.set_default_timeout()` and `browser_context.set_default_navigation_timeout()`.

    Parameters
    ----------
    timeout : float
        Maximum navigation time in milliseconds
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.set_default_navigation_timeout started&#34;)
        result = mapping.from_maybe_impl(
            self._impl_obj.set_default_navigation_timeout(timeout=timeout)
        )
        log_api(&#34;&lt;= page.set_default_navigation_timeout succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.set_default_navigation_timeout failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.set_default_timeout"><code class="name flex">
<span>def <span class="ident">set_default_timeout</span></span>(<span>self, timeout: float) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.set_default_timeout</p>
<p>This setting will change the default maximum time for all the methods accepting <code>timeout</code> option.</p>
<blockquote>
<p>NOTE: <code>page.set_default_navigation_timeout()</code> takes priority over <code>page.set_default_timeout()</code>.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>Maximum time in milliseconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_timeout(self, timeout: float) -&gt; NoneType:
    &#34;&#34;&#34;Page.set_default_timeout

    This setting will change the default maximum time for all the methods accepting `timeout` option.

    &gt; NOTE: `page.set_default_navigation_timeout()` takes priority over `page.set_default_timeout()`.

    Parameters
    ----------
    timeout : float
        Maximum time in milliseconds
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.set_default_timeout started&#34;)
        result = mapping.from_maybe_impl(
            self._impl_obj.set_default_timeout(timeout=timeout)
        )
        log_api(&#34;&lt;= page.set_default_timeout succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.set_default_timeout failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.set_extra_http_headers"><code class="name flex">
<span>async def <span class="ident">set_extra_http_headers</span></span>(<span>self, headers: Dict[str, str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.set_extra_http_headers</p>
<p>The extra HTTP headers will be sent with every request the page initiates.</p>
<blockquote>
<p>NOTE: <code>page.set_extra_http_headers()</code> does not guarantee the order of headers in the outgoing requests.</p>
</blockquote>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>headers</code></strong> :&ensp;<code>Dict[str, str]</code></dt>
<dd>An object containing additional HTTP headers to be sent with every request. All header values must be strings.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_extra_http_headers(self, headers: typing.Dict[str, str]) -&gt; NoneType:
    &#34;&#34;&#34;Page.set_extra_http_headers

    The extra HTTP headers will be sent with every request the page initiates.

    &gt; NOTE: `page.set_extra_http_headers()` does not guarantee the order of headers in the outgoing requests.

    Parameters
    ----------
    headers : Dict[str, str]
        An object containing additional HTTP headers to be sent with every request. All header values must be strings.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.set_extra_http_headers started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_extra_http_headers(
                headers=mapping.to_impl(headers)
            )
        )
        log_api(&#34;&lt;= page.set_extra_http_headers succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.set_extra_http_headers failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.set_input_files"><code class="name flex">
<span>async def <span class="ident">set_input_files</span></span>(<span>self, selector: str, files: Union[str, pathlib.Path, playwright._impl._api_structures.FilePayload, List[Union[str, pathlib.Path]], List[playwright._impl._api_structures.FilePayload]], timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.set_input_files</p>
<p>This method expects <code>selector</code> to point to an
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">input element</a>.</p>
<p>Sets the value of the file input to these file paths or files. If some of the <code>filePaths</code> are relative paths, then they
are resolved relative to the the current working directory. For empty array, clears the selected files.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>files</code></strong> :&ensp;<code>Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_input_files(
    self,
    selector: str,
    files: typing.Union[
        str,
        pathlib.Path,
        FilePayload,
        typing.List[typing.Union[str, pathlib.Path]],
        typing.List[FilePayload],
    ],
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.set_input_files

    This method expects `selector` to point to an
    [input element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input).

    Sets the value of the file input to these file paths or files. If some of the `filePaths` are relative paths, then they
    are resolved relative to the the current working directory. For empty array, clears the selected files.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    files : Union[List[Union[pathlib.Path, str]], List[{name: str, mimeType: str, buffer: bytes}], pathlib.Path, str, {name: str, mimeType: str, buffer: bytes}]
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.set_input_files started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_input_files(
                selector=selector,
                files=files,
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.set_input_files succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.set_input_files failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.set_viewport_size"><code class="name flex">
<span>async def <span class="ident">set_viewport_size</span></span>(<span>self, viewport_size: playwright._impl._api_structures.ViewportSize) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.set_viewport_size</p>
<p>In the case of multiple pages in a single browser, each page can have its own viewport size. However,
<code>browser.new_context()</code> allows to set viewport size (and more) for all pages in the context at once.</p>
<p><code>page.setViewportSize</code> will resize the page. A lot of websites don't expect phones to change size, so you should set the
viewport size before navigating to the page.</p>
<pre><code class="language-py">page = await browser.new_page()
await page.set_viewport_size({&quot;width&quot;: 640, &quot;height&quot;: 480})
await page.goto(&quot;https://example.com&quot;)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>viewport_size</code></strong> :&ensp;<code>{width: int, height: int}</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_viewport_size(self, viewport_size: ViewportSize) -&gt; NoneType:
    &#34;&#34;&#34;Page.set_viewport_size

    In the case of multiple pages in a single browser, each page can have its own viewport size. However,
    `browser.new_context()` allows to set viewport size (and more) for all pages in the context at once.

    `page.setViewportSize` will resize the page. A lot of websites don&#39;t expect phones to change size, so you should set the
    viewport size before navigating to the page.

    ```py
    page = await browser.new_page()
    await page.set_viewport_size({\&#34;width\&#34;: 640, \&#34;height\&#34;: 480})
    await page.goto(\&#34;https://example.com\&#34;)
    ```

    Parameters
    ----------
    viewport_size : {width: int, height: int}
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.set_viewport_size started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.set_viewport_size(viewportSize=viewport_size)
        )
        log_api(&#34;&lt;= page.set_viewport_size succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.set_viewport_size failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.tap"><code class="name flex">
<span>async def <span class="ident">tap</span></span>(<span>self, selector: str, modifiers: List[Literal['Alt', 'Control', 'Meta', 'Shift']] = None, position: playwright._impl._api_structures.Position = None, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.tap</p>
<p>This method taps an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.touchscreen</code> to tap the center of the element, or the specified <code>position</code>.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<blockquote>
<p>NOTE: <code>page.tap()</code> requires that the <code>hasTouch</code> option of the browser context be set to true.</p>
</blockquote>
<p>Shortcut for main frame's <code>frame.tap()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>modifiers</code></strong> :&ensp;<code>Union[List[Union["Alt", "Control", "Meta", "Shift"]], NoneType]</code></dt>
<dd>Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
modifiers back. If not specified, currently pressed modifiers are used.</dd>
<dt><strong><code>position</code></strong> :&ensp;<code>Union[{x: float, y: float}, NoneType]</code></dt>
<dd>A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
element.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def tap(
    self,
    selector: str,
    modifiers: typing.Union[
        typing.List[Literal[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]]
    ] = None,
    position: Position = None,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.tap

    This method taps an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.touchscreen` to tap the center of the element, or the specified `position`.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    &gt; NOTE: `page.tap()` requires that the `hasTouch` option of the browser context be set to true.

    Shortcut for main frame&#39;s `frame.tap()`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    modifiers : Union[List[Union[&#34;Alt&#34;, &#34;Control&#34;, &#34;Meta&#34;, &#34;Shift&#34;]], NoneType]
        Modifier keys to press. Ensures that only these modifiers are pressed during the operation, and then restores current
        modifiers back. If not specified, currently pressed modifiers are used.
    position : Union[{x: float, y: float}, NoneType]
        A point to use relative to the top-left corner of element padding box. If not specified, uses some visible point of the
        element.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.tap started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.tap(
                selector=selector,
                modifiers=modifiers,
                position=position,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.tap succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.tap failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.text_content"><code class="name flex">
<span>async def <span class="ident">text_content</span></span>(<span>self, selector: str, timeout: float = None) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.text_content</p>
<p>Returns <code>element.textContent</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def text_content(
    self, selector: str, timeout: float = None
) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Page.text_content

    Returns `element.textContent`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.text_content started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.text_content(selector=selector, timeout=timeout)
        )
        log_api(&#34;&lt;= page.text_content succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.text_content failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.title"><code class="name flex">
<span>async def <span class="ident">title</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Page.title</p>
<p>Returns the page's title. Shortcut for main frame's <code>frame.title()</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def title(self) -&gt; str:
    &#34;&#34;&#34;Page.title

    Returns the page&#39;s title. Shortcut for main frame&#39;s `frame.title()`.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.title started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.title())
        log_api(&#34;&lt;= page.title succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.title failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.type"><code class="name flex">
<span>async def <span class="ident">type</span></span>(<span>self, selector: str, text: str, delay: float = None, timeout: float = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.type</p>
<p>Sends a <code>keydown</code>, <code>keypress</code>/<code>input</code>, and <code>keyup</code> event for each character in the text. <code>page.type</code> can be used to send
fine-grained keyboard events. To fill values in form fields, use <code>page.fill()</code>.</p>
<p>To press a special key, like <code>Control</code> or <code>ArrowDown</code>, use <code>keyboard.press()</code>.</p>
<pre><code class="language-py">await page.type(&quot;#mytextarea&quot;, &quot;hello&quot;) # types instantly
await page.type(&quot;#mytextarea&quot;, &quot;world&quot;, delay=100) # types slower, like a user
</code></pre>
<p>Shortcut for main frame's <code>frame.type()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>A text to type into a focused element.</dd>
<dt><strong><code>delay</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Time to wait between key presses in milliseconds. Defaults to 0.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def type(
    self,
    selector: str,
    text: str,
    delay: float = None,
    timeout: float = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.type

    Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character in the text. `page.type` can be used to send
    fine-grained keyboard events. To fill values in form fields, use `page.fill()`.

    To press a special key, like `Control` or `ArrowDown`, use `keyboard.press()`.

    ```py
    await page.type(\&#34;#mytextarea\&#34;, \&#34;hello\&#34;) # types instantly
    await page.type(\&#34;#mytextarea\&#34;, \&#34;world\&#34;, delay=100) # types slower, like a user
    ```

    Shortcut for main frame&#39;s `frame.type()`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    text : str
        A text to type into a focused element.
    delay : Union[float, NoneType]
        Time to wait between key presses in milliseconds. Defaults to 0.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.type started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.type(
                selector=selector,
                text=text,
                delay=delay,
                timeout=timeout,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.type succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.type failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.uncheck"><code class="name flex">
<span>async def <span class="ident">uncheck</span></span>(<span>self, selector: str, timeout: float = None, force: bool = None, no_wait_after: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.uncheck</p>
<p>This method unchecks an element matching <code>selector</code> by performing the following steps:
1. Find an element match matching <code>selector</code>. If there is none, wait until a matching element is attached to the DOM.
1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
unchecked, this method returns immediately.
1. Wait for <a href="./actionability.md">actionability</a> checks on the matched element, unless <code>force</code> option is set. If the
element is detached during the checks, the whole action is retried.
1. Scroll the element into view if needed.
1. Use <code>page.mouse</code> to click in the center of the element.
1. Wait for initiated navigations to either succeed or fail, unless <code>noWaitAfter</code> option is set.
1. Ensure that the element is now unchecked. If not, this method rejects.</p>
<p>When all steps combined have not finished during the specified <code>timeout</code>, this method rejects with a <code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code>.
Passing zero timeout disables this.</p>
<p>Shortcut for main frame's <code>frame.uncheck()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
<a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to bypass the <a href="./actionability.md">actionability</a> checks. Defaults to <code>false</code>.</dd>
<dt><strong><code>no_wait_after</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
inaccessible pages. Defaults to <code>false</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def uncheck(
    self,
    selector: str,
    timeout: float = None,
    force: bool = None,
    no_wait_after: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.uncheck

    This method unchecks an element matching `selector` by performing the following steps:
    1. Find an element match matching `selector`. If there is none, wait until a matching element is attached to the DOM.
    1. Ensure that matched element is a checkbox or a radio input. If not, this method rejects. If the element is already
       unchecked, this method returns immediately.
    1. Wait for [actionability](./actionability.md) checks on the matched element, unless `force` option is set. If the
       element is detached during the checks, the whole action is retried.
    1. Scroll the element into view if needed.
    1. Use `page.mouse` to click in the center of the element.
    1. Wait for initiated navigations to either succeed or fail, unless `noWaitAfter` option is set.
    1. Ensure that the element is now unchecked. If not, this method rejects.

    When all steps combined have not finished during the specified `timeout`, this method rejects with a `TimeoutError`.
    Passing zero timeout disables this.

    Shortcut for main frame&#39;s `frame.uncheck()`.

    Parameters
    ----------
    selector : str
        A selector to search for element. If there are multiple elements satisfying the selector, the first will be used. See
        [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    force : Union[bool, NoneType]
        Whether to bypass the [actionability](./actionability.md) checks. Defaults to `false`.
    no_wait_after : Union[bool, NoneType]
        Actions that initiate navigations are waiting for these navigations to happen and for pages to start loading. You can
        opt out of waiting via setting this flag. You would only need this option in the exceptional cases such as navigating to
        inaccessible pages. Defaults to `false`.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.uncheck started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.uncheck(
                selector=selector,
                timeout=timeout,
                force=force,
                noWaitAfter=no_wait_after,
            )
        )
        log_api(&#34;&lt;= page.uncheck succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.uncheck failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.unroute"><code class="name flex">
<span>async def <span class="ident">unroute</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]], handler: Union[Callable[[ForwardRef('<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>')], Any], Callable[[ForwardRef('<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>'), ForwardRef('<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>')], Any]] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.unroute</p>
<p>Removes a route created with <code>page.route()</code>. When <code>handler</code> is not specified, removes all routes for the <code>url</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[Callable[[str], bool], Pattern, str]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving [URL] to match while routing.</dd>
<dt><strong><code>handler</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>, <a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>], Any], Callable[[<a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a>], Any], NoneType]</code></dt>
<dd>Optional handler function to route the request.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def unroute(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]],
    handler: typing.Union[
        typing.Callable[[&#34;Route&#34;], typing.Any],
        typing.Callable[[&#34;Route&#34;, &#34;Request&#34;], typing.Any],
    ] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.unroute

    Removes a route created with `page.route()`. When `handler` is not specified, removes all routes for the `url`.

    Parameters
    ----------
    url : Union[Callable[[str], bool], Pattern, str]
        A glob pattern, regex pattern or predicate receiving [URL] to match while routing.
    handler : Union[Callable[[Route, Request], Any], Callable[[Route], Any], NoneType]
        Optional handler function to route the request.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.unroute started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.unroute(
                url=self._wrap_handler(url), handler=self._wrap_handler(handler)
            )
        )
        log_api(&#34;&lt;= page.unroute succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.unroute failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.wait_for_event"><code class="name flex">
<span>async def <span class="ident">wait_for_event</span></span>(<span>self, event: str, predicate: Callable = None, timeout: float = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Page.wait_for_event</p>
<p>Returns the event data value.</p>
<p>Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
value. Will throw an error if the page is closed before the event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>Event name, same one typically passed into <code>*.on(event)</code>.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable, NoneType]</code></dt>
<dd>Receives the event data and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_event(
    self, event: str, predicate: typing.Callable = None, timeout: float = None
) -&gt; typing.Any:
    &#34;&#34;&#34;Page.wait_for_event

    Returns the event data value.

    Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
    value. Will throw an error if the page is closed before the event is fired.

    Parameters
    ----------
    event : str
        Event name, same one typically passed into `*.on(event)`.
    predicate : Union[Callable, NoneType]
        Receives the event data and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.wait_for_event started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.wait_for_event(
                event=event,
                predicate=self._wrap_handler(predicate),
                timeout=timeout,
            )
        )
        log_api(&#34;&lt;= page.wait_for_event succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.wait_for_event failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.wait_for_function"><code class="name flex">
<span>async def <span class="ident">wait_for_function</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None, timeout: float = None, polling: Union[float, Literal['raf']] = None) ‑> playwright.async_api._generated.JSHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Page.wait_for_function</p>
<p>Returns when the <code>pageFunction</code> returns a truthy value. It resolves to a JSHandle of the truthy value.</p>
<p>The <code>waitForFunction</code> can be used to observe viewport size change:</p>
<pre><code class="language-py">import asyncio
from playwright.async_api import async_playwright

async def run(playwright):
    webkit = playwright.webkit
    browser = await webkit.launch()
    page = await browser.new_page()
    watch_dog = page.wait_for_function(&quot;() =&gt; window.innerWidth &lt; 100&quot;)
    await page.set_viewport_size({&quot;width&quot;: 50, &quot;height&quot;: 50})
    await watch_dog
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
</code></pre>
<p>To pass an argument to the predicate of <code>page.wait_for_function()</code> function:</p>
<pre><code class="language-py">selector = &quot;.foo&quot;
await page.wait_for_function(&quot;selector =&gt; !!document.querySelector(selector)&quot;, selector)
</code></pre>
<p>Shortcut for main frame's <code>frame.wait_for_function()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
<dt><strong><code>polling</code></strong> :&ensp;<code>Union["raf", float, NoneType]</code></dt>
<dd>If <code>polling</code> is <code>'raf'</code>, then <code>pageFunction</code> is constantly executed in <code>requestAnimationFrame</code> callback. If <code>polling</code> is
a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to <code>raf</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_function(
    self,
    expression: str,
    arg: typing.Any = None,
    force_expr: bool = None,
    timeout: float = None,
    polling: typing.Union[float, Literal[&#34;raf&#34;]] = None,
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Page.wait_for_function

    Returns when the `pageFunction` returns a truthy value. It resolves to a JSHandle of the truthy value.

    The `waitForFunction` can be used to observe viewport size change:

    ```py
    import asyncio
    from playwright.async_api import async_playwright

    async def run(playwright):
        webkit = playwright.webkit
        browser = await webkit.launch()
        page = await browser.new_page()
        watch_dog = page.wait_for_function(\&#34;() =&gt; window.innerWidth &lt; 100\&#34;)
        await page.set_viewport_size({\&#34;width\&#34;: 50, \&#34;height\&#34;: 50})
        await watch_dog
        await browser.close()

    async def main():
        async with async_playwright() as playwright:
            await run(playwright)
    asyncio.run(main())
    ```

    To pass an argument to the predicate of `page.wait_for_function()` function:

    ```py
    selector = \&#34;.foo\&#34;
    await page.wait_for_function(\&#34;selector =&gt; !!document.querySelector(selector)\&#34;, selector)
    ```

    Shortcut for main frame&#39;s `frame.wait_for_function()`.

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.
    timeout : Union[float, NoneType]
        maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.
    polling : Union[&#34;raf&#34;, float, NoneType]
        If `polling` is `&#39;raf&#39;`, then `pageFunction` is constantly executed in `requestAnimationFrame` callback. If `polling` is
        a number, then it is treated as an interval in milliseconds at which the function would be executed. Defaults to `raf`.

    Returns
    -------
    JSHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.wait_for_function started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.wait_for_function(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
                timeout=timeout,
                polling=polling,
            )
        )
        log_api(&#34;&lt;= page.wait_for_function succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.wait_for_function failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.wait_for_load_state"><code class="name flex">
<span>async def <span class="ident">wait_for_load_state</span></span>(<span>self, state: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: float = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.wait_for_load_state</p>
<p>Returns when the required load state has been reached.</p>
<p>This resolves when the page reaches a required load state, <code>load</code> by default. The navigation must have been committed
when this method is called. If current document has already reached the required state, resolves immediately.</p>
<pre><code class="language-py">await page.click(&quot;button&quot;) # click triggers navigation.
await page.wait_for_load_state() # the promise resolves after &quot;load&quot; event.
</code></pre>
<pre><code class="language-py">async with page.expect_popup() as page_info:
    await page.click(&quot;button&quot;) # click triggers a popup.
popup = await page_info.value
 # Following resolves after &quot;domcontentloaded&quot; event.
await popup.wait_for_load_state(&quot;domcontentloaded&quot;)
print(await popup.title()) # popup is ready to use.
</code></pre>
<p>Shortcut for main frame's <code>frame.wait_for_load_state()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>Optional load state to wait for, defaults to <code>load</code>. If the state has been already reached while loading current
document, the method resolves immediately. Can be one of:
- <code>'load'</code> - wait for the <code>load</code> event to be fired.
- <code>'domcontentloaded'</code> - wait for the <code>DOMContentLoaded</code> event to be fired.
- <code>'networkidle'</code> - wait until there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_load_state(
    self,
    state: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: float = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Page.wait_for_load_state

    Returns when the required load state has been reached.

    This resolves when the page reaches a required load state, `load` by default. The navigation must have been committed
    when this method is called. If current document has already reached the required state, resolves immediately.

    ```py
    await page.click(\&#34;button\&#34;) # click triggers navigation.
    await page.wait_for_load_state() # the promise resolves after \&#34;load\&#34; event.
    ```

    ```py
    async with page.expect_popup() as page_info:
        await page.click(\&#34;button\&#34;) # click triggers a popup.
    popup = await page_info.value
     # Following resolves after \&#34;domcontentloaded\&#34; event.
    await popup.wait_for_load_state(\&#34;domcontentloaded\&#34;)
    print(await popup.title()) # popup is ready to use.
    ```

    Shortcut for main frame&#39;s `frame.wait_for_load_state()`.

    Parameters
    ----------
    state : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        Optional load state to wait for, defaults to `load`. If the state has been already reached while loading current
        document, the method resolves immediately. Can be one of:
        - `&#39;load&#39;` - wait for the `load` event to be fired.
        - `&#39;domcontentloaded&#39;` - wait for the `DOMContentLoaded` event to be fired.
        - `&#39;networkidle&#39;` - wait until there are no network connections for at least `500` ms.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.wait_for_load_state started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.wait_for_load_state(state=state, timeout=timeout)
        )
        log_api(&#34;&lt;= page.wait_for_load_state succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.wait_for_load_state failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.wait_for_navigation"><code class="name flex">
<span>async def <span class="ident">wait_for_navigation</span></span>(<span>self, url: Union[str, Pattern, Callable[[str], bool]] = None, wait_until: Literal['domcontentloaded', 'load', 'networkidle'] = None, timeout: float = None) ‑> Union[playwright.async_api._generated.Response, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.wait_for_navigation</p>
<p>Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will
resolve with <code>null</code>.</p>
<p>This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
cause the page to navigate. e.g. The click target has an <code>onclick</code> handler that triggers navigation from a <code>setTimeout</code>.
Consider this example:</p>
<pre><code class="language-py">async with page.expect_navigation():
    await page.click(&quot;a.delayed-navigation&quot;) # clicking the link will indirectly cause a navigation
# Resolves after navigation has finished
</code></pre>
<blockquote>
<p>NOTE: Usage of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">History API</a> to change the URL is
considered a navigation.</p>
</blockquote>
<p>Shortcut for main frame's <code>frame.wait_for_navigation()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[Callable[[str], bool], Pattern, str, NoneType]</code></dt>
<dd>A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation.</dd>
<dt><strong><code>wait_until</code></strong> :&ensp;<code>Union["domcontentloaded", "load", "networkidle", NoneType]</code></dt>
<dd>When to consider operation succeeded, defaults to <code>load</code>. Events can be either:
- <code>'domcontentloaded'</code> - consider operation to be finished when the <code>DOMContentLoaded</code> event is fired.
- <code>'load'</code> - consider operation to be finished when the <code>load</code> event is fired.
- <code>'networkidle'</code> - consider operation to be finished when there are no network connections for at least <code>500</code> ms.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum operation time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be
changed by using the <code>browser_context.set_default_navigation_timeout()</code>,
<code>browser_context.set_default_timeout()</code>, <code>page.set_default_navigation_timeout()</code> or
<code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_navigation(
    self,
    url: typing.Union[str, typing.Pattern, typing.Callable[[str], bool]] = None,
    wait_until: Literal[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;] = None,
    timeout: float = None,
) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Page.wait_for_navigation

    Returns the main resource response. In case of multiple redirects, the navigation will resolve with the response of the
    last redirect. In case of navigation to a different anchor or navigation due to History API usage, the navigation will
    resolve with `null`.

    This resolves when the page navigates to a new URL or reloads. It is useful for when you run code which will indirectly
    cause the page to navigate. e.g. The click target has an `onclick` handler that triggers navigation from a `setTimeout`.
    Consider this example:

    ```py
    async with page.expect_navigation():
        await page.click(\&#34;a.delayed-navigation\&#34;) # clicking the link will indirectly cause a navigation
    # Resolves after navigation has finished
    ```

    &gt; NOTE: Usage of the [History API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) to change the URL is
    considered a navigation.

    Shortcut for main frame&#39;s `frame.wait_for_navigation()`.

    Parameters
    ----------
    url : Union[Callable[[str], bool], Pattern, str, NoneType]
        A glob pattern, regex pattern or predicate receiving [URL] to match while waiting for the navigation.
    wait_until : Union[&#34;domcontentloaded&#34;, &#34;load&#34;, &#34;networkidle&#34;, NoneType]
        When to consider operation succeeded, defaults to `load`. Events can be either:
        - `&#39;domcontentloaded&#39;` - consider operation to be finished when the `DOMContentLoaded` event is fired.
        - `&#39;load&#39;` - consider operation to be finished when the `load` event is fired.
        - `&#39;networkidle&#39;` - consider operation to be finished when there are no network connections for at least `500` ms.
    timeout : Union[float, NoneType]
        Maximum operation time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be
        changed by using the `browser_context.set_default_navigation_timeout()`,
        `browser_context.set_default_timeout()`, `page.set_default_navigation_timeout()` or
        `page.set_default_timeout()` methods.

    Returns
    -------
    Union[Response, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.wait_for_navigation started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.wait_for_navigation(
                url=self._wrap_handler(url), waitUntil=wait_until, timeout=timeout
            )
        )
        log_api(&#34;&lt;= page.wait_for_navigation succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.wait_for_navigation failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.wait_for_request"><code class="name flex">
<span>async def <span class="ident">wait_for_request</span></span>(<span>self, url_or_predicate: Union[str, Pattern, Callable[[ForwardRef('<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>')], bool]], timeout: float = None) ‑> playwright.async_api._generated.Request</span>
</code></dt>
<dd>
<div class="desc"><p>Page.wait_for_request</p>
<p>Waits for the matching request and returns it.</p>
<pre><code class="language-py">first_request = await page.wait_for_request(&quot;http://example.com/resource&quot;)
final_request = await page.wait_for_request(lambda request: request.url == &quot;http://example.com&quot; and request.method == &quot;get&quot;)
return first_request.url
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url_or_predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>], bool], Pattern, str]</code></dt>
<dd>Request URL string, regex or predicate receiving <code><a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a></code> object.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum wait time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable the timeout. The default value can be
changed by using the <code>page.set_default_timeout()</code> method.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_request(
    self,
    url_or_predicate: typing.Union[
        str, typing.Pattern, typing.Callable[[&#34;Request&#34;], bool]
    ],
    timeout: float = None,
) -&gt; &#34;Request&#34;:
    &#34;&#34;&#34;Page.wait_for_request

    Waits for the matching request and returns it.

    ```py
    first_request = await page.wait_for_request(\&#34;http://example.com/resource\&#34;)
    final_request = await page.wait_for_request(lambda request: request.url == \&#34;http://example.com\&#34; and request.method == \&#34;get\&#34;)
    return first_request.url
    ```

    Parameters
    ----------
    url_or_predicate : Union[Callable[[Request], bool], Pattern, str]
        Request URL string, regex or predicate receiving `Request` object.
    timeout : Union[float, NoneType]
        Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be
        changed by using the `page.set_default_timeout()` method.

    Returns
    -------
    Request
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.wait_for_request started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.wait_for_request(
                urlOrPredicate=self._wrap_handler(url_or_predicate), timeout=timeout
            )
        )
        log_api(&#34;&lt;= page.wait_for_request succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.wait_for_request failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.wait_for_response"><code class="name flex">
<span>async def <span class="ident">wait_for_response</span></span>(<span>self, url_or_predicate: Union[str, Pattern, Callable[[ForwardRef('<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>')], bool]], timeout: float = None) ‑> playwright.async_api._generated.Response</span>
</code></dt>
<dd>
<div class="desc"><p>Page.wait_for_response</p>
<p>Returns the matched response.</p>
<pre><code class="language-py">first_response = await page.wait_for_response(&quot;https://example.com/resource&quot;)
final_response = await page.wait_for_response(lambda response: response.url == &quot;https://example.com&quot; and response.status === 200)
return final_response.ok
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url_or_predicate</code></strong> :&ensp;<code>Union[Callable[[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>], bool], Pattern, str]</code></dt>
<dd>Request URL string, regex or predicate receiving <code><a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a></code> object.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum wait time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable the timeout. The default value can be
changed by using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_response(
    self,
    url_or_predicate: typing.Union[
        str, typing.Pattern, typing.Callable[[&#34;Response&#34;], bool]
    ],
    timeout: float = None,
) -&gt; &#34;Response&#34;:
    &#34;&#34;&#34;Page.wait_for_response

    Returns the matched response.

    ```py
    first_response = await page.wait_for_response(\&#34;https://example.com/resource\&#34;)
    final_response = await page.wait_for_response(lambda response: response.url == \&#34;https://example.com\&#34; and response.status === 200)
    return final_response.ok
    ```

    Parameters
    ----------
    url_or_predicate : Union[Callable[[Response], bool], Pattern, str]
        Request URL string, regex or predicate receiving `Response` object.
    timeout : Union[float, NoneType]
        Maximum wait time in milliseconds, defaults to 30 seconds, pass `0` to disable the timeout. The default value can be
        changed by using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.

    Returns
    -------
    Response
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.wait_for_response started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.wait_for_response(
                urlOrPredicate=self._wrap_handler(url_or_predicate), timeout=timeout
            )
        )
        log_api(&#34;&lt;= page.wait_for_response succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.wait_for_response failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.wait_for_selector"><code class="name flex">
<span>async def <span class="ident">wait_for_selector</span></span>(<span>self, selector: str, timeout: float = None, state: Literal['attached', 'detached', 'hidden', 'visible'] = None) ‑> Union[playwright.async_api._generated.ElementHandle, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Page.wait_for_selector</p>
<p>Returns when element specified by selector satisfies <code>state</code> option. Returns <code>null</code> if waiting for <code>hidden</code> or
<code>detached</code>.</p>
<p>Wait for the <code>selector</code> to satisfy <code>state</code> option (either appear/disappear from dom, or become visible/hidden). If at
the moment of calling the method <code>selector</code> already satisfies the condition, the method will return immediately. If the
selector doesn't satisfy the condition for the <code>timeout</code> milliseconds, the function will throw.</p>
<p>This method works across navigations:</p>
<pre><code class="language-py">import asyncio
from playwright.async_api import async_playwright

async def run(playwright):
    chromium = playwright.chromium
    browser = await chromium.launch()
    page = await browser.new_page()
    for current_url in [&quot;https://google.com&quot;, &quot;https://bbc.com&quot;]:
        await page.goto(current_url, wait_until=&quot;domcontentloaded&quot;)
        element = await page.wait_for_selector(&quot;img&quot;)
        print(&quot;Loaded image: &quot; + str(await element.get_attribute(&quot;src&quot;)))
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>selector</code></strong> :&ensp;<code>str</code></dt>
<dd>A selector to query for. See <a href="./selectors.md#working-with-selectors">working with selectors</a> for more details.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time in milliseconds, defaults to 30 seconds, pass <code>0</code> to disable timeout. The default value can be changed by
using the <code>browser_context.set_default_timeout()</code> or <code>page.set_default_timeout()</code> methods.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>Union["attached", "detached", "hidden", "visible", NoneType]</code></dt>
<dd>Defaults to <code>'visible'</code>. Can be either:
- <code>'attached'</code> - wait for element to be present in DOM.
- <code>'detached'</code> - wait for element to not be present in DOM.
- <code>'visible'</code> - wait for element to have non-empty bounding box and no <code>visibility:hidden</code>. Note that element without
any content or with <code>display:none</code> has an empty bounding box and is not considered visible.
- <code>'hidden'</code> - wait for element to be either detached from DOM, or have an empty bounding box or <code>visibility:hidden</code>.
This is opposite to the <code>'visible'</code> option.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_selector(
    self,
    selector: str,
    timeout: float = None,
    state: Literal[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;] = None,
) -&gt; typing.Union[&#34;ElementHandle&#34;, NoneType]:
    &#34;&#34;&#34;Page.wait_for_selector

    Returns when element specified by selector satisfies `state` option. Returns `null` if waiting for `hidden` or
    `detached`.

    Wait for the `selector` to satisfy `state` option (either appear/disappear from dom, or become visible/hidden). If at
    the moment of calling the method `selector` already satisfies the condition, the method will return immediately. If the
    selector doesn&#39;t satisfy the condition for the `timeout` milliseconds, the function will throw.

    This method works across navigations:

    ```py
    import asyncio
    from playwright.async_api import async_playwright

    async def run(playwright):
        chromium = playwright.chromium
        browser = await chromium.launch()
        page = await browser.new_page()
        for current_url in [\&#34;https://google.com\&#34;, \&#34;https://bbc.com\&#34;]:
            await page.goto(current_url, wait_until=\&#34;domcontentloaded\&#34;)
            element = await page.wait_for_selector(\&#34;img\&#34;)
            print(\&#34;Loaded image: \&#34; + str(await element.get_attribute(\&#34;src\&#34;)))
        await browser.close()

    async def main():
        async with async_playwright() as playwright:
            await run(playwright)
    asyncio.run(main())
    ```

    Parameters
    ----------
    selector : str
        A selector to query for. See [working with selectors](./selectors.md#working-with-selectors) for more details.
    timeout : Union[float, NoneType]
        Maximum time in milliseconds, defaults to 30 seconds, pass `0` to disable timeout. The default value can be changed by
        using the `browser_context.set_default_timeout()` or `page.set_default_timeout()` methods.
    state : Union[&#34;attached&#34;, &#34;detached&#34;, &#34;hidden&#34;, &#34;visible&#34;, NoneType]
        Defaults to `&#39;visible&#39;`. Can be either:
        - `&#39;attached&#39;` - wait for element to be present in DOM.
        - `&#39;detached&#39;` - wait for element to not be present in DOM.
        - `&#39;visible&#39;` - wait for element to have non-empty bounding box and no `visibility:hidden`. Note that element without
          any content or with `display:none` has an empty bounding box and is not considered visible.
        - `&#39;hidden&#39;` - wait for element to be either detached from DOM, or have an empty bounding box or `visibility:hidden`.
          This is opposite to the `&#39;visible&#39;` option.

    Returns
    -------
    Union[ElementHandle, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.wait_for_selector started&#34;)
        result = mapping.from_impl_nullable(
            await self._impl_obj.wait_for_selector(
                selector=selector, timeout=timeout, state=state
            )
        )
        log_api(&#34;&lt;= page.wait_for_selector succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.wait_for_selector failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Page.wait_for_timeout"><code class="name flex">
<span>async def <span class="ident">wait_for_timeout</span></span>(<span>self, timeout: float) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Page.wait_for_timeout</p>
<p>Waits for the given <code>timeout</code> in milliseconds.</p>
<p>Note that <code>page.waitForTimeout()</code> should only be used for debugging. Tests using the timer in production are going to be
flaky. Use signals such as network events, selectors becoming visible and others instead.</p>
<pre><code class="language-py"># wait for 1 second
await page.wait_for_timeout(1000)
</code></pre>
<p>Shortcut for main frame's <code>frame.wait_for_timeout()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timeout</code></strong> :&ensp;<code>float</code></dt>
<dd>A timeout to wait for</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_timeout(self, timeout: float) -&gt; NoneType:
    &#34;&#34;&#34;Page.wait_for_timeout

    Waits for the given `timeout` in milliseconds.

    Note that `page.waitForTimeout()` should only be used for debugging. Tests using the timer in production are going to be
    flaky. Use signals such as network events, selectors becoming visible and others instead.

    ```py
    # wait for 1 second
    await page.wait_for_timeout(1000)
    ```

    Shortcut for main frame&#39;s `frame.wait_for_timeout()`.

    Parameters
    ----------
    timeout : float
        A timeout to wait for
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; page.wait_for_timeout started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.wait_for_timeout(timeout=timeout)
        )
        log_api(&#34;&lt;= page.wait_for_timeout succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= page.wait_for_timeout failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.PdfMargins"><code class="flex name class">
<span>class <span class="ident">PdfMargins</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PdfMargins(TypedDict, total=False):
    top: Optional[Union[str, float]]
    right: Optional[Union[str, float]]
    bottom: Optional[Union[str, float]]
    left: Optional[Union[str, float]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.PdfMargins.bottom"><code class="name">var <span class="ident">bottom</span> : Union[str, float, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.PdfMargins.left"><code class="name">var <span class="ident">left</span> : Union[str, float, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.PdfMargins.right"><code class="name">var <span class="ident">right</span> : Union[str, float, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.PdfMargins.top"><code class="name">var <span class="ident">top</span> : Union[str, float, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Playwright"><code class="flex name class">
<span>class <span class="ident">Playwright</span></span>
<span>(</span><span>obj: playwright._impl._playwright.Playwright)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Playwright(AsyncBase):
    def __init__(self, obj: PlaywrightImpl):
        super().__init__(obj)

    @property
    def devices(self) -&gt; typing.Dict:
        &#34;&#34;&#34;Playwright.devices

        Returns a dictionary of devices to be used with `browser.new_context()` or `browser.new_page()`.

        ```py
        import asyncio
        from playwright.async_api import async_playwright

        async def run(playwright):
            webkit = playwright.webkit
            iphone = playwright.devices[\&#34;iPhone 6\&#34;]
            browser = await webkit.launch()
            context = await browser.new_context(**iphone)
            page = await context.new_page()
            await page.goto(\&#34;http://example.com\&#34;)
            # other actions...
            await browser.close()

        async def main():
            async with async_playwright() as playwright:
                await run(playwright)
        asyncio.run(main())
        ```

        Returns
        -------
        Dict
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.devices)

    @property
    def selectors(self) -&gt; &#34;Selectors&#34;:
        &#34;&#34;&#34;Playwright.selectors

        Selectors can be used to install custom selector engines. See
        [Working with selectors](./selectors.md#working-with-selectors) for more information.

        Returns
        -------
        Selectors
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.selectors)

    @property
    def chromium(self) -&gt; &#34;BrowserType&#34;:
        &#34;&#34;&#34;Playwright.chromium

        This object can be used to launch or connect to Chromium, returning instances of `ChromiumBrowser`.

        Returns
        -------
        BrowserType
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.chromium)

    @property
    def firefox(self) -&gt; &#34;BrowserType&#34;:
        &#34;&#34;&#34;Playwright.firefox

        This object can be used to launch or connect to Firefox, returning instances of `FirefoxBrowser`.

        Returns
        -------
        BrowserType
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.firefox)

    @property
    def webkit(self) -&gt; &#34;BrowserType&#34;:
        &#34;&#34;&#34;Playwright.webkit

        This object can be used to launch or connect to WebKit, returning instances of `WebKitBrowser`.

        Returns
        -------
        BrowserType
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.webkit)

    def stop(self) -&gt; NoneType:
        &#34;&#34;&#34;Playwright.stop

        Terminates this instance of Playwright in case it was created bypassing the Python context manager. This is useful in
        REPL applications.

        ```py
        &gt;&gt;&gt; from playwright.sync_api import sync_playwright

        &gt;&gt;&gt; playwright = sync_playwright().start()

        &gt;&gt;&gt; browser = playwright.chromium.launch()
        &gt;&gt;&gt; page = browser.newPage()
        &gt;&gt;&gt; page.goto(\&#34;http://whatsmyuseragent.org/\&#34;)
        &gt;&gt;&gt; page.screenshot(path=\&#34;example.png\&#34;)
        &gt;&gt;&gt; browser.close()

        &gt;&gt;&gt; playwright.stop()
        ```
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; playwright.stop started&#34;)
            result = mapping.from_maybe_impl(self._impl_obj.stop())
            log_api(&#34;&lt;= playwright.stop succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= playwright.stop failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Playwright.chromium"><code class="name">var <span class="ident">chromium</span> : playwright.async_api._generated.BrowserType</code></dt>
<dd>
<div class="desc"><p>Playwright.chromium</p>
<p>This object can be used to launch or connect to Chromium, returning instances of <code>ChromiumBrowser</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.BrowserType" href="#playwright.async_api.BrowserType">BrowserType</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def chromium(self) -&gt; &#34;BrowserType&#34;:
    &#34;&#34;&#34;Playwright.chromium

    This object can be used to launch or connect to Chromium, returning instances of `ChromiumBrowser`.

    Returns
    -------
    BrowserType
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.chromium)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Playwright.devices"><code class="name">var <span class="ident">devices</span> : Dict</code></dt>
<dd>
<div class="desc"><p>Playwright.devices</p>
<p>Returns a dictionary of devices to be used with <code>browser.new_context()</code> or <code>browser.new_page()</code>.</p>
<pre><code class="language-py">import asyncio
from playwright.async_api import async_playwright

async def run(playwright):
    webkit = playwright.webkit
    iphone = playwright.devices[&quot;iPhone 6&quot;]
    browser = await webkit.launch()
    context = await browser.new_context(**iphone)
    page = await context.new_page()
    await page.goto(&quot;http://example.com&quot;)
    # other actions...
    await browser.close()

async def main():
    async with async_playwright() as playwright:
        await run(playwright)
asyncio.run(main())
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def devices(self) -&gt; typing.Dict:
    &#34;&#34;&#34;Playwright.devices

    Returns a dictionary of devices to be used with `browser.new_context()` or `browser.new_page()`.

    ```py
    import asyncio
    from playwright.async_api import async_playwright

    async def run(playwright):
        webkit = playwright.webkit
        iphone = playwright.devices[\&#34;iPhone 6\&#34;]
        browser = await webkit.launch()
        context = await browser.new_context(**iphone)
        page = await context.new_page()
        await page.goto(\&#34;http://example.com\&#34;)
        # other actions...
        await browser.close()

    async def main():
        async with async_playwright() as playwright:
            await run(playwright)
    asyncio.run(main())
    ```

    Returns
    -------
    Dict
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.devices)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Playwright.firefox"><code class="name">var <span class="ident">firefox</span> : playwright.async_api._generated.BrowserType</code></dt>
<dd>
<div class="desc"><p>Playwright.firefox</p>
<p>This object can be used to launch or connect to Firefox, returning instances of <code>FirefoxBrowser</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.BrowserType" href="#playwright.async_api.BrowserType">BrowserType</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def firefox(self) -&gt; &#34;BrowserType&#34;:
    &#34;&#34;&#34;Playwright.firefox

    This object can be used to launch or connect to Firefox, returning instances of `FirefoxBrowser`.

    Returns
    -------
    BrowserType
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.firefox)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Playwright.selectors"><code class="name">var <span class="ident">selectors</span> : playwright.async_api._generated.Selectors</code></dt>
<dd>
<div class="desc"><p>Playwright.selectors</p>
<p>Selectors can be used to install custom selector engines. See
<a href="./selectors.md#working-with-selectors">Working with selectors</a> for more information.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Selectors" href="#playwright.async_api.Selectors">Selectors</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def selectors(self) -&gt; &#34;Selectors&#34;:
    &#34;&#34;&#34;Playwright.selectors

    Selectors can be used to install custom selector engines. See
    [Working with selectors](./selectors.md#working-with-selectors) for more information.

    Returns
    -------
    Selectors
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.selectors)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Playwright.webkit"><code class="name">var <span class="ident">webkit</span> : playwright.async_api._generated.BrowserType</code></dt>
<dd>
<div class="desc"><p>Playwright.webkit</p>
<p>This object can be used to launch or connect to WebKit, returning instances of <code>WebKitBrowser</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.BrowserType" href="#playwright.async_api.BrowserType">BrowserType</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def webkit(self) -&gt; &#34;BrowserType&#34;:
    &#34;&#34;&#34;Playwright.webkit

    This object can be used to launch or connect to WebKit, returning instances of `WebKitBrowser`.

    Returns
    -------
    BrowserType
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.webkit)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Playwright.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Playwright.stop</p>
<p>Terminates this instance of Playwright in case it was created bypassing the Python context manager. This is useful in
REPL applications.</p>
<pre><code class="language-py">&gt;&gt;&gt; from playwright.sync_api import sync_playwright

&gt;&gt;&gt; playwright = sync_playwright().start()

&gt;&gt;&gt; browser = playwright.chromium.launch()
&gt;&gt;&gt; page = browser.newPage()
&gt;&gt;&gt; page.goto(&quot;http://whatsmyuseragent.org/&quot;)
&gt;&gt;&gt; page.screenshot(path=&quot;example.png&quot;)
&gt;&gt;&gt; browser.close()

&gt;&gt;&gt; playwright.stop()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self) -&gt; NoneType:
    &#34;&#34;&#34;Playwright.stop

    Terminates this instance of Playwright in case it was created bypassing the Python context manager. This is useful in
    REPL applications.

    ```py
    &gt;&gt;&gt; from playwright.sync_api import sync_playwright

    &gt;&gt;&gt; playwright = sync_playwright().start()

    &gt;&gt;&gt; browser = playwright.chromium.launch()
    &gt;&gt;&gt; page = browser.newPage()
    &gt;&gt;&gt; page.goto(\&#34;http://whatsmyuseragent.org/\&#34;)
    &gt;&gt;&gt; page.screenshot(path=\&#34;example.png\&#34;)
    &gt;&gt;&gt; browser.close()

    &gt;&gt;&gt; playwright.stop()
    ```
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; playwright.stop started&#34;)
        result = mapping.from_maybe_impl(self._impl_obj.stop())
        log_api(&#34;&lt;= playwright.stop succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= playwright.stop failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Position"><code class="flex name class">
<span>class <span class="ident">Position</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Position(TypedDict):
    x: float
    y: float</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.Position.x"><code class="name">var <span class="ident">x</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.Position.y"><code class="name">var <span class="ident">y</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.ProxySettings"><code class="flex name class">
<span>class <span class="ident">ProxySettings</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProxySettings(TypedDict, total=False):
    server: str
    bypass: Optional[str]
    username: Optional[str]
    password: Optional[str]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.ProxySettings.bypass"><code class="name">var <span class="ident">bypass</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ProxySettings.password"><code class="name">var <span class="ident">password</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ProxySettings.server"><code class="name">var <span class="ident">server</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ProxySettings.username"><code class="name">var <span class="ident">username</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Request"><code class="flex name class">
<span>class <span class="ident">Request</span></span>
<span>(</span><span>obj: playwright._impl._network.Request)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Request(AsyncBase):
    def __init__(self, obj: RequestImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Request.url

        URL of the request.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def resource_type(self) -&gt; str:
        &#34;&#34;&#34;Request.resource_type

        Contains the request&#39;s resource type as it was perceived by the rendering engine. ResourceType will be one of the
        following: `document`, `stylesheet`, `image`, `media`, `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`,
        `websocket`, `manifest`, `other`.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.resource_type)

    @property
    def method(self) -&gt; str:
        &#34;&#34;&#34;Request.method

        Request&#39;s method (GET, POST, etc.)

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.method)

    @property
    def post_data(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Request.post_data

        Request&#39;s post body, if any.

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.post_data)

    @property
    def post_data_json(self) -&gt; typing.Union[typing.Any, NoneType]:
        &#34;&#34;&#34;Request.post_data_json

        Returns parsed request&#39;s body for `form-urlencoded` and JSON as a fallback if any.

        When the response is `application/x-www-form-urlencoded` then a key/value object of the values will be returned.
        Otherwise it will be parsed as JSON.

        Returns
        -------
        Union[Any, NoneType]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.post_data_json)

    @property
    def post_data_buffer(self) -&gt; typing.Union[bytes, NoneType]:
        &#34;&#34;&#34;Request.post_data_buffer

        Request&#39;s post body in a binary form, if any.

        Returns
        -------
        Union[bytes, NoneType]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.post_data_buffer)

    @property
    def headers(self) -&gt; typing.Dict[str, str]:
        &#34;&#34;&#34;Request.headers

        An object with HTTP headers associated with the request. All header names are lower-case.

        Returns
        -------
        Dict[str, str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.headers)

    @property
    def frame(self) -&gt; &#34;Frame&#34;:
        &#34;&#34;&#34;Request.frame

        Returns the `Frame` that initiated this request.

        Returns
        -------
        Frame
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.frame)

    @property
    def redirected_from(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
        &#34;&#34;&#34;Request.redirected_from

        Request that was redirected by the server to this one, if any.

        When the server responds with a redirect, Playwright creates a new `Request` object. The two requests are connected by
        `redirectedFrom()` and `redirectedTo()` methods. When multiple server redirects has happened, it is possible to
        construct the whole redirect chain by repeatedly calling `redirectedFrom()`.

        For example, if the website `http://example.com` redirects to `https://example.com`:

        ```py
        response = await page.goto(\&#34;http://example.com\&#34;)
        print(response.request.redirected_from.url) # \&#34;http://example.com\&#34;
        ```

        If the website `https://google.com` has no redirects:

        ```py
        response = await page.goto(\&#34;https://google.com\&#34;)
        print(response.request.redirected_from) # None
        ```

        Returns
        -------
        Union[Request, NoneType]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.redirected_from)

    @property
    def redirected_to(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
        &#34;&#34;&#34;Request.redirected_to

        New request issued by the browser if the server responded with redirect.

        This method is the opposite of `request.redirected_from()`:

        ```py
        assert request.redirected_from.redirected_to == request
        ```

        Returns
        -------
        Union[Request, NoneType]
        &#34;&#34;&#34;
        return mapping.from_impl_nullable(self._impl_obj.redirected_to)

    @property
    def failure(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Request.failure

        Returns human-readable error message, e.g. `&#39;net::ERR_FAILED&#39;`. The method returns `None` unless this request has
        failed, as reported by `requestfailed` event.

        Example of logging of all the failed requests:

        ```py
        page.on(&#39;requestfailed&#39;, lambda request: print(request.url + &#39; &#39; + request.failure);
        ```

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.failure)

    @property
    def timing(self) -&gt; ResourceTiming:
        &#34;&#34;&#34;Request.timing

        Returns resource timing information for given request. Most of the timing values become available upon the response,
        `responseEnd` becomes available when request finishes. Find more information at
        [Resource Timing API](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming).

        ```py
        async with page.expect_event(\&#34;requestfinished\&#34;) as request_info:
            await page.goto(\&#34;http://example.com\&#34;)
        request = await request_info.value
        print(request.timing)
        ```

        Returns
        -------
        {startTime: float, domainLookupStart: float, domainLookupEnd: float, connectStart: float, secureConnectionStart: float, connectEnd: float, requestStart: float, responseStart: float, responseEnd: float}
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.timing)

    async def response(self) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
        &#34;&#34;&#34;Request.response

        Returns the matching `Response` object, or `null` if the response was not received due to error.

        Returns
        -------
        Union[Response, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; request.response started&#34;)
            result = mapping.from_impl_nullable(await self._impl_obj.response())
            log_api(&#34;&lt;= request.response succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= request.response failed&#34;)
            raise e

    def is_navigation_request(self) -&gt; bool:
        &#34;&#34;&#34;Request.is_navigation_request

        Whether this request is driving frame&#39;s navigation.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; request.is_navigation_request started&#34;)
            result = mapping.from_maybe_impl(self._impl_obj.is_navigation_request())
            log_api(&#34;&lt;= request.is_navigation_request succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= request.is_navigation_request failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Request.failure"><code class="name">var <span class="ident">failure</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.failure</p>
<p>Returns human-readable error message, e.g. <code>'net::ERR_FAILED'</code>. The method returns <code>None</code> unless this request has
failed, as reported by <code>requestfailed</code> event.</p>
<p>Example of logging of all the failed requests:</p>
<pre><code class="language-py">page.on('requestfailed', lambda request: print(request.url + ' ' + request.failure);
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def failure(self) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Request.failure

    Returns human-readable error message, e.g. `&#39;net::ERR_FAILED&#39;`. The method returns `None` unless this request has
    failed, as reported by `requestfailed` event.

    Example of logging of all the failed requests:

    ```py
    page.on(&#39;requestfailed&#39;, lambda request: print(request.url + &#39; &#39; + request.failure);
    ```

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.failure)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.frame"><code class="name">var <span class="ident">frame</span> : playwright.async_api._generated.Frame</code></dt>
<dd>
<div class="desc"><p>Request.frame</p>
<p>Returns the <code><a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a></code> that initiated this request.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame(self) -&gt; &#34;Frame&#34;:
    &#34;&#34;&#34;Request.frame

    Returns the `Frame` that initiated this request.

    Returns
    -------
    Frame
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.frame)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.headers"><code class="name">var <span class="ident">headers</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"><p>Request.headers</p>
<p>An object with HTTP headers associated with the request. All header names are lower-case.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def headers(self) -&gt; typing.Dict[str, str]:
    &#34;&#34;&#34;Request.headers

    An object with HTTP headers associated with the request. All header names are lower-case.

    Returns
    -------
    Dict[str, str]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.headers)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.method"><code class="name">var <span class="ident">method</span> : str</code></dt>
<dd>
<div class="desc"><p>Request.method</p>
<p>Request's method (GET, POST, etc.)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def method(self) -&gt; str:
    &#34;&#34;&#34;Request.method

    Request&#39;s method (GET, POST, etc.)

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.method)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.post_data"><code class="name">var <span class="ident">post_data</span> : Union[str, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.post_data</p>
<p>Request's post body, if any.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def post_data(self) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Request.post_data

    Request&#39;s post body, if any.

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.post_data)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.post_data_buffer"><code class="name">var <span class="ident">post_data_buffer</span> : Union[bytes, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.post_data_buffer</p>
<p>Request's post body in a binary form, if any.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[bytes, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def post_data_buffer(self) -&gt; typing.Union[bytes, NoneType]:
    &#34;&#34;&#34;Request.post_data_buffer

    Request&#39;s post body in a binary form, if any.

    Returns
    -------
    Union[bytes, NoneType]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.post_data_buffer)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.post_data_json"><code class="name">var <span class="ident">post_data_json</span> : Union[Any, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.post_data_json</p>
<p>Returns parsed request's body for <code>form-urlencoded</code> and JSON as a fallback if any.</p>
<p>When the response is <code>application/x-www-form-urlencoded</code> then a key/value object of the values will be returned.
Otherwise it will be parsed as JSON.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[Any, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def post_data_json(self) -&gt; typing.Union[typing.Any, NoneType]:
    &#34;&#34;&#34;Request.post_data_json

    Returns parsed request&#39;s body for `form-urlencoded` and JSON as a fallback if any.

    When the response is `application/x-www-form-urlencoded` then a key/value object of the values will be returned.
    Otherwise it will be parsed as JSON.

    Returns
    -------
    Union[Any, NoneType]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.post_data_json)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.redirected_from"><code class="name">var <span class="ident">redirected_from</span> : Union[playwright.async_api._generated.Request, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.redirected_from</p>
<p>Request that was redirected by the server to this one, if any.</p>
<p>When the server responds with a redirect, Playwright creates a new <code><a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a></code> object. The two requests are connected by
<code>redirectedFrom()</code> and <code>redirectedTo()</code> methods. When multiple server redirects has happened, it is possible to
construct the whole redirect chain by repeatedly calling <code>redirectedFrom()</code>.</p>
<p>For example, if the website <code>http://example.com</code> redirects to <code>https://example.com</code>:</p>
<pre><code class="language-py">response = await page.goto(&quot;http://example.com&quot;)
print(response.request.redirected_from.url) # &quot;http://example.com&quot;
</code></pre>
<p>If the website <code>https://google.com</code> has no redirects:</p>
<pre><code class="language-py">response = await page.goto(&quot;https://google.com&quot;)
print(response.request.redirected_from) # None
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def redirected_from(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
    &#34;&#34;&#34;Request.redirected_from

    Request that was redirected by the server to this one, if any.

    When the server responds with a redirect, Playwright creates a new `Request` object. The two requests are connected by
    `redirectedFrom()` and `redirectedTo()` methods. When multiple server redirects has happened, it is possible to
    construct the whole redirect chain by repeatedly calling `redirectedFrom()`.

    For example, if the website `http://example.com` redirects to `https://example.com`:

    ```py
    response = await page.goto(\&#34;http://example.com\&#34;)
    print(response.request.redirected_from.url) # \&#34;http://example.com\&#34;
    ```

    If the website `https://google.com` has no redirects:

    ```py
    response = await page.goto(\&#34;https://google.com\&#34;)
    print(response.request.redirected_from) # None
    ```

    Returns
    -------
    Union[Request, NoneType]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.redirected_from)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.redirected_to"><code class="name">var <span class="ident">redirected_to</span> : Union[playwright.async_api._generated.Request, NoneType]</code></dt>
<dd>
<div class="desc"><p>Request.redirected_to</p>
<p>New request issued by the browser if the server responded with redirect.</p>
<p>This method is the opposite of <code>request.redirected_from()</code>:</p>
<pre><code class="language-py">assert request.redirected_from.redirected_to == request
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def redirected_to(self) -&gt; typing.Union[&#34;Request&#34;, NoneType]:
    &#34;&#34;&#34;Request.redirected_to

    New request issued by the browser if the server responded with redirect.

    This method is the opposite of `request.redirected_from()`:

    ```py
    assert request.redirected_from.redirected_to == request
    ```

    Returns
    -------
    Union[Request, NoneType]
    &#34;&#34;&#34;
    return mapping.from_impl_nullable(self._impl_obj.redirected_to)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.resource_type"><code class="name">var <span class="ident">resource_type</span> : str</code></dt>
<dd>
<div class="desc"><p>Request.resource_type</p>
<p>Contains the request's resource type as it was perceived by the rendering engine. ResourceType will be one of the
following: <code>document</code>, <code>stylesheet</code>, <code>image</code>, <code>media</code>, <code>font</code>, <code>script</code>, <code>texttrack</code>, <code>xhr</code>, <code>fetch</code>, <code>eventsource</code>,
<code>websocket</code>, <code>manifest</code>, <code>other</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resource_type(self) -&gt; str:
    &#34;&#34;&#34;Request.resource_type

    Contains the request&#39;s resource type as it was perceived by the rendering engine. ResourceType will be one of the
    following: `document`, `stylesheet`, `image`, `media`, `font`, `script`, `texttrack`, `xhr`, `fetch`, `eventsource`,
    `websocket`, `manifest`, `other`.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.resource_type)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.timing"><code class="name">var <span class="ident">timing</span> : playwright._impl._api_structures.ResourceTiming</code></dt>
<dd>
<div class="desc"><p>Request.timing</p>
<p>Returns resource timing information for given request. Most of the timing values become available upon the response,
<code>responseEnd</code> becomes available when request finishes. Find more information at
<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming">Resource Timing API</a>.</p>
<pre><code class="language-py">async with page.expect_event(&quot;requestfinished&quot;) as request_info:
    await page.goto(&quot;http://example.com&quot;)
request = await request_info.value
print(request.timing)
</code></pre>
<h2 id="returns">Returns</h2>
<p>{startTime: float, domainLookupStart: float, domainLookupEnd: float, connectStart: float, secureConnectionStart: float, connectEnd: float, requestStart: float, responseStart: float, responseEnd: float}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timing(self) -&gt; ResourceTiming:
    &#34;&#34;&#34;Request.timing

    Returns resource timing information for given request. Most of the timing values become available upon the response,
    `responseEnd` becomes available when request finishes. Find more information at
    [Resource Timing API](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceResourceTiming).

    ```py
    async with page.expect_event(\&#34;requestfinished\&#34;) as request_info:
        await page.goto(\&#34;http://example.com\&#34;)
    request = await request_info.value
    print(request.timing)
    ```

    Returns
    -------
    {startTime: float, domainLookupStart: float, domainLookupEnd: float, connectStart: float, secureConnectionStart: float, connectEnd: float, requestStart: float, responseStart: float, responseEnd: float}
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.timing)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Request.url</p>
<p>URL of the request.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Request.url

    URL of the request.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Request.is_navigation_request"><code class="name flex">
<span>def <span class="ident">is_navigation_request</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Request.is_navigation_request</p>
<p>Whether this request is driving frame's navigation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_navigation_request(self) -&gt; bool:
    &#34;&#34;&#34;Request.is_navigation_request

    Whether this request is driving frame&#39;s navigation.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; request.is_navigation_request started&#34;)
        result = mapping.from_maybe_impl(self._impl_obj.is_navigation_request())
        log_api(&#34;&lt;= request.is_navigation_request succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= request.is_navigation_request failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Request.response"><code class="name flex">
<span>async def <span class="ident">response</span></span>(<span>self) ‑> Union[playwright.async_api._generated.Response, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Request.response</p>
<p>Returns the matching <code><a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a></code> object, or <code>null</code> if the response was not received due to error.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[<a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a>, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def response(self) -&gt; typing.Union[&#34;Response&#34;, NoneType]:
    &#34;&#34;&#34;Request.response

    Returns the matching `Response` object, or `null` if the response was not received due to error.

    Returns
    -------
    Union[Response, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; request.response started&#34;)
        result = mapping.from_impl_nullable(await self._impl_obj.response())
        log_api(&#34;&lt;= request.response succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= request.response failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.ResourceTiming"><code class="flex name class">
<span>class <span class="ident">ResourceTiming</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResourceTiming(TypedDict):
    startTime: float
    domainLookupStart: float
    domainLookupEnd: float
    connectStart: float
    secureConnectionStart: float
    connectEnd: float
    requestStart: float
    responseStart: float
    responseEnd: float</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.ResourceTiming.connectEnd"><code class="name">var <span class="ident">connectEnd</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ResourceTiming.connectStart"><code class="name">var <span class="ident">connectStart</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ResourceTiming.domainLookupEnd"><code class="name">var <span class="ident">domainLookupEnd</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ResourceTiming.domainLookupStart"><code class="name">var <span class="ident">domainLookupStart</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ResourceTiming.requestStart"><code class="name">var <span class="ident">requestStart</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ResourceTiming.responseEnd"><code class="name">var <span class="ident">responseEnd</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ResourceTiming.responseStart"><code class="name">var <span class="ident">responseStart</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ResourceTiming.secureConnectionStart"><code class="name">var <span class="ident">secureConnectionStart</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ResourceTiming.startTime"><code class="name">var <span class="ident">startTime</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Response"><code class="flex name class">
<span>class <span class="ident">Response</span></span>
<span>(</span><span>obj: playwright._impl._network.Response)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Response(AsyncBase):
    def __init__(self, obj: ResponseImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Response.url

        Contains the URL of the response.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    @property
    def ok(self) -&gt; bool:
        &#34;&#34;&#34;Response.ok

        Contains a boolean stating whether the response was successful (status in the range 200-299) or not.

        Returns
        -------
        bool
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.ok)

    @property
    def status(self) -&gt; int:
        &#34;&#34;&#34;Response.status

        Contains the status code of the response (e.g., 200 for a success).

        Returns
        -------
        int
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.status)

    @property
    def status_text(self) -&gt; str:
        &#34;&#34;&#34;Response.status_text

        Contains the status text of the response (e.g. usually an \&#34;OK\&#34; for a success).

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.status_text)

    @property
    def headers(self) -&gt; typing.Dict[str, str]:
        &#34;&#34;&#34;Response.headers

        Returns the object with HTTP headers associated with the response. All header names are lower-case.

        Returns
        -------
        Dict[str, str]
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.headers)

    @property
    def request(self) -&gt; &#34;Request&#34;:
        &#34;&#34;&#34;Response.request

        Returns the matching `Request` object.

        Returns
        -------
        Request
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.request)

    @property
    def frame(self) -&gt; &#34;Frame&#34;:
        &#34;&#34;&#34;Response.frame

        Returns the `Frame` that initiated this response.

        Returns
        -------
        Frame
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.frame)

    async def finished(self) -&gt; typing.Union[str, NoneType]:
        &#34;&#34;&#34;Response.finished

        Waits for this response to finish, returns failure error if request failed.

        Returns
        -------
        Union[str, NoneType]
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; response.finished started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.finished())
            log_api(&#34;&lt;= response.finished succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= response.finished failed&#34;)
            raise e

    async def body(self) -&gt; bytes:
        &#34;&#34;&#34;Response.body

        Returns the buffer with response body.

        Returns
        -------
        bytes
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; response.body started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.body())
            log_api(&#34;&lt;= response.body succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= response.body failed&#34;)
            raise e

    async def text(self) -&gt; str:
        &#34;&#34;&#34;Response.text

        Returns the text representation of response body.

        Returns
        -------
        str
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; response.text started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.text())
            log_api(&#34;&lt;= response.text succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= response.text failed&#34;)
            raise e

    async def json(self) -&gt; typing.Any:
        &#34;&#34;&#34;Response.json

        Returns the JSON representation of response body.

        This method will throw if the response body is not parsable via `JSON.parse`.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; response.json started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.json())
            log_api(&#34;&lt;= response.json succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= response.json failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Response.frame"><code class="name">var <span class="ident">frame</span> : playwright.async_api._generated.Frame</code></dt>
<dd>
<div class="desc"><p>Response.frame</p>
<p>Returns the <code><a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a></code> that initiated this response.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frame(self) -&gt; &#34;Frame&#34;:
    &#34;&#34;&#34;Response.frame

    Returns the `Frame` that initiated this response.

    Returns
    -------
    Frame
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.frame)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Response.headers"><code class="name">var <span class="ident">headers</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"><p>Response.headers</p>
<p>Returns the object with HTTP headers associated with the response. All header names are lower-case.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, str]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def headers(self) -&gt; typing.Dict[str, str]:
    &#34;&#34;&#34;Response.headers

    Returns the object with HTTP headers associated with the response. All header names are lower-case.

    Returns
    -------
    Dict[str, str]
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.headers)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Response.ok"><code class="name">var <span class="ident">ok</span> : bool</code></dt>
<dd>
<div class="desc"><p>Response.ok</p>
<p>Contains a boolean stating whether the response was successful (status in the range 200-299) or not.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ok(self) -&gt; bool:
    &#34;&#34;&#34;Response.ok

    Contains a boolean stating whether the response was successful (status in the range 200-299) or not.

    Returns
    -------
    bool
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.ok)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Response.request"><code class="name">var <span class="ident">request</span> : playwright.async_api._generated.Request</code></dt>
<dd>
<div class="desc"><p>Response.request</p>
<p>Returns the matching <code><a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a></code> object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def request(self) -&gt; &#34;Request&#34;:
    &#34;&#34;&#34;Response.request

    Returns the matching `Request` object.

    Returns
    -------
    Request
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.request)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Response.status"><code class="name">var <span class="ident">status</span> : int</code></dt>
<dd>
<div class="desc"><p>Response.status</p>
<p>Contains the status code of the response (e.g., 200 for a success).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status(self) -&gt; int:
    &#34;&#34;&#34;Response.status

    Contains the status code of the response (e.g., 200 for a success).

    Returns
    -------
    int
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.status)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Response.status_text"><code class="name">var <span class="ident">status_text</span> : str</code></dt>
<dd>
<div class="desc"><p>Response.status_text</p>
<p>Contains the status text of the response (e.g. usually an "OK" for a success).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def status_text(self) -&gt; str:
    &#34;&#34;&#34;Response.status_text

    Contains the status text of the response (e.g. usually an \&#34;OK\&#34; for a success).

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.status_text)</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Response.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Response.url</p>
<p>Contains the URL of the response.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Response.url

    Contains the URL of the response.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Response.body"><code class="name flex">
<span>async def <span class="ident">body</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Response.body</p>
<p>Returns the buffer with response body.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def body(self) -&gt; bytes:
    &#34;&#34;&#34;Response.body

    Returns the buffer with response body.

    Returns
    -------
    bytes
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; response.body started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.body())
        log_api(&#34;&lt;= response.body succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= response.body failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Response.finished"><code class="name flex">
<span>async def <span class="ident">finished</span></span>(<span>self) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Response.finished</p>
<p>Waits for this response to finish, returns failure error if request failed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, NoneType]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def finished(self) -&gt; typing.Union[str, NoneType]:
    &#34;&#34;&#34;Response.finished

    Waits for this response to finish, returns failure error if request failed.

    Returns
    -------
    Union[str, NoneType]
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; response.finished started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.finished())
        log_api(&#34;&lt;= response.finished succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= response.finished failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Response.json"><code class="name flex">
<span>async def <span class="ident">json</span></span>(<span>self) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Response.json</p>
<p>Returns the JSON representation of response body.</p>
<p>This method will throw if the response body is not parsable via <code>JSON.parse</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def json(self) -&gt; typing.Any:
    &#34;&#34;&#34;Response.json

    Returns the JSON representation of response body.

    This method will throw if the response body is not parsable via `JSON.parse`.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; response.json started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.json())
        log_api(&#34;&lt;= response.json succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= response.json failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Response.text"><code class="name flex">
<span>async def <span class="ident">text</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Response.text</p>
<p>Returns the text representation of response body.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def text(self) -&gt; str:
    &#34;&#34;&#34;Response.text

    Returns the text representation of response body.

    Returns
    -------
    str
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; response.text started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.text())
        log_api(&#34;&lt;= response.text succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= response.text failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Route"><code class="flex name class">
<span>class <span class="ident">Route</span></span>
<span>(</span><span>obj: playwright._impl._network.Route)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Route(AsyncBase):
    def __init__(self, obj: RouteImpl):
        super().__init__(obj)

    @property
    def request(self) -&gt; &#34;Request&#34;:
        &#34;&#34;&#34;Route.request

        A request to be routed.

        Returns
        -------
        Request
        &#34;&#34;&#34;
        return mapping.from_impl(self._impl_obj.request)

    async def abort(self, error_code: str = None) -&gt; NoneType:
        &#34;&#34;&#34;Route.abort

        Aborts the route&#39;s request.

        Parameters
        ----------
        error_code : Union[str, NoneType]
            Optional error code. Defaults to `failed`, could be one of the following:
            - `&#39;aborted&#39;` - An operation was aborted (due to user action)
            - `&#39;accessdenied&#39;` - Permission to access a resource, other than the network, was denied
            - `&#39;addressunreachable&#39;` - The IP address is unreachable. This usually means that there is no route to the specified
              host or network.
            - `&#39;blockedbyclient&#39;` - The client chose to block the request.
            - `&#39;blockedbyresponse&#39;` - The request failed because the response was delivered along with requirements which are not
              met (&#39;X-Frame-Options&#39; and &#39;Content-Security-Policy&#39; ancestor checks, for instance).
            - `&#39;connectionaborted&#39;` - A connection timed out as a result of not receiving an ACK for data sent.
            - `&#39;connectionclosed&#39;` - A connection was closed (corresponding to a TCP FIN).
            - `&#39;connectionfailed&#39;` - A connection attempt failed.
            - `&#39;connectionrefused&#39;` - A connection attempt was refused.
            - `&#39;connectionreset&#39;` - A connection was reset (corresponding to a TCP RST).
            - `&#39;internetdisconnected&#39;` - The Internet connection has been lost.
            - `&#39;namenotresolved&#39;` - The host name could not be resolved.
            - `&#39;timedout&#39;` - An operation timed out.
            - `&#39;failed&#39;` - A generic failure occurred.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; route.abort started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.abort(errorCode=error_code)
            )
            log_api(&#34;&lt;= route.abort succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= route.abort failed&#34;)
            raise e

    async def fulfill(
        self,
        status: int = None,
        headers: typing.Union[typing.Dict[str, str]] = None,
        body: typing.Union[str, bytes] = None,
        path: typing.Union[str, pathlib.Path] = None,
        content_type: str = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Route.fulfill

        Fulfills route&#39;s request with given response.

        An example of fulfilling all requests with 404 responses:

        ```py
        await page.route(\&#34;**/*\&#34;, lambda route: route.fulfill(
            status=404,
            content_type=\&#34;text/plain\&#34;,
            body=\&#34;not found!\&#34;))
        ```

        An example of serving static file:

        ```py
        await page.route(\&#34;**/xhr_endpoint\&#34;, lambda route: route.fulfill(path=\&#34;mock_data.json\&#34;))
        ```

        Parameters
        ----------
        status : Union[int, NoneType]
            Response status code, defaults to `200`.
        headers : Union[Dict[str, str], NoneType]
            Response headers. Header values will be converted to a string.
        body : Union[bytes, str, NoneType]
            Response body.
        path : Union[pathlib.Path, str, NoneType]
            File path to respond with. The content type will be inferred from file extension. If `path` is a relative path, then it
            is resolved relative to the current working directory.
        content_type : Union[str, NoneType]
            If set, equals to setting `Content-Type` response header.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; route.fulfill started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.fulfill(
                    status=status,
                    headers=mapping.to_impl(headers),
                    body=body,
                    path=path,
                    contentType=content_type,
                )
            )
            log_api(&#34;&lt;= route.fulfill succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= route.fulfill failed&#34;)
            raise e

    async def continue_(
        self,
        url: str = None,
        method: str = None,
        headers: typing.Union[typing.Dict[str, str]] = None,
        post_data: typing.Union[str, bytes] = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Route.continue_

        Continues route&#39;s request with optional overrides.

        ```py
        async def handle(route, request):
            # override headers
            headers = {
                **request.headers,
                \&#34;foo\&#34;: \&#34;bar\&#34; # set \&#34;foo\&#34; header
                \&#34;origin\&#34;: None # remove \&#34;origin\&#34; header
            }
            await route.continue(headers=headers)
        }
        await page.route(\&#34;**/*\&#34;, handle)
        ```

        Parameters
        ----------
        url : Union[str, NoneType]
            If set changes the request URL. New URL must have same protocol as original one.
        method : Union[str, NoneType]
            If set changes the request method (e.g. GET or POST)
        headers : Union[Dict[str, str], NoneType]
            If set changes the request HTTP headers. Header values will be converted to a string.
        post_data : Union[bytes, str, NoneType]
            If set changes the post data of request
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; route.continue_ started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.continue_(
                    url=url,
                    method=method,
                    headers=mapping.to_impl(headers),
                    postData=post_data,
                )
            )
            log_api(&#34;&lt;= route.continue_ succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= route.continue_ failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Route.request"><code class="name">var <span class="ident">request</span> : playwright.async_api._generated.Request</code></dt>
<dd>
<div class="desc"><p>Route.request</p>
<p>A request to be routed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def request(self) -&gt; &#34;Request&#34;:
    &#34;&#34;&#34;Route.request

    A request to be routed.

    Returns
    -------
    Request
    &#34;&#34;&#34;
    return mapping.from_impl(self._impl_obj.request)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Route.abort"><code class="name flex">
<span>async def <span class="ident">abort</span></span>(<span>self, error_code: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Route.abort</p>
<p>Aborts the route's request.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>error_code</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Optional error code. Defaults to <code>failed</code>, could be one of the following:
- <code>'aborted'</code> - An operation was aborted (due to user action)
- <code>'accessdenied'</code> - Permission to access a resource, other than the network, was denied
- <code>'addressunreachable'</code> - The IP address is unreachable. This usually means that there is no route to the specified
host or network.
- <code>'blockedbyclient'</code> - The client chose to block the request.
- <code>'blockedbyresponse'</code> - The request failed because the response was delivered along with requirements which are not
met ('X-Frame-Options' and 'Content-Security-Policy' ancestor checks, for instance).
- <code>'connectionaborted'</code> - A connection timed out as a result of not receiving an ACK for data sent.
- <code>'connectionclosed'</code> - A connection was closed (corresponding to a TCP FIN).
- <code>'connectionfailed'</code> - A connection attempt failed.
- <code>'connectionrefused'</code> - A connection attempt was refused.
- <code>'connectionreset'</code> - A connection was reset (corresponding to a TCP RST).
- <code>'internetdisconnected'</code> - The Internet connection has been lost.
- <code>'namenotresolved'</code> - The host name could not be resolved.
- <code>'timedout'</code> - An operation timed out.
- <code>'failed'</code> - A generic failure occurred.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def abort(self, error_code: str = None) -&gt; NoneType:
    &#34;&#34;&#34;Route.abort

    Aborts the route&#39;s request.

    Parameters
    ----------
    error_code : Union[str, NoneType]
        Optional error code. Defaults to `failed`, could be one of the following:
        - `&#39;aborted&#39;` - An operation was aborted (due to user action)
        - `&#39;accessdenied&#39;` - Permission to access a resource, other than the network, was denied
        - `&#39;addressunreachable&#39;` - The IP address is unreachable. This usually means that there is no route to the specified
          host or network.
        - `&#39;blockedbyclient&#39;` - The client chose to block the request.
        - `&#39;blockedbyresponse&#39;` - The request failed because the response was delivered along with requirements which are not
          met (&#39;X-Frame-Options&#39; and &#39;Content-Security-Policy&#39; ancestor checks, for instance).
        - `&#39;connectionaborted&#39;` - A connection timed out as a result of not receiving an ACK for data sent.
        - `&#39;connectionclosed&#39;` - A connection was closed (corresponding to a TCP FIN).
        - `&#39;connectionfailed&#39;` - A connection attempt failed.
        - `&#39;connectionrefused&#39;` - A connection attempt was refused.
        - `&#39;connectionreset&#39;` - A connection was reset (corresponding to a TCP RST).
        - `&#39;internetdisconnected&#39;` - The Internet connection has been lost.
        - `&#39;namenotresolved&#39;` - The host name could not be resolved.
        - `&#39;timedout&#39;` - An operation timed out.
        - `&#39;failed&#39;` - A generic failure occurred.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; route.abort started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.abort(errorCode=error_code)
        )
        log_api(&#34;&lt;= route.abort succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= route.abort failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Route.continue_"><code class="name flex">
<span>async def <span class="ident">continue_</span></span>(<span>self, url: str = None, method: str = None, headers: Dict[str, str] = None, post_data: Union[str, bytes] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Route.continue_</p>
<p>Continues route's request with optional overrides.</p>
<pre><code class="language-py">async def handle(route, request):
    # override headers
    headers = {
        **request.headers,
        &quot;foo&quot;: &quot;bar&quot; # set &quot;foo&quot; header
        &quot;origin&quot;: None # remove &quot;origin&quot; header
    }
    await route.continue(headers=headers)
}
await page.route(&quot;**/*&quot;, handle)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>If set changes the request URL. New URL must have same protocol as original one.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>If set changes the request method (e.g. GET or POST)</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>Union[Dict[str, str], NoneType]</code></dt>
<dd>If set changes the request HTTP headers. Header values will be converted to a string.</dd>
<dt><strong><code>post_data</code></strong> :&ensp;<code>Union[bytes, str, NoneType]</code></dt>
<dd>If set changes the post data of request</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def continue_(
    self,
    url: str = None,
    method: str = None,
    headers: typing.Union[typing.Dict[str, str]] = None,
    post_data: typing.Union[str, bytes] = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Route.continue_

    Continues route&#39;s request with optional overrides.

    ```py
    async def handle(route, request):
        # override headers
        headers = {
            **request.headers,
            \&#34;foo\&#34;: \&#34;bar\&#34; # set \&#34;foo\&#34; header
            \&#34;origin\&#34;: None # remove \&#34;origin\&#34; header
        }
        await route.continue(headers=headers)
    }
    await page.route(\&#34;**/*\&#34;, handle)
    ```

    Parameters
    ----------
    url : Union[str, NoneType]
        If set changes the request URL. New URL must have same protocol as original one.
    method : Union[str, NoneType]
        If set changes the request method (e.g. GET or POST)
    headers : Union[Dict[str, str], NoneType]
        If set changes the request HTTP headers. Header values will be converted to a string.
    post_data : Union[bytes, str, NoneType]
        If set changes the post data of request
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; route.continue_ started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.continue_(
                url=url,
                method=method,
                headers=mapping.to_impl(headers),
                postData=post_data,
            )
        )
        log_api(&#34;&lt;= route.continue_ succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= route.continue_ failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Route.fulfill"><code class="name flex">
<span>async def <span class="ident">fulfill</span></span>(<span>self, status: int = None, headers: Dict[str, str] = None, body: Union[str, bytes] = None, path: Union[str, pathlib.Path] = None, content_type: str = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Route.fulfill</p>
<p>Fulfills route's request with given response.</p>
<p>An example of fulfilling all requests with 404 responses:</p>
<pre><code class="language-py">await page.route(&quot;**/*&quot;, lambda route: route.fulfill(
    status=404,
    content_type=&quot;text/plain&quot;,
    body=&quot;not found!&quot;))
</code></pre>
<p>An example of serving static file:</p>
<pre><code class="language-py">await page.route(&quot;**/xhr_endpoint&quot;, lambda route: route.fulfill(path=&quot;mock_data.json&quot;))
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>status</code></strong> :&ensp;<code>Union[int, NoneType]</code></dt>
<dd>Response status code, defaults to <code>200</code>.</dd>
<dt><strong><code>headers</code></strong> :&ensp;<code>Union[Dict[str, str], NoneType]</code></dt>
<dd>Response headers. Header values will be converted to a string.</dd>
<dt><strong><code>body</code></strong> :&ensp;<code>Union[bytes, str, NoneType]</code></dt>
<dd>Response body.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>File path to respond with. The content type will be inferred from file extension. If <code>path</code> is a relative path, then it
is resolved relative to the current working directory.</dd>
<dt><strong><code>content_type</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>If set, equals to setting <code>Content-Type</code> response header.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def fulfill(
    self,
    status: int = None,
    headers: typing.Union[typing.Dict[str, str]] = None,
    body: typing.Union[str, bytes] = None,
    path: typing.Union[str, pathlib.Path] = None,
    content_type: str = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Route.fulfill

    Fulfills route&#39;s request with given response.

    An example of fulfilling all requests with 404 responses:

    ```py
    await page.route(\&#34;**/*\&#34;, lambda route: route.fulfill(
        status=404,
        content_type=\&#34;text/plain\&#34;,
        body=\&#34;not found!\&#34;))
    ```

    An example of serving static file:

    ```py
    await page.route(\&#34;**/xhr_endpoint\&#34;, lambda route: route.fulfill(path=\&#34;mock_data.json\&#34;))
    ```

    Parameters
    ----------
    status : Union[int, NoneType]
        Response status code, defaults to `200`.
    headers : Union[Dict[str, str], NoneType]
        Response headers. Header values will be converted to a string.
    body : Union[bytes, str, NoneType]
        Response body.
    path : Union[pathlib.Path, str, NoneType]
        File path to respond with. The content type will be inferred from file extension. If `path` is a relative path, then it
        is resolved relative to the current working directory.
    content_type : Union[str, NoneType]
        If set, equals to setting `Content-Type` response header.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; route.fulfill started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.fulfill(
                status=status,
                headers=mapping.to_impl(headers),
                body=body,
                path=path,
                contentType=content_type,
            )
        )
        log_api(&#34;&lt;= route.fulfill succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= route.fulfill failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Selectors"><code class="flex name class">
<span>class <span class="ident">Selectors</span></span>
<span>(</span><span>obj: playwright._impl._selectors.Selectors)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Selectors(AsyncBase):
    def __init__(self, obj: SelectorsImpl):
        super().__init__(obj)

    async def register(
        self,
        name: str,
        script: str = None,
        path: typing.Union[str, pathlib.Path] = None,
        content_script: bool = None,
    ) -&gt; NoneType:
        &#34;&#34;&#34;Selectors.register

        An example of registering selector engine that queries elements based on a tag name:

        ```py
        # FIXME: add snippet
        ```

        Parameters
        ----------
        name : str
            Name that is used in selectors as a prefix, e.g. `{name: &#39;foo&#39;}` enables `foo=myselectorbody` selectors. May only
            contain `[a-zA-Z0-9_]` characters.
        script : Union[str, NoneType]
            Raw script content.
        path : Union[pathlib.Path, str, NoneType]
            Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to the current working
            directory.
        content_script : Union[bool, NoneType]
            Whether to run this selector engine in isolated JavaScript environment. This environment has access to the same DOM, but
            not any JavaScript objects from the frame&#39;s scripts. Defaults to `false`. Note that running as a content script is not
            guaranteed when this engine is used together with other registered engines.
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; selectors.register started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.register(
                    name=name, script=script, path=path, contentScript=content_script
                )
            )
            log_api(&#34;&lt;= selectors.register succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= selectors.register failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Selectors.register"><code class="name flex">
<span>async def <span class="ident">register</span></span>(<span>self, name: str, script: str = None, path: Union[str, pathlib.Path] = None, content_script: bool = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Selectors.register</p>
<p>An example of registering selector engine that queries elements based on a tag name:</p>
<pre><code class="language-py"># FIXME: add snippet
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name that is used in selectors as a prefix, e.g. <code>{name: 'foo'}</code> enables <code>foo=myselectorbody</code> selectors. May only
contain <code>[a-zA-Z0-9_]</code> characters.</dd>
<dt><strong><code>script</code></strong> :&ensp;<code>Union[str, NoneType]</code></dt>
<dd>Raw script content.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[pathlib.Path, str, NoneType]</code></dt>
<dd>Path to the JavaScript file. If <code>path</code> is a relative path, then it is resolved relative to the current working
directory.</dd>
<dt><strong><code>content_script</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to run this selector engine in isolated JavaScript environment. This environment has access to the same DOM, but
not any JavaScript objects from the frame's scripts. Defaults to <code>false</code>. Note that running as a content script is not
guaranteed when this engine is used together with other registered engines.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def register(
    self,
    name: str,
    script: str = None,
    path: typing.Union[str, pathlib.Path] = None,
    content_script: bool = None,
) -&gt; NoneType:
    &#34;&#34;&#34;Selectors.register

    An example of registering selector engine that queries elements based on a tag name:

    ```py
    # FIXME: add snippet
    ```

    Parameters
    ----------
    name : str
        Name that is used in selectors as a prefix, e.g. `{name: &#39;foo&#39;}` enables `foo=myselectorbody` selectors. May only
        contain `[a-zA-Z0-9_]` characters.
    script : Union[str, NoneType]
        Raw script content.
    path : Union[pathlib.Path, str, NoneType]
        Path to the JavaScript file. If `path` is a relative path, then it is resolved relative to the current working
        directory.
    content_script : Union[bool, NoneType]
        Whether to run this selector engine in isolated JavaScript environment. This environment has access to the same DOM, but
        not any JavaScript objects from the frame&#39;s scripts. Defaults to `false`. Note that running as a content script is not
        guaranteed when this engine is used together with other registered engines.
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; selectors.register started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.register(
                name=name, script=script, path=path, contentScript=content_script
            )
        )
        log_api(&#34;&lt;= selectors.register succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= selectors.register failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.SourceLocation"><code class="flex name class">
<span>class <span class="ident">SourceLocation</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SourceLocation(TypedDict):
    url: str
    lineNumber: int
    columnNumber: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.SourceLocation.columnNumber"><code class="name">var <span class="ident">columnNumber</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.SourceLocation.lineNumber"><code class="name">var <span class="ident">lineNumber</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.SourceLocation.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.StorageState"><code class="flex name class">
<span>class <span class="ident">StorageState</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StorageState(TypedDict, total=False):
    cookies: Optional[List[Cookie]]
    origins: Optional[List[OriginState]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.StorageState.cookies"><code class="name">var <span class="ident">cookies</span> : Union[List[playwright._impl._api_structures.Cookie], NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.StorageState.origins"><code class="name">var <span class="ident">origins</span> : Union[List[playwright._impl._api_structures.OriginState], NoneType]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.TimeoutError"><code class="flex name class">
<span>class <span class="ident">TimeoutError</span></span>
<span>(</span><span>message: str, stack: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeoutError(Error):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._api_types.Error</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="playwright.async_api.Touchscreen"><code class="flex name class">
<span>class <span class="ident">Touchscreen</span></span>
<span>(</span><span>obj: playwright._impl._input.Touchscreen)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Touchscreen(AsyncBase):
    def __init__(self, obj: TouchscreenImpl):
        super().__init__(obj)

    async def tap(self, x: float, y: float) -&gt; NoneType:
        &#34;&#34;&#34;Touchscreen.tap

        Dispatches a `touchstart` and `touchend` event with a single touch at the position (`x`,`y`).

        Parameters
        ----------
        x : float
        y : float
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; touchscreen.tap started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.tap(x=x, y=y))
            log_api(&#34;&lt;= touchscreen.tap succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= touchscreen.tap failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Touchscreen.tap"><code class="name flex">
<span>async def <span class="ident">tap</span></span>(<span>self, x: float, y: float) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Touchscreen.tap</p>
<p>Dispatches a <code>touchstart</code> and <code>touchend</code> event with a single touch at the position (<code>x</code>,<code>y</code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def tap(self, x: float, y: float) -&gt; NoneType:
    &#34;&#34;&#34;Touchscreen.tap

    Dispatches a `touchstart` and `touchend` event with a single touch at the position (`x`,`y`).

    Parameters
    ----------
    x : float
    y : float
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; touchscreen.tap started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.tap(x=x, y=y))
        log_api(&#34;&lt;= touchscreen.tap succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= touchscreen.tap failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Video"><code class="flex name class">
<span>class <span class="ident">Video</span></span>
<span>(</span><span>obj: playwright._impl._video.Video)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Video(AsyncBase):
    def __init__(self, obj: VideoImpl):
        super().__init__(obj)

    async def path(self) -&gt; pathlib.Path:
        &#34;&#34;&#34;Video.path

        Returns the file system path this video will be recorded to. The video is guaranteed to be written to the filesystem
        upon closing the browser context.

        Returns
        -------
        pathlib.Path
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; video.path started&#34;)
            result = mapping.from_maybe_impl(await self._impl_obj.path())
            log_api(&#34;&lt;= video.path succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= video.path failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Video.path"><code class="name flex">
<span>async def <span class="ident">path</span></span>(<span>self) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"><p>Video.path</p>
<p>Returns the file system path this video will be recorded to. The video is guaranteed to be written to the filesystem
upon closing the browser context.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pathlib.Path</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def path(self) -&gt; pathlib.Path:
    &#34;&#34;&#34;Video.path

    Returns the file system path this video will be recorded to. The video is guaranteed to be written to the filesystem
    upon closing the browser context.

    Returns
    -------
    pathlib.Path
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; video.path started&#34;)
        result = mapping.from_maybe_impl(await self._impl_obj.path())
        log_api(&#34;&lt;= video.path succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= video.path failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.ViewportSize"><code class="flex name class">
<span>class <span class="ident">ViewportSize</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ViewportSize(TypedDict):
    width: int
    height: int</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="playwright.async_api.ViewportSize.height"><code class="name">var <span class="ident">height</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="playwright.async_api.ViewportSize.width"><code class="name">var <span class="ident">width</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.WebSocket"><code class="flex name class">
<span>class <span class="ident">WebSocket</span></span>
<span>(</span><span>obj: playwright._impl._network.WebSocket)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WebSocket(AsyncBase):
    def __init__(self, obj: WebSocketImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;WebSocket.url

        Contains the URL of the WebSocket.

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    def expect_event(
        self, event: str, predicate: typing.Callable = None, timeout: float = None
    ) -&gt; AsyncEventContextManager:
        &#34;&#34;&#34;WebSocket.expect_event

        Performs action and waits for given `event` to fire. If predicate is provided, it passes event&#39;s value into the
        `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the socket is
        closed before the `event` is fired.

        ```py
        async with ws.expect_event(event_name) as event_info:
            await ws.click(\&#34;button\&#34;)
        value = await event_info.value
        ```

        Parameters
        ----------
        event : str
            Event name, same one typically passed into `*.on(event)`.
        predicate : Union[Callable, NoneType]
            Receives the event data and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        EventContextManager
        &#34;&#34;&#34;

        return AsyncEventContextManager(
            self._impl_obj.expect_event(
                event=event, predicate=self._wrap_handler(predicate), timeout=timeout
            ).future
        )

    async def wait_for_event(
        self, event: str, predicate: typing.Callable = None, timeout: float = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;WebSocket.wait_for_event

        Returns the event data value.

        Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
        value. Will throw an error if the webSocket is closed before the event is fired.

        Parameters
        ----------
        event : str
            Event name, same one would pass into `webSocket.on(event)`.
        predicate : Union[Callable, NoneType]
            Receives the event data and resolves to truthy value when the waiting should resolve.
        timeout : Union[float, NoneType]
            Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
            value can be changed by using the `browser_context.set_default_timeout()`.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; web_socket.wait_for_event started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.wait_for_event(
                    event=event,
                    predicate=self._wrap_handler(predicate),
                    timeout=timeout,
                )
            )
            log_api(&#34;&lt;= web_socket.wait_for_event succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= web_socket.wait_for_event failed&#34;)
            raise e

    def is_closed(self) -&gt; bool:
        &#34;&#34;&#34;WebSocket.is_closed

        Indicates that the web socket has been closed.

        Returns
        -------
        bool
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; web_socket.is_closed started&#34;)
            result = mapping.from_maybe_impl(self._impl_obj.is_closed())
            log_api(&#34;&lt;= web_socket.is_closed succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= web_socket.is_closed failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.WebSocket.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>WebSocket.url</p>
<p>Contains the URL of the WebSocket.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;WebSocket.url

    Contains the URL of the WebSocket.

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.WebSocket.expect_event"><code class="name flex">
<span>def <span class="ident">expect_event</span></span>(<span>self, event: str, predicate: Callable = None, timeout: float = None) ‑> playwright._impl._async_base.AsyncEventContextManager</span>
</code></dt>
<dd>
<div class="desc"><p>WebSocket.expect_event</p>
<p>Performs action and waits for given <code>event</code> to fire. If predicate is provided, it passes event's value into the
<code>predicate</code> function and waits for <code>predicate(event)</code> to return a truthy value. Will throw an error if the socket is
closed before the <code>event</code> is fired.</p>
<pre><code class="language-py">async with ws.expect_event(event_name) as event_info:
    await ws.click(&quot;button&quot;)
value = await event_info.value
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>Event name, same one typically passed into <code>*.on(event)</code>.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable, NoneType]</code></dt>
<dd>Receives the event data and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>EventContextManager</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expect_event(
    self, event: str, predicate: typing.Callable = None, timeout: float = None
) -&gt; AsyncEventContextManager:
    &#34;&#34;&#34;WebSocket.expect_event

    Performs action and waits for given `event` to fire. If predicate is provided, it passes event&#39;s value into the
    `predicate` function and waits for `predicate(event)` to return a truthy value. Will throw an error if the socket is
    closed before the `event` is fired.

    ```py
    async with ws.expect_event(event_name) as event_info:
        await ws.click(\&#34;button\&#34;)
    value = await event_info.value
    ```

    Parameters
    ----------
    event : str
        Event name, same one typically passed into `*.on(event)`.
    predicate : Union[Callable, NoneType]
        Receives the event data and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    EventContextManager
    &#34;&#34;&#34;

    return AsyncEventContextManager(
        self._impl_obj.expect_event(
            event=event, predicate=self._wrap_handler(predicate), timeout=timeout
        ).future
    )</code></pre>
</details>
</dd>
<dt id="playwright.async_api.WebSocket.is_closed"><code class="name flex">
<span>def <span class="ident">is_closed</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>WebSocket.is_closed</p>
<p>Indicates that the web socket has been closed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_closed(self) -&gt; bool:
    &#34;&#34;&#34;WebSocket.is_closed

    Indicates that the web socket has been closed.

    Returns
    -------
    bool
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; web_socket.is_closed started&#34;)
        result = mapping.from_maybe_impl(self._impl_obj.is_closed())
        log_api(&#34;&lt;= web_socket.is_closed succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= web_socket.is_closed failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.WebSocket.wait_for_event"><code class="name flex">
<span>async def <span class="ident">wait_for_event</span></span>(<span>self, event: str, predicate: Callable = None, timeout: float = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>WebSocket.wait_for_event</p>
<p>Returns the event data value.</p>
<p>Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
value. Will throw an error if the webSocket is closed before the event is fired.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>event</code></strong> :&ensp;<code>str</code></dt>
<dd>Event name, same one would pass into <code>webSocket.on(event)</code>.</dd>
<dt><strong><code>predicate</code></strong> :&ensp;<code>Union[Callable, NoneType]</code></dt>
<dd>Receives the event data and resolves to truthy value when the waiting should resolve.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>Union[float, NoneType]</code></dt>
<dd>Maximum time to wait for in milliseconds. Defaults to <code>30000</code> (30 seconds). Pass <code>0</code> to disable timeout. The default
value can be changed by using the <code>browser_context.set_default_timeout()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_event(
    self, event: str, predicate: typing.Callable = None, timeout: float = None
) -&gt; typing.Any:
    &#34;&#34;&#34;WebSocket.wait_for_event

    Returns the event data value.

    Waits for event to fire and passes its value into the predicate function. Returns when the predicate returns truthy
    value. Will throw an error if the webSocket is closed before the event is fired.

    Parameters
    ----------
    event : str
        Event name, same one would pass into `webSocket.on(event)`.
    predicate : Union[Callable, NoneType]
        Receives the event data and resolves to truthy value when the waiting should resolve.
    timeout : Union[float, NoneType]
        Maximum time to wait for in milliseconds. Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
        value can be changed by using the `browser_context.set_default_timeout()`.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; web_socket.wait_for_event started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.wait_for_event(
                event=event,
                predicate=self._wrap_handler(predicate),
                timeout=timeout,
            )
        )
        log_api(&#34;&lt;= web_socket.wait_for_event succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= web_socket.wait_for_event failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="playwright.async_api.Worker"><code class="flex name class">
<span>class <span class="ident">Worker</span></span>
<span>(</span><span>obj: playwright._impl._page.Worker)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Worker(AsyncBase):
    def __init__(self, obj: WorkerImpl):
        super().__init__(obj)

    @property
    def url(self) -&gt; str:
        &#34;&#34;&#34;Worker.url

        Returns
        -------
        str
        &#34;&#34;&#34;
        return mapping.from_maybe_impl(self._impl_obj.url)

    async def evaluate(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; typing.Any:
        &#34;&#34;&#34;Worker.evaluate

        Returns the return value of `pageFunction`

        If the function passed to the `worker.evaluate` returns a [Promise], then `worker.evaluate` would wait for the promise
        to resolve and return its value.

        If the function passed to the `worker.evaluate` returns a non-[Serializable] value, then `worker.evaluate` returns
        `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`:
        `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        Any
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; worker.evaluate started&#34;)
            result = mapping.from_maybe_impl(
                await self._impl_obj.evaluate(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= worker.evaluate succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= worker.evaluate failed&#34;)
            raise e

    async def evaluate_handle(
        self, expression: str, arg: typing.Any = None, force_expr: bool = None
    ) -&gt; &#34;JSHandle&#34;:
        &#34;&#34;&#34;Worker.evaluate_handle

        Returns the return value of `pageFunction` as in-page object (JSHandle).

        The only difference between `worker.evaluate` and `worker.evaluateHandle` is that `worker.evaluateHandle` returns
        in-page object (JSHandle).

        If the function passed to the `worker.evaluateHandle` returns a [Promise], then `worker.evaluateHandle` would wait for
        the promise to resolve and return its value.

        Parameters
        ----------
        expression : str
            JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
            as a function. Otherwise, evaluated as an expression.
        arg : Union[Any, NoneType]
            Optional argument to pass to `pageFunction`
        force_expr : Union[bool, NoneType]
            Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
            Optional.

        Returns
        -------
        JSHandle
        &#34;&#34;&#34;

        try:
            log_api(&#34;=&gt; worker.evaluate_handle started&#34;)
            result = mapping.from_impl(
                await self._impl_obj.evaluate_handle(
                    expression=expression,
                    arg=mapping.to_impl(arg),
                    force_expr=force_expr,
                )
            )
            log_api(&#34;&lt;= worker.evaluate_handle succeded&#34;)
            return result
        except Exception as e:
            log_api(&#34;&lt;= worker.evaluate_handle failed&#34;)
            raise e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>playwright._impl._async_base.AsyncBase</li>
<li>playwright._impl._impl_to_api_mapping.ImplWrapper</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="playwright.async_api.Worker.url"><code class="name">var <span class="ident">url</span> : str</code></dt>
<dd>
<div class="desc"><p>Worker.url</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def url(self) -&gt; str:
    &#34;&#34;&#34;Worker.url

    Returns
    -------
    str
    &#34;&#34;&#34;
    return mapping.from_maybe_impl(self._impl_obj.url)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="playwright.async_api.Worker.evaluate"><code class="name flex">
<span>async def <span class="ident">evaluate</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Worker.evaluate</p>
<p>Returns the return value of <code>pageFunction</code></p>
<p>If the function passed to the <code>worker.evaluate</code> returns a [Promise], then <code>worker.evaluate</code> would wait for the promise
to resolve and return its value.</p>
<p>If the function passed to the <code>worker.evaluate</code> returns a non-[Serializable] value, then <code>worker.evaluate</code> returns
<code>undefined</code>. DevTools Protocol also supports transferring some additional values that are not serializable by <code>JSON</code>:
<code>-0</code>, <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>, and bigint literals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def evaluate(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; typing.Any:
    &#34;&#34;&#34;Worker.evaluate

    Returns the return value of `pageFunction`

    If the function passed to the `worker.evaluate` returns a [Promise], then `worker.evaluate` would wait for the promise
    to resolve and return its value.

    If the function passed to the `worker.evaluate` returns a non-[Serializable] value, then `worker.evaluate` returns
    `undefined`. DevTools Protocol also supports transferring some additional values that are not serializable by `JSON`:
    `-0`, `NaN`, `Infinity`, `-Infinity`, and bigint literals.

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    Any
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; worker.evaluate started&#34;)
        result = mapping.from_maybe_impl(
            await self._impl_obj.evaluate(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= worker.evaluate succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= worker.evaluate failed&#34;)
        raise e</code></pre>
</details>
</dd>
<dt id="playwright.async_api.Worker.evaluate_handle"><code class="name flex">
<span>async def <span class="ident">evaluate_handle</span></span>(<span>self, expression: str, arg: Any = None, force_expr: bool = None) ‑> playwright.async_api._generated.JSHandle</span>
</code></dt>
<dd>
<div class="desc"><p>Worker.evaluate_handle</p>
<p>Returns the return value of <code>pageFunction</code> as in-page object (JSHandle).</p>
<p>The only difference between <code>worker.evaluate</code> and <code>worker.evaluateHandle</code> is that <code>worker.evaluateHandle</code> returns
in-page object (JSHandle).</p>
<p>If the function passed to the <code>worker.evaluateHandle</code> returns a [Promise], then <code>worker.evaluateHandle</code> would wait for
the promise to resolve and return its value.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>expression</code></strong> :&ensp;<code>str</code></dt>
<dd>JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
as a function. Otherwise, evaluated as an expression.</dd>
<dt><strong><code>arg</code></strong> :&ensp;<code>Union[Any, NoneType]</code></dt>
<dd>Optional argument to pass to <code>pageFunction</code></dd>
<dt><strong><code>force_expr</code></strong> :&ensp;<code>Union[bool, NoneType]</code></dt>
<dd>Whether to treat given <code>expression</code> as JavaScript evaluate expression, even though it looks like an arrow function.
Optional.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def evaluate_handle(
    self, expression: str, arg: typing.Any = None, force_expr: bool = None
) -&gt; &#34;JSHandle&#34;:
    &#34;&#34;&#34;Worker.evaluate_handle

    Returns the return value of `pageFunction` as in-page object (JSHandle).

    The only difference between `worker.evaluate` and `worker.evaluateHandle` is that `worker.evaluateHandle` returns
    in-page object (JSHandle).

    If the function passed to the `worker.evaluateHandle` returns a [Promise], then `worker.evaluateHandle` would wait for
    the promise to resolve and return its value.

    Parameters
    ----------
    expression : str
        JavaScript expression to be evaluated in the browser context. If it looks like a function declaration, it is interpreted
        as a function. Otherwise, evaluated as an expression.
    arg : Union[Any, NoneType]
        Optional argument to pass to `pageFunction`
    force_expr : Union[bool, NoneType]
        Whether to treat given `expression` as JavaScript evaluate expression, even though it looks like an arrow function.
        Optional.

    Returns
    -------
    JSHandle
    &#34;&#34;&#34;

    try:
        log_api(&#34;=&gt; worker.evaluate_handle started&#34;)
        result = mapping.from_impl(
            await self._impl_obj.evaluate_handle(
                expression=expression,
                arg=mapping.to_impl(arg),
                force_expr=force_expr,
            )
        )
        log_api(&#34;&lt;= worker.evaluate_handle succeded&#34;)
        return result
    except Exception as e:
        log_api(&#34;&lt;= worker.evaluate_handle failed&#34;)
        raise e</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="playwright" href="../index.html">playwright</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="playwright.async_api.async_playwright" href="#playwright.async_api.async_playwright">async_playwright</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="playwright.async_api.Accessibility" href="#playwright.async_api.Accessibility">Accessibility</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Accessibility.snapshot" href="#playwright.async_api.Accessibility.snapshot">snapshot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.BindingCall" href="#playwright.async_api.BindingCall">BindingCall</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.BindingCall.call" href="#playwright.async_api.BindingCall.call">call</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Browser" href="#playwright.async_api.Browser">Browser</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.async_api.Browser.close" href="#playwright.async_api.Browser.close">close</a></code></li>
<li><code><a title="playwright.async_api.Browser.contexts" href="#playwright.async_api.Browser.contexts">contexts</a></code></li>
<li><code><a title="playwright.async_api.Browser.is_connected" href="#playwright.async_api.Browser.is_connected">is_connected</a></code></li>
<li><code><a title="playwright.async_api.Browser.new_context" href="#playwright.async_api.Browser.new_context">new_context</a></code></li>
<li><code><a title="playwright.async_api.Browser.new_page" href="#playwright.async_api.Browser.new_page">new_page</a></code></li>
<li><code><a title="playwright.async_api.Browser.version" href="#playwright.async_api.Browser.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.BrowserContext" href="#playwright.async_api.BrowserContext">BrowserContext</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.BrowserContext.add_cookies" href="#playwright.async_api.BrowserContext.add_cookies">add_cookies</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.add_init_script" href="#playwright.async_api.BrowserContext.add_init_script">add_init_script</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.browser" href="#playwright.async_api.BrowserContext.browser">browser</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.clear_cookies" href="#playwright.async_api.BrowserContext.clear_cookies">clear_cookies</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.clear_permissions" href="#playwright.async_api.BrowserContext.clear_permissions">clear_permissions</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.close" href="#playwright.async_api.BrowserContext.close">close</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.cookies" href="#playwright.async_api.BrowserContext.cookies">cookies</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.expect_event" href="#playwright.async_api.BrowserContext.expect_event">expect_event</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.expect_page" href="#playwright.async_api.BrowserContext.expect_page">expect_page</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.expose_binding" href="#playwright.async_api.BrowserContext.expose_binding">expose_binding</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.expose_function" href="#playwright.async_api.BrowserContext.expose_function">expose_function</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.grant_permissions" href="#playwright.async_api.BrowserContext.grant_permissions">grant_permissions</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.new_page" href="#playwright.async_api.BrowserContext.new_page">new_page</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.pages" href="#playwright.async_api.BrowserContext.pages">pages</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.route" href="#playwright.async_api.BrowserContext.route">route</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.set_default_navigation_timeout" href="#playwright.async_api.BrowserContext.set_default_navigation_timeout">set_default_navigation_timeout</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.set_default_timeout" href="#playwright.async_api.BrowserContext.set_default_timeout">set_default_timeout</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.set_extra_http_headers" href="#playwright.async_api.BrowserContext.set_extra_http_headers">set_extra_http_headers</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.set_geolocation" href="#playwright.async_api.BrowserContext.set_geolocation">set_geolocation</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.set_offline" href="#playwright.async_api.BrowserContext.set_offline">set_offline</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.storage_state" href="#playwright.async_api.BrowserContext.storage_state">storage_state</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.unroute" href="#playwright.async_api.BrowserContext.unroute">unroute</a></code></li>
<li><code><a title="playwright.async_api.BrowserContext.wait_for_event" href="#playwright.async_api.BrowserContext.wait_for_event">wait_for_event</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.BrowserType" href="#playwright.async_api.BrowserType">BrowserType</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.BrowserType.executable_path" href="#playwright.async_api.BrowserType.executable_path">executable_path</a></code></li>
<li><code><a title="playwright.async_api.BrowserType.launch" href="#playwright.async_api.BrowserType.launch">launch</a></code></li>
<li><code><a title="playwright.async_api.BrowserType.launch_persistent_context" href="#playwright.async_api.BrowserType.launch_persistent_context">launch_persistent_context</a></code></li>
<li><code><a title="playwright.async_api.BrowserType.name" href="#playwright.async_api.BrowserType.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.CDPSession" href="#playwright.async_api.CDPSession">CDPSession</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.CDPSession.detach" href="#playwright.async_api.CDPSession.detach">detach</a></code></li>
<li><code><a title="playwright.async_api.CDPSession.send" href="#playwright.async_api.CDPSession.send">send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.ChromiumBrowserContext" href="#playwright.async_api.ChromiumBrowserContext">ChromiumBrowserContext</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.ChromiumBrowserContext.background_pages" href="#playwright.async_api.ChromiumBrowserContext.background_pages">background_pages</a></code></li>
<li><code><a title="playwright.async_api.ChromiumBrowserContext.new_cdp_session" href="#playwright.async_api.ChromiumBrowserContext.new_cdp_session">new_cdp_session</a></code></li>
<li><code><a title="playwright.async_api.ChromiumBrowserContext.service_workers" href="#playwright.async_api.ChromiumBrowserContext.service_workers">service_workers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.ConsoleMessage" href="#playwright.async_api.ConsoleMessage">ConsoleMessage</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.ConsoleMessage.args" href="#playwright.async_api.ConsoleMessage.args">args</a></code></li>
<li><code><a title="playwright.async_api.ConsoleMessage.location" href="#playwright.async_api.ConsoleMessage.location">location</a></code></li>
<li><code><a title="playwright.async_api.ConsoleMessage.text" href="#playwright.async_api.ConsoleMessage.text">text</a></code></li>
<li><code><a title="playwright.async_api.ConsoleMessage.type" href="#playwright.async_api.ConsoleMessage.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Cookie" href="#playwright.async_api.Cookie">Cookie</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.async_api.Cookie.domain" href="#playwright.async_api.Cookie.domain">domain</a></code></li>
<li><code><a title="playwright.async_api.Cookie.expires" href="#playwright.async_api.Cookie.expires">expires</a></code></li>
<li><code><a title="playwright.async_api.Cookie.httpOnly" href="#playwright.async_api.Cookie.httpOnly">httpOnly</a></code></li>
<li><code><a title="playwright.async_api.Cookie.name" href="#playwright.async_api.Cookie.name">name</a></code></li>
<li><code><a title="playwright.async_api.Cookie.path" href="#playwright.async_api.Cookie.path">path</a></code></li>
<li><code><a title="playwright.async_api.Cookie.sameSite" href="#playwright.async_api.Cookie.sameSite">sameSite</a></code></li>
<li><code><a title="playwright.async_api.Cookie.secure" href="#playwright.async_api.Cookie.secure">secure</a></code></li>
<li><code><a title="playwright.async_api.Cookie.url" href="#playwright.async_api.Cookie.url">url</a></code></li>
<li><code><a title="playwright.async_api.Cookie.value" href="#playwright.async_api.Cookie.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Dialog" href="#playwright.async_api.Dialog">Dialog</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Dialog.accept" href="#playwright.async_api.Dialog.accept">accept</a></code></li>
<li><code><a title="playwright.async_api.Dialog.default_value" href="#playwright.async_api.Dialog.default_value">default_value</a></code></li>
<li><code><a title="playwright.async_api.Dialog.dismiss" href="#playwright.async_api.Dialog.dismiss">dismiss</a></code></li>
<li><code><a title="playwright.async_api.Dialog.message" href="#playwright.async_api.Dialog.message">message</a></code></li>
<li><code><a title="playwright.async_api.Dialog.type" href="#playwright.async_api.Dialog.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Download" href="#playwright.async_api.Download">Download</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.async_api.Download.delete" href="#playwright.async_api.Download.delete">delete</a></code></li>
<li><code><a title="playwright.async_api.Download.failure" href="#playwright.async_api.Download.failure">failure</a></code></li>
<li><code><a title="playwright.async_api.Download.path" href="#playwright.async_api.Download.path">path</a></code></li>
<li><code><a title="playwright.async_api.Download.save_as" href="#playwright.async_api.Download.save_as">save_as</a></code></li>
<li><code><a title="playwright.async_api.Download.suggested_filename" href="#playwright.async_api.Download.suggested_filename">suggested_filename</a></code></li>
<li><code><a title="playwright.async_api.Download.url" href="#playwright.async_api.Download.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.ElementHandle" href="#playwright.async_api.ElementHandle">ElementHandle</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.ElementHandle.as_element" href="#playwright.async_api.ElementHandle.as_element">as_element</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.bounding_box" href="#playwright.async_api.ElementHandle.bounding_box">bounding_box</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.check" href="#playwright.async_api.ElementHandle.check">check</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.click" href="#playwright.async_api.ElementHandle.click">click</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.content_frame" href="#playwright.async_api.ElementHandle.content_frame">content_frame</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.dblclick" href="#playwright.async_api.ElementHandle.dblclick">dblclick</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.dispatch_event" href="#playwright.async_api.ElementHandle.dispatch_event">dispatch_event</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.eval_on_selector" href="#playwright.async_api.ElementHandle.eval_on_selector">eval_on_selector</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.eval_on_selector_all" href="#playwright.async_api.ElementHandle.eval_on_selector_all">eval_on_selector_all</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.fill" href="#playwright.async_api.ElementHandle.fill">fill</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.focus" href="#playwright.async_api.ElementHandle.focus">focus</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.get_attribute" href="#playwright.async_api.ElementHandle.get_attribute">get_attribute</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.hover" href="#playwright.async_api.ElementHandle.hover">hover</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.inner_html" href="#playwright.async_api.ElementHandle.inner_html">inner_html</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.inner_text" href="#playwright.async_api.ElementHandle.inner_text">inner_text</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.is_checked" href="#playwright.async_api.ElementHandle.is_checked">is_checked</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.is_disabled" href="#playwright.async_api.ElementHandle.is_disabled">is_disabled</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.is_editable" href="#playwright.async_api.ElementHandle.is_editable">is_editable</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.is_enabled" href="#playwright.async_api.ElementHandle.is_enabled">is_enabled</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.is_hidden" href="#playwright.async_api.ElementHandle.is_hidden">is_hidden</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.is_visible" href="#playwright.async_api.ElementHandle.is_visible">is_visible</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.owner_frame" href="#playwright.async_api.ElementHandle.owner_frame">owner_frame</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.press" href="#playwright.async_api.ElementHandle.press">press</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.query_selector" href="#playwright.async_api.ElementHandle.query_selector">query_selector</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.query_selector_all" href="#playwright.async_api.ElementHandle.query_selector_all">query_selector_all</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.screenshot" href="#playwright.async_api.ElementHandle.screenshot">screenshot</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.scroll_into_view_if_needed" href="#playwright.async_api.ElementHandle.scroll_into_view_if_needed">scroll_into_view_if_needed</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.select_option" href="#playwright.async_api.ElementHandle.select_option">select_option</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.select_text" href="#playwright.async_api.ElementHandle.select_text">select_text</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.set_input_files" href="#playwright.async_api.ElementHandle.set_input_files">set_input_files</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.tap" href="#playwright.async_api.ElementHandle.tap">tap</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.text_content" href="#playwright.async_api.ElementHandle.text_content">text_content</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.type" href="#playwright.async_api.ElementHandle.type">type</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.uncheck" href="#playwright.async_api.ElementHandle.uncheck">uncheck</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.wait_for_element_state" href="#playwright.async_api.ElementHandle.wait_for_element_state">wait_for_element_state</a></code></li>
<li><code><a title="playwright.async_api.ElementHandle.wait_for_selector" href="#playwright.async_api.ElementHandle.wait_for_selector">wait_for_selector</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Error" href="#playwright.async_api.Error">Error</a></code></h4>
</li>
<li>
<h4><code><a title="playwright.async_api.FileChooser" href="#playwright.async_api.FileChooser">FileChooser</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.FileChooser.element" href="#playwright.async_api.FileChooser.element">element</a></code></li>
<li><code><a title="playwright.async_api.FileChooser.is_multiple" href="#playwright.async_api.FileChooser.is_multiple">is_multiple</a></code></li>
<li><code><a title="playwright.async_api.FileChooser.page" href="#playwright.async_api.FileChooser.page">page</a></code></li>
<li><code><a title="playwright.async_api.FileChooser.set_files" href="#playwright.async_api.FileChooser.set_files">set_files</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.FilePayload" href="#playwright.async_api.FilePayload">FilePayload</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.FilePayload.buffer" href="#playwright.async_api.FilePayload.buffer">buffer</a></code></li>
<li><code><a title="playwright.async_api.FilePayload.mimeType" href="#playwright.async_api.FilePayload.mimeType">mimeType</a></code></li>
<li><code><a title="playwright.async_api.FilePayload.name" href="#playwright.async_api.FilePayload.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.FloatRect" href="#playwright.async_api.FloatRect">FloatRect</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.FloatRect.height" href="#playwright.async_api.FloatRect.height">height</a></code></li>
<li><code><a title="playwright.async_api.FloatRect.width" href="#playwright.async_api.FloatRect.width">width</a></code></li>
<li><code><a title="playwright.async_api.FloatRect.x" href="#playwright.async_api.FloatRect.x">x</a></code></li>
<li><code><a title="playwright.async_api.FloatRect.y" href="#playwright.async_api.FloatRect.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Frame" href="#playwright.async_api.Frame">Frame</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Frame.add_script_tag" href="#playwright.async_api.Frame.add_script_tag">add_script_tag</a></code></li>
<li><code><a title="playwright.async_api.Frame.add_style_tag" href="#playwright.async_api.Frame.add_style_tag">add_style_tag</a></code></li>
<li><code><a title="playwright.async_api.Frame.check" href="#playwright.async_api.Frame.check">check</a></code></li>
<li><code><a title="playwright.async_api.Frame.child_frames" href="#playwright.async_api.Frame.child_frames">child_frames</a></code></li>
<li><code><a title="playwright.async_api.Frame.click" href="#playwright.async_api.Frame.click">click</a></code></li>
<li><code><a title="playwright.async_api.Frame.content" href="#playwright.async_api.Frame.content">content</a></code></li>
<li><code><a title="playwright.async_api.Frame.dblclick" href="#playwright.async_api.Frame.dblclick">dblclick</a></code></li>
<li><code><a title="playwright.async_api.Frame.dispatch_event" href="#playwright.async_api.Frame.dispatch_event">dispatch_event</a></code></li>
<li><code><a title="playwright.async_api.Frame.eval_on_selector" href="#playwright.async_api.Frame.eval_on_selector">eval_on_selector</a></code></li>
<li><code><a title="playwright.async_api.Frame.eval_on_selector_all" href="#playwright.async_api.Frame.eval_on_selector_all">eval_on_selector_all</a></code></li>
<li><code><a title="playwright.async_api.Frame.evaluate" href="#playwright.async_api.Frame.evaluate">evaluate</a></code></li>
<li><code><a title="playwright.async_api.Frame.evaluate_handle" href="#playwright.async_api.Frame.evaluate_handle">evaluate_handle</a></code></li>
<li><code><a title="playwright.async_api.Frame.expect_navigation" href="#playwright.async_api.Frame.expect_navigation">expect_navigation</a></code></li>
<li><code><a title="playwright.async_api.Frame.fill" href="#playwright.async_api.Frame.fill">fill</a></code></li>
<li><code><a title="playwright.async_api.Frame.focus" href="#playwright.async_api.Frame.focus">focus</a></code></li>
<li><code><a title="playwright.async_api.Frame.frame_element" href="#playwright.async_api.Frame.frame_element">frame_element</a></code></li>
<li><code><a title="playwright.async_api.Frame.get_attribute" href="#playwright.async_api.Frame.get_attribute">get_attribute</a></code></li>
<li><code><a title="playwright.async_api.Frame.goto" href="#playwright.async_api.Frame.goto">goto</a></code></li>
<li><code><a title="playwright.async_api.Frame.hover" href="#playwright.async_api.Frame.hover">hover</a></code></li>
<li><code><a title="playwright.async_api.Frame.inner_html" href="#playwright.async_api.Frame.inner_html">inner_html</a></code></li>
<li><code><a title="playwright.async_api.Frame.inner_text" href="#playwright.async_api.Frame.inner_text">inner_text</a></code></li>
<li><code><a title="playwright.async_api.Frame.is_checked" href="#playwright.async_api.Frame.is_checked">is_checked</a></code></li>
<li><code><a title="playwright.async_api.Frame.is_detached" href="#playwright.async_api.Frame.is_detached">is_detached</a></code></li>
<li><code><a title="playwright.async_api.Frame.is_disabled" href="#playwright.async_api.Frame.is_disabled">is_disabled</a></code></li>
<li><code><a title="playwright.async_api.Frame.is_editable" href="#playwright.async_api.Frame.is_editable">is_editable</a></code></li>
<li><code><a title="playwright.async_api.Frame.is_enabled" href="#playwright.async_api.Frame.is_enabled">is_enabled</a></code></li>
<li><code><a title="playwright.async_api.Frame.is_hidden" href="#playwright.async_api.Frame.is_hidden">is_hidden</a></code></li>
<li><code><a title="playwright.async_api.Frame.is_visible" href="#playwright.async_api.Frame.is_visible">is_visible</a></code></li>
<li><code><a title="playwright.async_api.Frame.name" href="#playwright.async_api.Frame.name">name</a></code></li>
<li><code><a title="playwright.async_api.Frame.page" href="#playwright.async_api.Frame.page">page</a></code></li>
<li><code><a title="playwright.async_api.Frame.parent_frame" href="#playwright.async_api.Frame.parent_frame">parent_frame</a></code></li>
<li><code><a title="playwright.async_api.Frame.press" href="#playwright.async_api.Frame.press">press</a></code></li>
<li><code><a title="playwright.async_api.Frame.query_selector" href="#playwright.async_api.Frame.query_selector">query_selector</a></code></li>
<li><code><a title="playwright.async_api.Frame.query_selector_all" href="#playwright.async_api.Frame.query_selector_all">query_selector_all</a></code></li>
<li><code><a title="playwright.async_api.Frame.select_option" href="#playwright.async_api.Frame.select_option">select_option</a></code></li>
<li><code><a title="playwright.async_api.Frame.set_content" href="#playwright.async_api.Frame.set_content">set_content</a></code></li>
<li><code><a title="playwright.async_api.Frame.set_input_files" href="#playwright.async_api.Frame.set_input_files">set_input_files</a></code></li>
<li><code><a title="playwright.async_api.Frame.tap" href="#playwright.async_api.Frame.tap">tap</a></code></li>
<li><code><a title="playwright.async_api.Frame.text_content" href="#playwright.async_api.Frame.text_content">text_content</a></code></li>
<li><code><a title="playwright.async_api.Frame.title" href="#playwright.async_api.Frame.title">title</a></code></li>
<li><code><a title="playwright.async_api.Frame.type" href="#playwright.async_api.Frame.type">type</a></code></li>
<li><code><a title="playwright.async_api.Frame.uncheck" href="#playwright.async_api.Frame.uncheck">uncheck</a></code></li>
<li><code><a title="playwright.async_api.Frame.url" href="#playwright.async_api.Frame.url">url</a></code></li>
<li><code><a title="playwright.async_api.Frame.wait_for_function" href="#playwright.async_api.Frame.wait_for_function">wait_for_function</a></code></li>
<li><code><a title="playwright.async_api.Frame.wait_for_load_state" href="#playwright.async_api.Frame.wait_for_load_state">wait_for_load_state</a></code></li>
<li><code><a title="playwright.async_api.Frame.wait_for_navigation" href="#playwright.async_api.Frame.wait_for_navigation">wait_for_navigation</a></code></li>
<li><code><a title="playwright.async_api.Frame.wait_for_selector" href="#playwright.async_api.Frame.wait_for_selector">wait_for_selector</a></code></li>
<li><code><a title="playwright.async_api.Frame.wait_for_timeout" href="#playwright.async_api.Frame.wait_for_timeout">wait_for_timeout</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Geolocation" href="#playwright.async_api.Geolocation">Geolocation</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Geolocation.accuracy" href="#playwright.async_api.Geolocation.accuracy">accuracy</a></code></li>
<li><code><a title="playwright.async_api.Geolocation.latitude" href="#playwright.async_api.Geolocation.latitude">latitude</a></code></li>
<li><code><a title="playwright.async_api.Geolocation.longitude" href="#playwright.async_api.Geolocation.longitude">longitude</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.HttpCredentials" href="#playwright.async_api.HttpCredentials">HttpCredentials</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.HttpCredentials.password" href="#playwright.async_api.HttpCredentials.password">password</a></code></li>
<li><code><a title="playwright.async_api.HttpCredentials.username" href="#playwright.async_api.HttpCredentials.username">username</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.JSHandle" href="#playwright.async_api.JSHandle">JSHandle</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.async_api.JSHandle.as_element" href="#playwright.async_api.JSHandle.as_element">as_element</a></code></li>
<li><code><a title="playwright.async_api.JSHandle.dispose" href="#playwright.async_api.JSHandle.dispose">dispose</a></code></li>
<li><code><a title="playwright.async_api.JSHandle.evaluate" href="#playwright.async_api.JSHandle.evaluate">evaluate</a></code></li>
<li><code><a title="playwright.async_api.JSHandle.evaluate_handle" href="#playwright.async_api.JSHandle.evaluate_handle">evaluate_handle</a></code></li>
<li><code><a title="playwright.async_api.JSHandle.get_properties" href="#playwright.async_api.JSHandle.get_properties">get_properties</a></code></li>
<li><code><a title="playwright.async_api.JSHandle.get_property" href="#playwright.async_api.JSHandle.get_property">get_property</a></code></li>
<li><code><a title="playwright.async_api.JSHandle.json_value" href="#playwright.async_api.JSHandle.json_value">json_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Keyboard" href="#playwright.async_api.Keyboard">Keyboard</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Keyboard.down" href="#playwright.async_api.Keyboard.down">down</a></code></li>
<li><code><a title="playwright.async_api.Keyboard.insert_text" href="#playwright.async_api.Keyboard.insert_text">insert_text</a></code></li>
<li><code><a title="playwright.async_api.Keyboard.press" href="#playwright.async_api.Keyboard.press">press</a></code></li>
<li><code><a title="playwright.async_api.Keyboard.type" href="#playwright.async_api.Keyboard.type">type</a></code></li>
<li><code><a title="playwright.async_api.Keyboard.up" href="#playwright.async_api.Keyboard.up">up</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Mouse" href="#playwright.async_api.Mouse">Mouse</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Mouse.click" href="#playwright.async_api.Mouse.click">click</a></code></li>
<li><code><a title="playwright.async_api.Mouse.dblclick" href="#playwright.async_api.Mouse.dblclick">dblclick</a></code></li>
<li><code><a title="playwright.async_api.Mouse.down" href="#playwright.async_api.Mouse.down">down</a></code></li>
<li><code><a title="playwright.async_api.Mouse.move" href="#playwright.async_api.Mouse.move">move</a></code></li>
<li><code><a title="playwright.async_api.Mouse.up" href="#playwright.async_api.Mouse.up">up</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Page" href="#playwright.async_api.Page">Page</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Page.accessibility" href="#playwright.async_api.Page.accessibility">accessibility</a></code></li>
<li><code><a title="playwright.async_api.Page.add_init_script" href="#playwright.async_api.Page.add_init_script">add_init_script</a></code></li>
<li><code><a title="playwright.async_api.Page.add_script_tag" href="#playwright.async_api.Page.add_script_tag">add_script_tag</a></code></li>
<li><code><a title="playwright.async_api.Page.add_style_tag" href="#playwright.async_api.Page.add_style_tag">add_style_tag</a></code></li>
<li><code><a title="playwright.async_api.Page.bring_to_front" href="#playwright.async_api.Page.bring_to_front">bring_to_front</a></code></li>
<li><code><a title="playwright.async_api.Page.check" href="#playwright.async_api.Page.check">check</a></code></li>
<li><code><a title="playwright.async_api.Page.click" href="#playwright.async_api.Page.click">click</a></code></li>
<li><code><a title="playwright.async_api.Page.close" href="#playwright.async_api.Page.close">close</a></code></li>
<li><code><a title="playwright.async_api.Page.content" href="#playwright.async_api.Page.content">content</a></code></li>
<li><code><a title="playwright.async_api.Page.context" href="#playwright.async_api.Page.context">context</a></code></li>
<li><code><a title="playwright.async_api.Page.dblclick" href="#playwright.async_api.Page.dblclick">dblclick</a></code></li>
<li><code><a title="playwright.async_api.Page.dispatch_event" href="#playwright.async_api.Page.dispatch_event">dispatch_event</a></code></li>
<li><code><a title="playwright.async_api.Page.emulate_media" href="#playwright.async_api.Page.emulate_media">emulate_media</a></code></li>
<li><code><a title="playwright.async_api.Page.eval_on_selector" href="#playwright.async_api.Page.eval_on_selector">eval_on_selector</a></code></li>
<li><code><a title="playwright.async_api.Page.eval_on_selector_all" href="#playwright.async_api.Page.eval_on_selector_all">eval_on_selector_all</a></code></li>
<li><code><a title="playwright.async_api.Page.evaluate" href="#playwright.async_api.Page.evaluate">evaluate</a></code></li>
<li><code><a title="playwright.async_api.Page.evaluate_handle" href="#playwright.async_api.Page.evaluate_handle">evaluate_handle</a></code></li>
<li><code><a title="playwright.async_api.Page.expect_console_message" href="#playwright.async_api.Page.expect_console_message">expect_console_message</a></code></li>
<li><code><a title="playwright.async_api.Page.expect_download" href="#playwright.async_api.Page.expect_download">expect_download</a></code></li>
<li><code><a title="playwright.async_api.Page.expect_event" href="#playwright.async_api.Page.expect_event">expect_event</a></code></li>
<li><code><a title="playwright.async_api.Page.expect_file_chooser" href="#playwright.async_api.Page.expect_file_chooser">expect_file_chooser</a></code></li>
<li><code><a title="playwright.async_api.Page.expect_navigation" href="#playwright.async_api.Page.expect_navigation">expect_navigation</a></code></li>
<li><code><a title="playwright.async_api.Page.expect_popup" href="#playwright.async_api.Page.expect_popup">expect_popup</a></code></li>
<li><code><a title="playwright.async_api.Page.expect_request" href="#playwright.async_api.Page.expect_request">expect_request</a></code></li>
<li><code><a title="playwright.async_api.Page.expect_response" href="#playwright.async_api.Page.expect_response">expect_response</a></code></li>
<li><code><a title="playwright.async_api.Page.expect_worker" href="#playwright.async_api.Page.expect_worker">expect_worker</a></code></li>
<li><code><a title="playwright.async_api.Page.expose_binding" href="#playwright.async_api.Page.expose_binding">expose_binding</a></code></li>
<li><code><a title="playwright.async_api.Page.expose_function" href="#playwright.async_api.Page.expose_function">expose_function</a></code></li>
<li><code><a title="playwright.async_api.Page.fill" href="#playwright.async_api.Page.fill">fill</a></code></li>
<li><code><a title="playwright.async_api.Page.focus" href="#playwright.async_api.Page.focus">focus</a></code></li>
<li><code><a title="playwright.async_api.Page.frame" href="#playwright.async_api.Page.frame">frame</a></code></li>
<li><code><a title="playwright.async_api.Page.frames" href="#playwright.async_api.Page.frames">frames</a></code></li>
<li><code><a title="playwright.async_api.Page.get_attribute" href="#playwright.async_api.Page.get_attribute">get_attribute</a></code></li>
<li><code><a title="playwright.async_api.Page.go_back" href="#playwright.async_api.Page.go_back">go_back</a></code></li>
<li><code><a title="playwright.async_api.Page.go_forward" href="#playwright.async_api.Page.go_forward">go_forward</a></code></li>
<li><code><a title="playwright.async_api.Page.goto" href="#playwright.async_api.Page.goto">goto</a></code></li>
<li><code><a title="playwright.async_api.Page.hover" href="#playwright.async_api.Page.hover">hover</a></code></li>
<li><code><a title="playwright.async_api.Page.inner_html" href="#playwright.async_api.Page.inner_html">inner_html</a></code></li>
<li><code><a title="playwright.async_api.Page.inner_text" href="#playwright.async_api.Page.inner_text">inner_text</a></code></li>
<li><code><a title="playwright.async_api.Page.is_checked" href="#playwright.async_api.Page.is_checked">is_checked</a></code></li>
<li><code><a title="playwright.async_api.Page.is_closed" href="#playwright.async_api.Page.is_closed">is_closed</a></code></li>
<li><code><a title="playwright.async_api.Page.is_disabled" href="#playwright.async_api.Page.is_disabled">is_disabled</a></code></li>
<li><code><a title="playwright.async_api.Page.is_editable" href="#playwright.async_api.Page.is_editable">is_editable</a></code></li>
<li><code><a title="playwright.async_api.Page.is_enabled" href="#playwright.async_api.Page.is_enabled">is_enabled</a></code></li>
<li><code><a title="playwright.async_api.Page.is_hidden" href="#playwright.async_api.Page.is_hidden">is_hidden</a></code></li>
<li><code><a title="playwright.async_api.Page.is_visible" href="#playwright.async_api.Page.is_visible">is_visible</a></code></li>
<li><code><a title="playwright.async_api.Page.keyboard" href="#playwright.async_api.Page.keyboard">keyboard</a></code></li>
<li><code><a title="playwright.async_api.Page.main_frame" href="#playwright.async_api.Page.main_frame">main_frame</a></code></li>
<li><code><a title="playwright.async_api.Page.mouse" href="#playwright.async_api.Page.mouse">mouse</a></code></li>
<li><code><a title="playwright.async_api.Page.opener" href="#playwright.async_api.Page.opener">opener</a></code></li>
<li><code><a title="playwright.async_api.Page.pdf" href="#playwright.async_api.Page.pdf">pdf</a></code></li>
<li><code><a title="playwright.async_api.Page.press" href="#playwright.async_api.Page.press">press</a></code></li>
<li><code><a title="playwright.async_api.Page.query_selector" href="#playwright.async_api.Page.query_selector">query_selector</a></code></li>
<li><code><a title="playwright.async_api.Page.query_selector_all" href="#playwright.async_api.Page.query_selector_all">query_selector_all</a></code></li>
<li><code><a title="playwright.async_api.Page.reload" href="#playwright.async_api.Page.reload">reload</a></code></li>
<li><code><a title="playwright.async_api.Page.route" href="#playwright.async_api.Page.route">route</a></code></li>
<li><code><a title="playwright.async_api.Page.screenshot" href="#playwright.async_api.Page.screenshot">screenshot</a></code></li>
<li><code><a title="playwright.async_api.Page.select_option" href="#playwright.async_api.Page.select_option">select_option</a></code></li>
<li><code><a title="playwright.async_api.Page.set_content" href="#playwright.async_api.Page.set_content">set_content</a></code></li>
<li><code><a title="playwright.async_api.Page.set_default_navigation_timeout" href="#playwright.async_api.Page.set_default_navigation_timeout">set_default_navigation_timeout</a></code></li>
<li><code><a title="playwright.async_api.Page.set_default_timeout" href="#playwright.async_api.Page.set_default_timeout">set_default_timeout</a></code></li>
<li><code><a title="playwright.async_api.Page.set_extra_http_headers" href="#playwright.async_api.Page.set_extra_http_headers">set_extra_http_headers</a></code></li>
<li><code><a title="playwright.async_api.Page.set_input_files" href="#playwright.async_api.Page.set_input_files">set_input_files</a></code></li>
<li><code><a title="playwright.async_api.Page.set_viewport_size" href="#playwright.async_api.Page.set_viewport_size">set_viewport_size</a></code></li>
<li><code><a title="playwright.async_api.Page.tap" href="#playwright.async_api.Page.tap">tap</a></code></li>
<li><code><a title="playwright.async_api.Page.text_content" href="#playwright.async_api.Page.text_content">text_content</a></code></li>
<li><code><a title="playwright.async_api.Page.title" href="#playwright.async_api.Page.title">title</a></code></li>
<li><code><a title="playwright.async_api.Page.touchscreen" href="#playwright.async_api.Page.touchscreen">touchscreen</a></code></li>
<li><code><a title="playwright.async_api.Page.type" href="#playwright.async_api.Page.type">type</a></code></li>
<li><code><a title="playwright.async_api.Page.uncheck" href="#playwright.async_api.Page.uncheck">uncheck</a></code></li>
<li><code><a title="playwright.async_api.Page.unroute" href="#playwright.async_api.Page.unroute">unroute</a></code></li>
<li><code><a title="playwright.async_api.Page.url" href="#playwright.async_api.Page.url">url</a></code></li>
<li><code><a title="playwright.async_api.Page.video" href="#playwright.async_api.Page.video">video</a></code></li>
<li><code><a title="playwright.async_api.Page.viewport_size" href="#playwright.async_api.Page.viewport_size">viewport_size</a></code></li>
<li><code><a title="playwright.async_api.Page.wait_for_event" href="#playwright.async_api.Page.wait_for_event">wait_for_event</a></code></li>
<li><code><a title="playwright.async_api.Page.wait_for_function" href="#playwright.async_api.Page.wait_for_function">wait_for_function</a></code></li>
<li><code><a title="playwright.async_api.Page.wait_for_load_state" href="#playwright.async_api.Page.wait_for_load_state">wait_for_load_state</a></code></li>
<li><code><a title="playwright.async_api.Page.wait_for_navigation" href="#playwright.async_api.Page.wait_for_navigation">wait_for_navigation</a></code></li>
<li><code><a title="playwright.async_api.Page.wait_for_request" href="#playwright.async_api.Page.wait_for_request">wait_for_request</a></code></li>
<li><code><a title="playwright.async_api.Page.wait_for_response" href="#playwright.async_api.Page.wait_for_response">wait_for_response</a></code></li>
<li><code><a title="playwright.async_api.Page.wait_for_selector" href="#playwright.async_api.Page.wait_for_selector">wait_for_selector</a></code></li>
<li><code><a title="playwright.async_api.Page.wait_for_timeout" href="#playwright.async_api.Page.wait_for_timeout">wait_for_timeout</a></code></li>
<li><code><a title="playwright.async_api.Page.workers" href="#playwright.async_api.Page.workers">workers</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.PdfMargins" href="#playwright.async_api.PdfMargins">PdfMargins</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.PdfMargins.bottom" href="#playwright.async_api.PdfMargins.bottom">bottom</a></code></li>
<li><code><a title="playwright.async_api.PdfMargins.left" href="#playwright.async_api.PdfMargins.left">left</a></code></li>
<li><code><a title="playwright.async_api.PdfMargins.right" href="#playwright.async_api.PdfMargins.right">right</a></code></li>
<li><code><a title="playwright.async_api.PdfMargins.top" href="#playwright.async_api.PdfMargins.top">top</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Playwright" href="#playwright.async_api.Playwright">Playwright</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.async_api.Playwright.chromium" href="#playwright.async_api.Playwright.chromium">chromium</a></code></li>
<li><code><a title="playwright.async_api.Playwright.devices" href="#playwright.async_api.Playwright.devices">devices</a></code></li>
<li><code><a title="playwright.async_api.Playwright.firefox" href="#playwright.async_api.Playwright.firefox">firefox</a></code></li>
<li><code><a title="playwright.async_api.Playwright.selectors" href="#playwright.async_api.Playwright.selectors">selectors</a></code></li>
<li><code><a title="playwright.async_api.Playwright.stop" href="#playwright.async_api.Playwright.stop">stop</a></code></li>
<li><code><a title="playwright.async_api.Playwright.webkit" href="#playwright.async_api.Playwright.webkit">webkit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Position" href="#playwright.async_api.Position">Position</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Position.x" href="#playwright.async_api.Position.x">x</a></code></li>
<li><code><a title="playwright.async_api.Position.y" href="#playwright.async_api.Position.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.ProxySettings" href="#playwright.async_api.ProxySettings">ProxySettings</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.ProxySettings.bypass" href="#playwright.async_api.ProxySettings.bypass">bypass</a></code></li>
<li><code><a title="playwright.async_api.ProxySettings.password" href="#playwright.async_api.ProxySettings.password">password</a></code></li>
<li><code><a title="playwright.async_api.ProxySettings.server" href="#playwright.async_api.ProxySettings.server">server</a></code></li>
<li><code><a title="playwright.async_api.ProxySettings.username" href="#playwright.async_api.ProxySettings.username">username</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Request" href="#playwright.async_api.Request">Request</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Request.failure" href="#playwright.async_api.Request.failure">failure</a></code></li>
<li><code><a title="playwright.async_api.Request.frame" href="#playwright.async_api.Request.frame">frame</a></code></li>
<li><code><a title="playwright.async_api.Request.headers" href="#playwright.async_api.Request.headers">headers</a></code></li>
<li><code><a title="playwright.async_api.Request.is_navigation_request" href="#playwright.async_api.Request.is_navigation_request">is_navigation_request</a></code></li>
<li><code><a title="playwright.async_api.Request.method" href="#playwright.async_api.Request.method">method</a></code></li>
<li><code><a title="playwright.async_api.Request.post_data" href="#playwright.async_api.Request.post_data">post_data</a></code></li>
<li><code><a title="playwright.async_api.Request.post_data_buffer" href="#playwright.async_api.Request.post_data_buffer">post_data_buffer</a></code></li>
<li><code><a title="playwright.async_api.Request.post_data_json" href="#playwright.async_api.Request.post_data_json">post_data_json</a></code></li>
<li><code><a title="playwright.async_api.Request.redirected_from" href="#playwright.async_api.Request.redirected_from">redirected_from</a></code></li>
<li><code><a title="playwright.async_api.Request.redirected_to" href="#playwright.async_api.Request.redirected_to">redirected_to</a></code></li>
<li><code><a title="playwright.async_api.Request.resource_type" href="#playwright.async_api.Request.resource_type">resource_type</a></code></li>
<li><code><a title="playwright.async_api.Request.response" href="#playwright.async_api.Request.response">response</a></code></li>
<li><code><a title="playwright.async_api.Request.timing" href="#playwright.async_api.Request.timing">timing</a></code></li>
<li><code><a title="playwright.async_api.Request.url" href="#playwright.async_api.Request.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.ResourceTiming" href="#playwright.async_api.ResourceTiming">ResourceTiming</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.ResourceTiming.connectEnd" href="#playwright.async_api.ResourceTiming.connectEnd">connectEnd</a></code></li>
<li><code><a title="playwright.async_api.ResourceTiming.connectStart" href="#playwright.async_api.ResourceTiming.connectStart">connectStart</a></code></li>
<li><code><a title="playwright.async_api.ResourceTiming.domainLookupEnd" href="#playwright.async_api.ResourceTiming.domainLookupEnd">domainLookupEnd</a></code></li>
<li><code><a title="playwright.async_api.ResourceTiming.domainLookupStart" href="#playwright.async_api.ResourceTiming.domainLookupStart">domainLookupStart</a></code></li>
<li><code><a title="playwright.async_api.ResourceTiming.requestStart" href="#playwright.async_api.ResourceTiming.requestStart">requestStart</a></code></li>
<li><code><a title="playwright.async_api.ResourceTiming.responseEnd" href="#playwright.async_api.ResourceTiming.responseEnd">responseEnd</a></code></li>
<li><code><a title="playwright.async_api.ResourceTiming.responseStart" href="#playwright.async_api.ResourceTiming.responseStart">responseStart</a></code></li>
<li><code><a title="playwright.async_api.ResourceTiming.secureConnectionStart" href="#playwright.async_api.ResourceTiming.secureConnectionStart">secureConnectionStart</a></code></li>
<li><code><a title="playwright.async_api.ResourceTiming.startTime" href="#playwright.async_api.ResourceTiming.startTime">startTime</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Response" href="#playwright.async_api.Response">Response</a></code></h4>
<ul class="two-column">
<li><code><a title="playwright.async_api.Response.body" href="#playwright.async_api.Response.body">body</a></code></li>
<li><code><a title="playwright.async_api.Response.finished" href="#playwright.async_api.Response.finished">finished</a></code></li>
<li><code><a title="playwright.async_api.Response.frame" href="#playwright.async_api.Response.frame">frame</a></code></li>
<li><code><a title="playwright.async_api.Response.headers" href="#playwright.async_api.Response.headers">headers</a></code></li>
<li><code><a title="playwright.async_api.Response.json" href="#playwright.async_api.Response.json">json</a></code></li>
<li><code><a title="playwright.async_api.Response.ok" href="#playwright.async_api.Response.ok">ok</a></code></li>
<li><code><a title="playwright.async_api.Response.request" href="#playwright.async_api.Response.request">request</a></code></li>
<li><code><a title="playwright.async_api.Response.status" href="#playwright.async_api.Response.status">status</a></code></li>
<li><code><a title="playwright.async_api.Response.status_text" href="#playwright.async_api.Response.status_text">status_text</a></code></li>
<li><code><a title="playwright.async_api.Response.text" href="#playwright.async_api.Response.text">text</a></code></li>
<li><code><a title="playwright.async_api.Response.url" href="#playwright.async_api.Response.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Route" href="#playwright.async_api.Route">Route</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Route.abort" href="#playwright.async_api.Route.abort">abort</a></code></li>
<li><code><a title="playwright.async_api.Route.continue_" href="#playwright.async_api.Route.continue_">continue_</a></code></li>
<li><code><a title="playwright.async_api.Route.fulfill" href="#playwright.async_api.Route.fulfill">fulfill</a></code></li>
<li><code><a title="playwright.async_api.Route.request" href="#playwright.async_api.Route.request">request</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Selectors" href="#playwright.async_api.Selectors">Selectors</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Selectors.register" href="#playwright.async_api.Selectors.register">register</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.SourceLocation" href="#playwright.async_api.SourceLocation">SourceLocation</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.SourceLocation.columnNumber" href="#playwright.async_api.SourceLocation.columnNumber">columnNumber</a></code></li>
<li><code><a title="playwright.async_api.SourceLocation.lineNumber" href="#playwright.async_api.SourceLocation.lineNumber">lineNumber</a></code></li>
<li><code><a title="playwright.async_api.SourceLocation.url" href="#playwright.async_api.SourceLocation.url">url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.StorageState" href="#playwright.async_api.StorageState">StorageState</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.StorageState.cookies" href="#playwright.async_api.StorageState.cookies">cookies</a></code></li>
<li><code><a title="playwright.async_api.StorageState.origins" href="#playwright.async_api.StorageState.origins">origins</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.TimeoutError" href="#playwright.async_api.TimeoutError">TimeoutError</a></code></h4>
</li>
<li>
<h4><code><a title="playwright.async_api.Touchscreen" href="#playwright.async_api.Touchscreen">Touchscreen</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Touchscreen.tap" href="#playwright.async_api.Touchscreen.tap">tap</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Video" href="#playwright.async_api.Video">Video</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Video.path" href="#playwright.async_api.Video.path">path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.ViewportSize" href="#playwright.async_api.ViewportSize">ViewportSize</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.ViewportSize.height" href="#playwright.async_api.ViewportSize.height">height</a></code></li>
<li><code><a title="playwright.async_api.ViewportSize.width" href="#playwright.async_api.ViewportSize.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.WebSocket" href="#playwright.async_api.WebSocket">WebSocket</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.WebSocket.expect_event" href="#playwright.async_api.WebSocket.expect_event">expect_event</a></code></li>
<li><code><a title="playwright.async_api.WebSocket.is_closed" href="#playwright.async_api.WebSocket.is_closed">is_closed</a></code></li>
<li><code><a title="playwright.async_api.WebSocket.url" href="#playwright.async_api.WebSocket.url">url</a></code></li>
<li><code><a title="playwright.async_api.WebSocket.wait_for_event" href="#playwright.async_api.WebSocket.wait_for_event">wait_for_event</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="playwright.async_api.Worker" href="#playwright.async_api.Worker">Worker</a></code></h4>
<ul class="">
<li><code><a title="playwright.async_api.Worker.evaluate" href="#playwright.async_api.Worker.evaluate">evaluate</a></code></li>
<li><code><a title="playwright.async_api.Worker.evaluate_handle" href="#playwright.async_api.Worker.evaluate_handle">evaluate_handle</a></code></li>
<li><code><a title="playwright.async_api.Worker.url" href="#playwright.async_api.Worker.url">url</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>